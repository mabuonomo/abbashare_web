{"version":3,"sources":["../src/model/mutation.ts"],"names":[],"mappings":"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","file":"mutation.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\n\nimport { Document, MaybeDocument, NoDocument } from './document';\nimport { DocumentKey } from './document_key';\nimport { FieldValue, ObjectValue, ServerTimestampValue } from './field_value';\nimport { FieldPath } from './path';\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nexport class FieldMask {\n  constructor(readonly fields: FieldPath[]) {\n    // TODO(dimond): validation of FieldMask\n  }\n\n  equals(other: FieldMask): boolean {\n    return misc.arrayEquals(this.fields, other.fields);\n  }\n}\n\n/** Represents a transform within a TransformMutation. */\nexport interface TransformOperation {\n  equals(other: TransformOperation): boolean;\n}\n\n/** Transforms a value into a server-generated timestamp. */\nexport class ServerTimestampTransform implements TransformOperation {\n  private constructor() {}\n  static instance = new ServerTimestampTransform();\n\n  equals(other: TransformOperation): boolean {\n    return other instanceof ServerTimestampTransform;\n  }\n}\n\n/** A field path and the TransformOperation to perform upon it. */\nexport class FieldTransform {\n  constructor(\n    readonly field: FieldPath,\n    readonly transform: TransformOperation\n  ) {}\n\n  equals(other: FieldTransform): boolean {\n    return (\n      this.field.equals(other.field) && this.transform.equals(other.transform)\n    );\n  }\n}\n\n/** The result of successfully applying a mutation to the backend. */\nexport class MutationResult {\n  constructor(\n    /**\n       * The version at which the mutation was committed or null for a delete.\n       */\n    readonly version: SnapshotVersion | null,\n    /**\n       * The resulting fields returned from the backend after a\n       * TransformMutation has been committed. Contains one FieldValue for each\n       * FieldTransform that was in the mutation.\n       *\n       * Will be null if the mutation was not a TransformMutation.\n       */\n    readonly transformResults: FieldValue[] | null\n  ) {}\n}\n\nexport enum MutationType {\n  Set,\n  Patch,\n  Transform,\n  Delete\n}\n\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nexport class Precondition {\n  static readonly NONE = new Precondition();\n\n  private constructor(\n    public readonly updateTime?: SnapshotVersion,\n    public readonly exists?: boolean\n  ) {\n    assert(\n      updateTime === undefined || exists === undefined,\n      'Precondition can specify \"exists\" or \"updateTime\" but not both'\n    );\n  }\n\n  /** Creates a new Precondition with an exists flag. */\n  static exists(exists: boolean) {\n    return new Precondition(undefined, exists);\n  }\n\n  /** Creates a new Precondition based on a version a document exists at. */\n  static updateTime(version: SnapshotVersion) {\n    return new Precondition(version);\n  }\n\n  /** Returns whether this Precondition is empty. */\n  get isNone(): boolean {\n    return this.updateTime === undefined && this.exists === undefined;\n  }\n\n  /**\n   * Returns true if the preconditions is valid for the given document\n   * (or null if no document is available).\n   */\n  isValidFor(maybeDoc: MaybeDocument | null) {\n    if (this.updateTime !== undefined) {\n      return (\n        maybeDoc instanceof Document && maybeDoc.version.equals(this.updateTime)\n      );\n    } else if (this.exists !== undefined) {\n      if (this.exists) {\n        return maybeDoc instanceof Document;\n      } else {\n        return maybeDoc === null || maybeDoc instanceof NoDocument;\n      }\n    } else {\n      assert(this.isNone, 'Precondition should be empty');\n      return true;\n    }\n  }\n\n  equals(other: Precondition) {\n    return (\n      misc.equals(this.updateTime, other.updateTime) &&\n      this.exists === other.exists\n    );\n  }\n}\n\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nexport abstract class Mutation {\n  readonly type: MutationType;\n  readonly key: DocumentKey;\n  readonly precondition: Precondition;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing a new remote document. Both the input and returned documents\n   * can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param mutationResult The result of applying the mutation from the backend.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing the new local view of a document. Both the input and returned\n   * documents can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param localWriteTime A timestamp indicating the local write time of the\n   *     batch this mutation is a part of.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null;\n\n  abstract equals(other: Mutation): boolean;\n\n  protected verifyKeyMatches(maybeDoc: MaybeDocument | null): void {\n    if (maybeDoc != null) {\n      assert(\n        maybeDoc.key.equals(this.key),\n        'Can only apply a mutation to a document with the same key'\n      );\n    }\n  }\n\n  /**\n   * Returns the version from the given document for use as the result of a\n   * mutation. Mutations are defined to return the version of the base document\n   * only if it is an existing document. Deleted and unknown documents have a\n   * post-mutation version of SnapshotVersion.MIN.\n   */\n  protected static getPostMutationVersion(\n    maybeDoc: MaybeDocument | null\n  ): SnapshotVersion {\n    if (maybeDoc instanceof Document) {\n      return maybeDoc.version;\n    } else {\n      return SnapshotVersion.MIN;\n    }\n  }\n}\n\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nexport class SetMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly value: ObjectValue,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Set;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by SetMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof SetMutation &&\n      this.key.equals(other.key) &&\n      this.value.equals(other.value) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n}\n\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nexport class PatchMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Patch;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by PatchMutation.'\n    );\n\n    // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof PatchMutation &&\n      this.key.equals(other.key) &&\n      this.fieldMask.equals(other.fieldMask) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n\n  /**\n   * Patches the data of document if available or creates a new document. Note\n   * that this does not check whether or not the precondition of this patch\n   * holds.\n   */\n  private patchDocument(maybeDoc: MaybeDocument | null): ObjectValue {\n    let data: ObjectValue;\n    if (maybeDoc instanceof Document) {\n      data = maybeDoc.data;\n    } else {\n      data = ObjectValue.EMPTY;\n    }\n    return this.patchObject(data);\n  }\n\n  private patchObject(data: ObjectValue): ObjectValue {\n    for (const fieldPath of this.fieldMask.fields) {\n      const newValue = this.data.field(fieldPath);\n      if (newValue !== undefined) {\n        data = data.set(fieldPath, newValue);\n      } else {\n        data = data.delete(fieldPath);\n      }\n    }\n    return data;\n  }\n}\n\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nexport class TransformMutation extends Mutation {\n  readonly type: MutationType = MutationType.Transform;\n\n  // NOTE: We set a precondition of exists: true as a safety-check, since we\n  // always combine TransformMutations with a SetMutation or PatchMutation which\n  // (if successful) should end up with an existing document.\n  readonly precondition = Precondition.exists(true);\n\n  constructor(\n    readonly key: DocumentKey,\n    readonly fieldTransforms: FieldTransform[]\n  ) {\n    super();\n  }\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults != null,\n      'Transform results missing for TransformMutation.'\n    );\n    const transformResults = mutationResult.transformResults!;\n\n    // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const transformResults = this.localTransformResults(localWriteTime);\n    const newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof TransformMutation &&\n      this.key.equals(other.key) &&\n      misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n\n  /**\n   * Asserts that the given MaybeDocument is actually a Document and verifies\n   * that it matches the key for this mutation. Since we only support\n   * transformations with precondition exists this method is guaranteed to be\n   * safe.\n   */\n  private requireDocument(maybeDoc: MaybeDocument | null): Document {\n    assert(\n      maybeDoc instanceof Document,\n      'Unknown MaybeDocument type ' + maybeDoc\n    );\n    const doc = maybeDoc! as Document;\n    assert(\n      doc.key.equals(this.key),\n      'Can only transform a document with the same key'\n    );\n    return doc;\n  }\n\n  /**\n   * Creates a list of \"transform results\" (a transform result is a field value\n   * representing the result of applying a transform) for use when applying a\n   * TransformMutation locally.\n   *\n   * @param localWriteTime The local time of the transform mutation (used to\n   *     generate ServerTimestampValues).\n   * @return The transform results list.\n   */\n  private localTransformResults(localWriteTime: Timestamp): FieldValue[] {\n    const transformResults = [] as FieldValue[];\n    for (const fieldTransform of this.fieldTransforms) {\n      const transform = fieldTransform.transform;\n      if (transform instanceof ServerTimestampTransform) {\n        transformResults.push(new ServerTimestampValue(localWriteTime));\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n    return transformResults;\n  }\n\n  private transformObject(\n    data: ObjectValue,\n    transformResults: FieldValue[]\n  ): ObjectValue {\n    assert(\n      transformResults.length === this.fieldTransforms.length,\n      'TransformResults length mismatch.'\n    );\n\n    for (let i = 0; i < this.fieldTransforms.length; i++) {\n      const fieldTransform = this.fieldTransforms[i];\n      const transform = fieldTransform.transform;\n      const fieldPath = fieldTransform.field;\n      if (transform instanceof ServerTimestampTransform) {\n        data = data.set(fieldPath, transformResults[i]);\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n    return data;\n  }\n}\n\n/** A mutation that deletes the document at the given key. */\nexport class DeleteMutation extends Mutation {\n  constructor(readonly key: DocumentKey, readonly precondition: Precondition) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Delete;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by DeleteMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    return new NoDocument(this.key, SnapshotVersion.MIN);\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(this.key),\n        'Can only apply mutation to document with same key'\n      );\n    }\n    return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof DeleteMutation &&\n      this.key.equals(other.key) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n}\n"]}