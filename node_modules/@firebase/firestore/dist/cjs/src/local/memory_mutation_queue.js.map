{"version":3,"sources":["../src/local/memory_mutation_queue.ts"],"names":[],"mappings":"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","file":"memory_mutation_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\n\nexport class MemoryMutationQueue implements MutationQueue {\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  private mutationQueue: MutationBatch[] = [];\n\n  /** Next value to use when assigning sequential IDs to each mutation batch. */\n  private nextBatchId: BatchId = 1;\n\n  /** The highest acknowledged mutation in the queue. */\n  private highestAcknowledgedBatchId: BatchId = BATCHID_UNKNOWN;\n\n  /** The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   */\n  private lastStreamToken: ProtoByteString = emptyByteString();\n\n  /** The garbage collector to notify about potential garbage keys. */\n  private garbageCollector: GarbageCollector | null = null;\n\n  /** An ordered mapping between documents and the mutations batch IDs. */\n  private batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    // NOTE: The queue may be shutdown / started multiple times, since we\n    // maintain the queue for the duration of the app session in case a user\n    // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n    // accommodate tests that expect as much), we reset nextBatchId and\n    // highestAcknowledgedBatchId if the queue is empty.\n    if (this.mutationQueue.length === 0) {\n      this.nextBatchId = 1;\n      this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n    }\n    assert(\n      this.highestAcknowledgedBatchId < this.nextBatchId,\n      'highestAcknowledgedBatchId must be less than the nextBatchId'\n    );\n    return PersistencePromise.resolve();\n  }\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    return PersistencePromise.resolve(this.mutationQueue.length === 0);\n  }\n\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.nextBatchId);\n  }\n\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n  }\n\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    const batchId = batch.batchId;\n    assert(\n      batchId > this.highestAcknowledgedBatchId,\n      'Mutation batchIDs must be acknowledged in order'\n    );\n\n    const batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n\n    // Verify that the batch in the queue is the one to be acknowledged.\n    const check = this.mutationQueue[batchIndex];\n    assert(\n      batchId === check.batchId,\n      'Queue ordering failure: expected batch ' +\n        batchId +\n        ', got batch ' +\n        check.batchId\n    );\n    assert(\n      !check.isTombstone(),\n      \"Can't acknowledge a previously removed batch\"\n    );\n\n    this.highestAcknowledgedBatchId = batchId;\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  }\n\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString> {\n    return PersistencePromise.resolve(this.lastStreamToken);\n  }\n\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    assert(mutations.length !== 0, 'Mutation batches should not be empty');\n\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n\n    if (this.mutationQueue.length > 0) {\n      const prior = this.mutationQueue[this.mutationQueue.length - 1];\n      assert(\n        prior.batchId < batchId,\n        'Mutation batchIDs must be monotonically increasing order'\n      );\n    }\n\n    const batch = new MutationBatch(batchId, localWriteTime, mutations);\n    this.mutationQueue.push(batch);\n\n    // Track references by document key.\n    for (const mutation of mutations) {\n      this.batchesByDocumentKey = this.batchesByDocumentKey.add(\n        new DocReference(mutation.key, batchId)\n      );\n    }\n\n    return PersistencePromise.resolve(batch);\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return PersistencePromise.resolve(this.findMutationBatch(batchId));\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const size = this.mutationQueue.length;\n\n    // All batches with batchId <= this.highestAcknowledgedBatchId have been\n    // acknowledged so the first unacknowledged batch after batchID will have a\n    // batchID larger than both of these values.\n    batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);\n\n    // The requested batchId may still be out of range so normalize it to the\n    // start of the queue.\n    const rawIndex = this.indexOfBatchId(batchId);\n    let index = rawIndex < 0 ? 0 : rawIndex;\n\n    // Finally return the first non-tombstone batch.\n    for (; index < size; index++) {\n      const batch = this.mutationQueue[index];\n      if (!batch.isTombstone()) {\n        return PersistencePromise.resolve(batch);\n      }\n    }\n    return PersistencePromise.resolve(null);\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    return PersistencePromise.resolve(\n      this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length)\n    );\n  }\n\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]> {\n    const count = this.mutationQueue.length;\n\n    let endIndex = this.indexOfBatchId(batchId);\n    if (endIndex < 0) {\n      endIndex = 0;\n    } else if (endIndex >= count) {\n      endIndex = count;\n    } else {\n      // The endIndex is in the queue so increment to pull everything in the\n      // queue including it.\n      endIndex++;\n    }\n\n    return PersistencePromise.resolve(\n      this.getAllLiveMutationBatchesBeforeIndex(endIndex)\n    );\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    const start = new DocReference(documentKey, 0);\n    const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n    const result: MutationBatch[] = [];\n    this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n      assert(\n        documentKey.equals(ref.key),\n        \"Should only iterate over a single key's batches\"\n      );\n      const batch = this.findMutationBatch(ref.targetOrBatchId);\n      assert(\n        batch !== null,\n        'Batches in the index must exist in the main table'\n      );\n      result.push(batch!);\n    });\n\n    return PersistencePromise.resolve(result);\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    // Use the query path as a prefix for testing if a document matches the\n    // query.\n    const prefix = query.path;\n    const immediateChildrenPathLength = prefix.length + 1;\n\n    // Construct a document reference for actually scanning the index. Unlike\n    // the prefix the document key in this reference must have an even number of\n    // segments. The empty segment can be used a suffix of the query path\n    // because it precedes all other segments in an ordered traversal.\n    let startPath = prefix;\n    if (!DocumentKey.isDocumentKey(startPath)) {\n      startPath = startPath.child('');\n    }\n\n    const start = new DocReference(new DocumentKey(startPath), 0);\n\n    // Find unique batchIDs referenced by all documents potentially matching the\n    // query.\n    let uniqueBatchIDs = new SortedSet<number>(primitiveComparator);\n\n    this.batchesByDocumentKey.forEachWhile(ref => {\n      const rowKeyPath = ref.key.path;\n      if (!prefix.isPrefixOf(rowKeyPath)) {\n        return false;\n      } else {\n        // Rows with document keys more than one segment longer than the query\n        // path can't be matches. For example, a query on 'rooms' can't match\n        // the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (rowKeyPath.length === immediateChildrenPathLength) {\n          uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n        }\n        return true;\n      }\n    }, start);\n\n    // Construct an array of matching batches, sorted by batchID to ensure that\n    // multiple mutations affecting the same document key are applied in order.\n    const result: MutationBatch[] = [];\n    uniqueBatchIDs.forEach(batchId => {\n      const batch = this.findMutationBatch(batchId);\n      if (batch !== null) {\n        result.push(batch);\n      }\n    });\n    return PersistencePromise.resolve(result);\n  }\n\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void> {\n    const batchCount = batches.length;\n    assert(batchCount > 0, 'Should not remove mutations when none exist.');\n\n    const firstBatchId = batches[0].batchId;\n    const queueCount = this.mutationQueue.length;\n\n    // Find the position of the first batch for removal. This need not be the\n    // first entry in the queue.\n    const startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n    assert(\n      this.mutationQueue[startIndex].batchId === firstBatchId,\n      'Removed batches must exist in the queue'\n    );\n\n    // Check that removed batches are contiguous (while excluding tombstones).\n    let batchIndex = 1;\n    let queueIndex = startIndex + 1;\n    while (batchIndex < batchCount && queueIndex < queueCount) {\n      const batch = this.mutationQueue[queueIndex];\n      if (batch.isTombstone()) {\n        queueIndex++;\n        continue;\n      }\n\n      assert(\n        batch.batchId === batches[batchIndex].batchId,\n        'Removed batches must be contiguous in the queue'\n      );\n      batchIndex++;\n      queueIndex++;\n    }\n\n    // Only actually remove batches if removing at the front of the queue.\n    // Previously rejected batches may have left tombstones in the queue, so\n    // expand the removal range to include any tombstones.\n    if (startIndex === 0) {\n      for (; queueIndex < queueCount; queueIndex++) {\n        const batch = this.mutationQueue[queueIndex];\n        if (!batch.isTombstone()) {\n          break;\n        }\n      }\n      const length = queueIndex - startIndex;\n      this.mutationQueue.splice(startIndex, length);\n    } else {\n      // Mark the tombstones\n      for (let i = startIndex; i < queueIndex; i++) {\n        this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n      }\n    }\n\n    let references = this.batchesByDocumentKey;\n    for (const batch of batches) {\n      const batchId = batch.batchId;\n      for (const mutation of batch.mutations) {\n        const key = mutation.key;\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(key);\n        }\n\n        const ref = new DocReference(key, batchId);\n        references = references.delete(ref);\n      }\n    }\n    this.batchesByDocumentKey = references;\n    return PersistencePromise.resolve();\n  }\n\n  setGarbageCollector(garbageCollector: GarbageCollector | null): void {\n    this.garbageCollector = garbageCollector;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    if (this.mutationQueue.length === 0) {\n      assert(\n        this.batchesByDocumentKey.isEmpty(),\n        'Document leak -- detected dangling mutation references when queue is empty.'\n      );\n    }\n    return PersistencePromise.resolve();\n  }\n\n  /**\n   * A private helper that collects all the mutations batches in the queue up to\n   * but not including the given endIndex. All tombstones in the queue are\n   * excluded.\n   */\n  private getAllLiveMutationBatchesBeforeIndex(\n    endIndex: number\n  ): MutationBatch[] {\n    const result: MutationBatch[] = [];\n\n    for (let i = 0; i < endIndex; i++) {\n      const batch = this.mutationQueue[i];\n      if (!batch.isTombstone()) {\n        result.push(batch);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue and asserts that\n   * the resulting index is within the bounds of the queue.\n   *\n   * @param batchId The batchId to search for\n   * @param action A description of what the caller is doing, phrased in passive\n   * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n   */\n  private indexOfExistingBatchId(batchId: BatchId, action: string): number {\n    const index = this.indexOfBatchId(batchId);\n    assert(\n      index >= 0 && index < this.mutationQueue.length,\n      'Batches must exist to be ' + action\n    );\n    return index;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue. This operation\n   * is O(1).\n   *\n   * @return The computed index of the batch with the given batchId, based on\n   * the state of the queue. Note this index can be negative if the requested\n   * batchId has already been remvoed from the queue or past the end of the\n   * queue if the batchId is larger than the last added batch.\n   */\n  private indexOfBatchId(batchId: BatchId): number {\n    if (this.mutationQueue.length === 0) {\n      // As an index this is past the end of the queue\n      return 0;\n    }\n\n    // Examine the front of the queue to figure out the difference between the\n    // batchId and indexes in the array. Note that since the queue is ordered\n    // by batchId, if the first batch has a larger batchId then the requested\n    // batchId doesn't exist in the queue.\n    const firstBatchId = this.mutationQueue[0].batchId;\n    return batchId - firstBatchId;\n  }\n\n  /**\n   * A version of lookupMutationBatch that doesn't return a promise, this makes\n   * other functions that uses this code easier to read and more efficent.\n   */\n  private findMutationBatch(batchId: BatchId): MutationBatch | null {\n    const index = this.indexOfBatchId(batchId);\n    if (index < 0 || index >= this.mutationQueue.length) {\n      return null;\n    }\n\n    const batch = this.mutationQueue[index];\n    assert(batch.batchId === batchId, 'If found batch must match');\n    return batch.isTombstone() ? null : batch;\n  }\n}\n"]}