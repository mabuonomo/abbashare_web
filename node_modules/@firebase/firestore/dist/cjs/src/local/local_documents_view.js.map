{"version":3,"sources":["../src/local/local_documents_view.ts"],"names":[],"mappings":"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","file":"local_documents_view.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  DocumentMap,\n  documentMap,\n  MaybeDocumentMap,\n  maybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ResourcePath } from '../model/path';\nimport { fail } from '../util/assert';\n\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nexport class LocalDocumentsView {\n  constructor(\n    private remoteDocumentCache: RemoteDocumentCache,\n    private mutationQueue: MutationQueue\n  ) {}\n\n  /**\n   * Get the local view of the document identified by `key`.\n   *\n   * @return Local view of the document or null if we don't have any cached\n   * state for it.\n   */\n  getDocument(\n    transaction: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.remoteDocumentCache\n      .getEntry(transaction, key)\n      .next(remoteDoc => {\n        return this.computeLocalDocument(transaction, key, remoteDoc);\n      });\n  }\n\n  /**\n   * Gets the local view of the documents identified by `keys`.\n   *\n   * If we don't have cached state for a document in `keys`, a NoDocument will\n   * be stored for that key in the resulting set.\n   */\n  getDocuments(\n    transaction: PersistenceTransaction,\n    keys: DocumentKeySet\n  ): PersistencePromise<MaybeDocumentMap> {\n    const promises = [] as Array<PersistencePromise<void>>;\n    let results = maybeDocumentMap();\n    keys.forEach(key => {\n      promises.push(\n        this.getDocument(transaction, key).next(maybeDoc => {\n          // TODO(http://b/32275378): Don't conflate missing / deleted.\n          if (!maybeDoc) {\n            maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n          }\n          results = results.insert(key, maybeDoc);\n        })\n      );\n    });\n    return PersistencePromise.waitFor(promises).next(() => results);\n  }\n\n  /** Performs a query against the local view of all documents. */\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    if (DocumentKey.isDocumentKey(query.path)) {\n      return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n    } else {\n      return this.getDocumentsMatchingCollectionQuery(transaction, query);\n    }\n  }\n\n  private getDocumentsMatchingDocumentQuery(\n    transaction: PersistenceTransaction,\n    docPath: ResourcePath\n  ): PersistencePromise<DocumentMap> {\n    // Just do a simple document lookup.\n    return this.getDocument(\n      transaction,\n      new DocumentKey(docPath)\n    ).next(maybeDoc => {\n      let result = documentMap();\n      if (maybeDoc instanceof Document) {\n        result = result.insert(maybeDoc.key, maybeDoc);\n      }\n      return result;\n    });\n  }\n\n  private getDocumentsMatchingCollectionQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    // Query the remote documents and overlay mutations.\n    // TODO(mikelehen): There may be significant overlap between the mutations\n    // affecting these remote documents and the\n    // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n    let results: DocumentMap;\n    return this.remoteDocumentCache\n      .getDocumentsMatchingQuery(transaction, query)\n      .next(queryResults => {\n        return this.computeLocalDocuments(transaction, queryResults);\n      })\n      .next(promisedResults => {\n        results = promisedResults;\n        // Now use the mutation queue to discover any other documents that may\n        // match the query after applying mutations.\n        return this.mutationQueue.getAllMutationBatchesAffectingQuery(\n          transaction,\n          query\n        );\n      })\n      .next(matchingMutationBatches => {\n        let matchingKeys = documentKeySet();\n        for (const batch of matchingMutationBatches) {\n          for (const mutation of batch.mutations) {\n            // TODO(mikelehen): PERF: Check if this mutation actually\n            // affects the query to reduce work.\n            if (!results.get(mutation.key)) {\n              matchingKeys = matchingKeys.add(mutation.key);\n            }\n          }\n        }\n\n        // Now add in the results for the matchingKeys.\n        const promises = [] as Array<PersistencePromise<void>>;\n        matchingKeys.forEach(key => {\n          promises.push(\n            this.getDocument(transaction, key).next(doc => {\n              if (doc instanceof Document) {\n                results = results.insert(doc.key, doc);\n              }\n            })\n          );\n        });\n        return PersistencePromise.waitFor(promises);\n      })\n      .next(() => {\n        // Finally, filter out any documents that don't actually match\n        // the query.\n        results.forEach((key, doc) => {\n          if (!query.matches(doc)) {\n            results = results.remove(key);\n          }\n        });\n\n        return results;\n      });\n  }\n\n  /**\n   * Takes a remote document and applies local mutations to generate the local\n   * view of the document.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the document (necessary when remoteDocument\n   *     is null).\n   * @param document The base remote document to apply mutations to or null.\n   */\n  private computeLocalDocument(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey,\n    document: MaybeDocument | null\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.mutationQueue\n      .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n      .next(batches => {\n        for (const batch of batches) {\n          document = batch.applyToLocalView(documentKey, document);\n        }\n        return document;\n      });\n  }\n\n  /**\n   * Takes a set of remote documents and applies local mutations to generate the\n   * local view of the documents.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documents The base remote documents to apply mutations to.\n   * @return The local view of the documents.\n   */\n  private computeLocalDocuments(\n    transaction: PersistenceTransaction,\n    documents: DocumentMap\n  ): PersistencePromise<DocumentMap> {\n    const promises = [] as Array<PersistencePromise<void>>;\n    documents.forEach((key, doc) => {\n      promises.push(\n        this.computeLocalDocument(transaction, key, doc).next(mutatedDoc => {\n          if (mutatedDoc instanceof Document) {\n            documents = documents.insert(mutatedDoc.key, mutatedDoc);\n          } else if (mutatedDoc instanceof NoDocument) {\n            documents = documents.remove(mutatedDoc.key);\n          } else {\n            fail('Unknown MaybeDocument: ' + mutatedDoc);\n          }\n        })\n      );\n    });\n    return PersistencePromise.waitFor(promises).next(() => documents);\n  }\n}\n"]}