{"version":3,"sources":["../src/util/async_queue.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;AAEH,mCAAwC;AACxC,2BAA6B;AAG7B,qCAAqC;AAErC;IAAA;QACE,iCAAiC;QACzB,SAAI,GAA0B,OAAO,CAAC,OAAO,EAAE,CAAC;QAExD,6EAA6E;QAC7E,mCAAmC;QAC3B,mBAAc,GAAG,CAAC,CAAC;QAK3B,uEAAuE;QACvE,2BAA2B;QACnB,wBAAmB,GAAG,KAAK,CAAC;IAmEtC,CAAC;IAjEC;;;;;OAKG;IACH,6BAAQ,GAAR,UAAY,EAAoB,EAAE,KAAc;QAAhD,iBAoBC;QAnBC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YACjB,aAAI,CAAC,gCAAgC,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAChE,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACrB,IAAI,CAAC,cAAc,EAAE,CAAC;YACtB,IAAM,UAAQ,GAAG,IAAI,kBAAQ,EAAK,CAAC;YACnC,UAAU,CAAC;gBACT,KAAI,CAAC,gBAAgB,CAAC;oBACpB,MAAM,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,UAAA,MAAM;wBACrB,UAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;oBAC3B,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;gBACH,KAAI,CAAC,cAAc,EAAE,CAAC,CAAC,uCAAuC;YAChE,CAAC,EAAE,KAAK,CAAC,CAAC;YACV,MAAM,CAAC,UAAQ,CAAC,OAAO,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAEO,qCAAgB,GAAxB,UAA4B,EAAoB;QAAhD,iBAeC;QAdC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;YACzB,KAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,MAAM,CAAC,EAAE,EAAE;iBACR,KAAK,CAAC,UAAA,KAAK;gBACV,KAAI,CAAC,OAAO,GAAG,KAAK,CAAC;gBACrB,KAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;gBACjC,GAAG,CAAC,KAAK,CAAC,4BAA4B,EAAE,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;gBACtE,MAAM,KAAK,CAAC;YACd,CAAC,CAAC;iBACD,IAAI,CAAC;gBACJ,KAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;YACnC,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,IAAI,CAAC,IAA0B,CAAC;IACzC,CAAC;IAED;;;;;OAKG;IACH,8CAAyB,GAAzB;QACE,eAAM,CACJ,IAAI,CAAC,mBAAmB,EACxB,mEAAmE,CACpE,CAAC;IACJ,CAAC;IAED,0BAAK,GAAL;QACE,2EAA2E;QAC3E,4EAA4E;QAC5E,mDAAmD;QACnD,eAAM,CAAC,IAAI,CAAC,cAAc,KAAK,CAAC,EAAE,sCAAsC,CAAC,CAAC;QAC1E,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,EAA1B,CAA0B,CAAC,CAAC;IACzD,CAAC;IACH,iBAAC;AAAD,CAhFA,AAgFC,IAAA;AAhFY,gCAAU","file":"async_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { AnyDuringMigration, AnyJs } from './misc';\n\nimport { Deferred } from './promise';\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<AnyJs | void> = Promise.resolve();\n\n  // The number of ops that are queued to be run in the future (i.e. they had a\n  // delay that has not yet elapsed).\n  private delayedOpCount = 0;\n\n  // visible for testing\n  failure: Error;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   *\n   * Can optionally specify a delay to wait before queuing the operation.\n   */\n  schedule<T>(op: () => Promise<T>, delay?: number): Promise<T> {\n    if (this.failure) {\n      fail('AsyncQueue is already failed: ' + this.failure.message);\n    }\n\n    if ((delay || 0) > 0) {\n      this.delayedOpCount++;\n      const deferred = new Deferred<T>();\n      setTimeout(() => {\n        this.scheduleInternal(() => {\n          return op().then(result => {\n            deferred.resolve(result);\n          });\n        });\n        this.delayedOpCount--; // decrement once it's actually queued.\n      }, delay);\n      return deferred.promise;\n    } else {\n      return this.scheduleInternal(op);\n    }\n  }\n\n  private scheduleInternal<T>(op: () => Promise<T>): Promise<T> {\n    this.tail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch(error => {\n          this.failure = error;\n          this.operationInProgress = false;\n          log.error('INTERNAL UNHANDLED ERROR: ', error.stack || error.message);\n          throw error;\n        })\n        .then(() => {\n          this.operationInProgress = false;\n        });\n    });\n    return this.tail as AnyDuringMigration;\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    assert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  drain(): Promise<void> {\n    // TODO(mikelehen): This should perhaps also drain items that are queued to\n    // run in the future (perhaps by artificially running them early), but since\n    // no tests need that yet, I didn't bother for now.\n    assert(this.delayedOpCount === 0, \"draining doesn't handle delayed ops.\");\n    return this.schedule(() => Promise.resolve(undefined));\n  }\n}\n"]}