{"version":3,"sources":["../src/remote/remote_store.ts"],"names":[],"mappings":"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","file":"remote_store.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { DatabaseInfo } from '../core/database_info';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { BatchId, OnlineState, TargetId } from '../core/types';\nimport { LocalStore } from '../local/local_store';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationResult } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\n\nimport { Datastore } from './datastore';\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream\n} from './persistent_stream';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { RemoteSyncer } from './remote_syncer';\nimport { isPermanentError } from './rpc_error';\nimport {\n  WatchChange,\n  WatchChangeAggregator,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\n\nconst LOG_TAG = 'RemoteStore';\n\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\n\n// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\nconst ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nexport class RemoteStore {\n  private pendingWrites: MutationBatch[] = [];\n  private lastBatchSeen: BatchId = BATCHID_UNKNOWN;\n\n  /**\n   * A mapping of watched targets that the client cares about tracking and the\n   * user has explicitly called a 'listen' for this target.\n   *\n   * These targets may or may not have been sent to or acknowledged by the\n   * server. On re-establishing the listen stream, these targets should be sent\n   * to the server. The targets removed with unlistens are removed eagerly\n   * without waiting for confirmation from the listen stream.\n   */\n  private listenTargets: { [targetId: number]: QueryData } = {};\n\n  /**\n   * A mapping of targetId to pending acks needed.\n   *\n   * If a targetId is present in this map, then we're waiting for watch to\n   * acknowledge a removal or addition of the target. If a target is not in this\n   * mapping, and it's in the listenTargets map, then we consider the target to\n   * be active.\n   *\n   * We increment the count here every time we issue a request over the stream\n   * to watch or unwatch. We then decrement the count every time we get a target\n   * added or target removed message from the server. Once the count is equal to\n   * 0 we know that the client and server are in the same state (once this state\n   * is reached the targetId is removed from the map to free the memory).\n   */\n  private pendingTargetResponses: { [targetId: number]: number } = {};\n\n  private accumulatedWatchChanges: WatchChange[] = [];\n\n  private watchStream: PersistentListenStream = null;\n  private writeStream: PersistentWriteStream = null;\n\n  /**\n   * The online state of the watch stream. The state is set to healthy if and\n   * only if there are messages received by the backend.\n   */\n  private watchStreamOnlineState = OnlineState.Unknown;\n\n  /** A count of consecutive failures to open the stream. */\n  private watchStreamFailures = 0;\n\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    private asyncQueue: AsyncQueue,\n    /**\n     * The local store, used to fill the write pipeline with outbound\n     * mutations and resolve existence filter mismatches.\n     */\n    private localStore: LocalStore,\n    /** The client-side proxy for interacting with the backend. */\n    private datastore: Datastore,\n    private onlineStateHandler: (onlineState: OnlineState) => void\n  ) {}\n\n  /** SyncEngine to notify of watch and write events. */\n  public syncEngine: RemoteSyncer;\n\n  /**\n   * Starts up the remote store, creating streams, restoring state from\n   * LocalStore, etc.\n   */\n  start(): Promise<void> {\n    return this.enableNetwork();\n  }\n\n  private setOnlineStateToHealthy(): void {\n    this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n  }\n\n  private setOnlineStateToUnknown(): void {\n    // The state is set to unknown when a healthy stream is closed (e.g. due to\n    // a token timeout) or when we have no active listens and therefore there's\n    // no need to start the stream. Assuming there is (possibly in the future)\n    // an active listen, then we will eventually move to state Online or Failed,\n    // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n    // attempts before failing, so we reset the count here.\n    this.watchStreamFailures = 0;\n    this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n  }\n\n  private updateOnlineStateAfterFailure(): void {\n    // The first failure after we are successfully connected moves us to the\n    // 'Unknown' state. We then may make multiple attempts (based on\n    // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n    if (this.watchStreamOnlineState === OnlineState.Healthy) {\n      this.setOnlineStateToUnknown();\n    } else {\n      this.watchStreamFailures++;\n      if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n        this.updateAndBroadcastOnlineState(OnlineState.Failed);\n      }\n    }\n  }\n\n  private updateAndBroadcastOnlineState(onlineState: OnlineState): void {\n    const didChange = this.watchStreamOnlineState !== onlineState;\n    this.watchStreamOnlineState = onlineState;\n    if (didChange) {\n      this.onlineStateHandler(onlineState);\n    }\n  }\n\n  private isNetworkEnabled(): boolean {\n    assert(\n      (this.watchStream == null) == (this.writeStream == null),\n      'WatchStream and WriteStream should both be null or non-null'\n    );\n    return this.watchStream != null;\n  }\n\n  /** Re-enables the network. Only to be called as the counterpart to disableNetwork(). */\n  enableNetwork(): Promise<void> {\n    assert(\n      this.watchStream == null,\n      'enableNetwork() called with non-null watchStream.'\n    );\n    assert(\n      this.writeStream == null,\n      'enableNetwork() called with non-null writeStream.'\n    );\n\n    // Create new streams (but note they're not started yet).\n    this.watchStream = this.datastore.newPersistentWatchStream({\n      onOpen: this.onWatchStreamOpen.bind(this),\n      onClose: this.onWatchStreamClose.bind(this),\n      onWatchChange: this.onWatchStreamChange.bind(this)\n    });\n    this.writeStream = this.datastore.newPersistentWriteStream({\n      onOpen: this.onWriteStreamOpen.bind(this),\n      onClose: this.onWriteStreamClose.bind(this),\n      onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n      onMutationResult: this.onMutationResult.bind(this)\n    });\n\n    // Load any saved stream token from persistent storage\n    return this.localStore.getLastStreamToken().then(token => {\n      this.writeStream.lastStreamToken = token;\n\n      if (this.shouldStartWatchStream()) {\n        this.startWatchStream();\n      }\n\n      this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n\n      return this.fillWritePipeline(); // This may start the writeStream.\n    });\n  }\n\n  /** Temporarily disables the network. The network can be re-enabled using enableNetwork(). */\n  disableNetwork(): Promise<void> {\n    this.updateAndBroadcastOnlineState(OnlineState.Failed);\n\n    // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n    // event).\n    this.watchStream.stop();\n    this.writeStream.stop();\n\n    this.cleanUpWatchStreamState();\n    this.cleanUpWriteStreamState();\n\n    this.writeStream = null;\n    this.watchStream = null;\n\n    return Promise.resolve();\n  }\n\n  shutdown(): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore shutting down.');\n    this.disableNetwork();\n    return Promise.resolve(undefined);\n  }\n\n  /** Starts new listen for the given query. Uses resume token if provided */\n  listen(queryData: QueryData): void {\n    assert(\n      !objUtils.contains(this.listenTargets, queryData.targetId),\n      'listen called with duplicate targetId!'\n    );\n    // Mark this as something the client is currently listening for.\n    this.listenTargets[queryData.targetId] = queryData;\n\n    if (this.shouldStartWatchStream()) {\n      // The listen will be sent in onWatchStreamOpen\n      this.startWatchStream();\n    } else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendWatchRequest(queryData);\n    }\n  }\n\n  /** Removes the listen from server */\n  unlisten(targetId: TargetId): void {\n    assert(\n      objUtils.contains(this.listenTargets, targetId),\n      'unlisten called without assigned target ID!'\n    );\n    const queryData = this.listenTargets[targetId];\n    delete this.listenTargets[targetId];\n    if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendUnwatchRequest(targetId);\n    }\n  }\n\n  /**\n   * We need to increment the the expected number of pending responses we're due\n   * from watch so we wait for the ack to process any messages from this target.\n   */\n  private sendWatchRequest(queryData: QueryData): void {\n    this.recordPendingTargetRequest(queryData.targetId);\n    this.watchStream.watch(queryData);\n  }\n\n  /**\n   * We need to increment the expected number of pending responses we're due\n   * from watch so we wait for the removal on the server before we process any\n   * messages from this target.\n   */\n  private sendUnwatchRequest(targetId: TargetId): void {\n    this.recordPendingTargetRequest(targetId);\n    this.watchStream.unwatch(targetId);\n  }\n\n  /**\n   * Increment the mapping of how many acks are needed from watch before we can\n   * consider the server to be 'in-sync' with the client's active targets.\n   */\n  private recordPendingTargetRequest(targetId: TargetId): void {\n    // For each request we get we need to record we need a response for it.\n    this.pendingTargetResponses[targetId] =\n      (this.pendingTargetResponses[targetId] || 0) + 1;\n  }\n\n  private startWatchStream(): void {\n    assert(\n      this.shouldStartWatchStream(),\n      'startWriteStream() called when shouldStartWatchStream() is false.'\n    );\n    this.watchStream.start();\n  }\n\n  /**\n   * Returns whether the watch stream should be started because there are\n   * active targets trying to be listened too\n   */\n  private shouldStartWatchStream(): boolean {\n    return (\n      this.isNetworkEnabled() &&\n      !this.watchStream.isStarted() &&\n      !objUtils.isEmpty(this.listenTargets)\n    );\n  }\n\n  private cleanUpWatchStreamState(): void {\n    // If the connection is closed then we'll never get a snapshot version for\n    // the accumulated changes and so we'll never be able to complete the batch.\n    // When we start up again the server is going to resend these changes\n    // anyway, so just toss the accumulated state.\n    this.accumulatedWatchChanges = [];\n    this.pendingTargetResponses = {};\n  }\n\n  private onWatchStreamOpen(): Promise<void> {\n    // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n    // targets are active\n    objUtils.forEachNumber(this.listenTargets, (targetId, queryData) => {\n      this.sendWatchRequest(queryData);\n    });\n    return Promise.resolve();\n  }\n\n  private onWatchStreamClose(error: FirestoreError | null): Promise<void> {\n    assert(\n      this.isNetworkEnabled(),\n      'onWatchStreamClose() should only be called when the network is enabled'\n    );\n\n    this.cleanUpWatchStreamState();\n\n    // If there was an error, retry the connection.\n    if (this.shouldStartWatchStream()) {\n      this.updateOnlineStateAfterFailure();\n      this.startWatchStream();\n    } else {\n      // No need to restart watch stream because there are no active targets.\n      // The online state is set to unknown because there is no active attempt\n      // at establishing a connection\n      this.setOnlineStateToUnknown();\n    }\n    return Promise.resolve();\n  }\n\n  private onWatchStreamChange(\n    watchChange: WatchChange,\n    snapshotVersion: SnapshotVersion\n  ): Promise<void> {\n    // Mark the connection as healthy because we got a message from the server\n    this.setOnlineStateToHealthy();\n\n    if (\n      watchChange instanceof WatchTargetChange &&\n      watchChange.state === WatchTargetChangeState.Removed &&\n      watchChange.cause\n    ) {\n      // There was an error on a target, don't wait for a consistent snapshot\n      // to raise events\n      return this.handleTargetError(watchChange);\n    }\n    // Accumulate watch changes but don't process them if there's no\n    // snapshotVersion or it's older than a previous snapshot we've processed\n    // (can happen after we resume a target using a resume token).\n    this.accumulatedWatchChanges.push(watchChange);\n    if (\n      !snapshotVersion.equals(SnapshotVersion.MIN) &&\n      snapshotVersion.compareTo(\n        this.localStore.getLastRemoteSnapshotVersion()\n      ) >= 0\n    ) {\n      const changes = this.accumulatedWatchChanges;\n      this.accumulatedWatchChanges = [];\n      return this.handleWatchChangeBatch(snapshotVersion, changes);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Takes a batch of changes from the Datastore, repackages them as a\n   * RemoteEvent, and passes that on to the listener, which is typically the\n   * SyncEngine.\n   */\n  private handleWatchChangeBatch(\n    snapshotVersion: SnapshotVersion,\n    changes: WatchChange[]\n  ): Promise<void> {\n    const aggregator = new WatchChangeAggregator(\n      snapshotVersion,\n      this.listenTargets,\n      this.pendingTargetResponses\n    );\n    aggregator.addChanges(changes);\n    const remoteEvent = aggregator.createRemoteEvent();\n    // Get the new response counts from the aggregator\n    this.pendingTargetResponses = aggregator.pendingTargetResponses;\n\n    const promises: Array<Promise<void>> = [];\n    // Handle existence filters and existence filter mismatches.\n    objUtils.forEachNumber(\n      aggregator.existenceFilters,\n      (targetId: TargetId, filter: ExistenceFilter) => {\n        const queryData = this.listenTargets[targetId];\n        if (!queryData) {\n          // A watched target might have been removed already.\n          return;\n        }\n        const query = queryData.query;\n        if (query.isDocumentQuery()) {\n          if (filter.count === 0) {\n            // The existence filter told us the document does not exist.\n            // We need to deduce that this document does not exist and apply\n            // a deleted document to our updates. Without applying a deleted\n            // document there might be another query that will raise this\n            // document as part of a snapshot until it is resolved,\n            // essentially exposing inconsistency between queries.\n            const key = new DocumentKey(query.path);\n            const deletedDoc = new NoDocument(key, snapshotVersion);\n            remoteEvent.addDocumentUpdate(deletedDoc);\n          } else {\n            assert(\n              filter.count === 1,\n              'Single document existence filter with count: ' + filter.count\n            );\n          }\n        } else {\n          // Not a document query.\n          const promise = this.localStore\n            .remoteDocumentKeys(targetId)\n            .then(trackedRemote => {\n              if (remoteEvent.targetChanges[targetId]) {\n                const mapping = remoteEvent.targetChanges[targetId].mapping;\n                if (mapping !== null) {\n                  if (mapping instanceof UpdateMapping) {\n                    trackedRemote = mapping.applyToKeySet(trackedRemote);\n                  } else {\n                    assert(\n                      mapping instanceof ResetMapping,\n                      'Expected either reset or update mapping but got something else: ' +\n                        mapping\n                    );\n                    trackedRemote = mapping.documents;\n                  }\n                }\n              }\n\n              if (trackedRemote.size !== filter.count) {\n                // Existence filter mismatch, resetting mapping.\n\n                // Make sure the mismatch is exposed in the remote event.\n                remoteEvent.handleExistenceFilterMismatch(targetId);\n\n                // Clear the resume token for the query, since we're in a\n                // known mismatch state.\n                const newQueryData = new QueryData(\n                  query,\n                  targetId,\n                  queryData.purpose\n                );\n                this.listenTargets[targetId] = newQueryData;\n\n                // Cause a hard reset by unwatching and rewatching\n                // immediately, but deliberately don't send a resume token\n                // so that we get a full update.\n                // Make sure we expect that this acks are going to happen.\n                this.sendUnwatchRequest(targetId);\n\n                // Mark the query we send as being on behalf of an existence\n                // filter mismatch, but don't actually retain that in\n                // listenTargets. This ensures that we flag the first\n                // re-listen this way without impacting future listens of\n                // this target (that might happen e.g. on reconnect).\n                const requestQueryData = new QueryData(\n                  query,\n                  targetId,\n                  QueryPurpose.ExistenceFilterMismatch\n                );\n                this.sendWatchRequest(requestQueryData);\n              }\n            });\n          promises.push(promise);\n        }\n      }\n    );\n\n    return Promise.all(promises).then(() => {\n      // Update in-memory resume tokens. LocalStore will update the\n      // persistent view of these when applying the completed RemoteEvent.\n      objUtils.forEachNumber(remoteEvent.targetChanges, (targetId, change) => {\n        if (change.resumeToken.length > 0) {\n          const queryData = this.listenTargets[targetId];\n          // A watched target might have been removed already.\n          if (queryData) {\n            this.listenTargets[targetId] = queryData.update({\n              resumeToken: change.resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n          }\n        }\n      });\n\n      // Finally handle remote event\n      return this.syncEngine.applyRemoteEvent(remoteEvent);\n    });\n  }\n\n  /** Handles an error on a target */\n  private handleTargetError(watchChange: WatchTargetChange): Promise<void> {\n    assert(!!watchChange.cause, 'Handling target error without a cause');\n    const error = watchChange.cause!;\n    let promiseChain = Promise.resolve();\n    watchChange.targetIds.forEach(targetId => {\n      promiseChain = promiseChain.then(() => {\n        if (objUtils.contains(this.listenTargets, targetId)) {\n          delete this.listenTargets[targetId];\n          return this.syncEngine.rejectListen(targetId, error);\n        } else {\n          // A watched target might have been removed already.\n          return Promise.resolve();\n        }\n      });\n    });\n    return promiseChain;\n  }\n\n  cleanUpWriteStreamState() {\n    this.lastBatchSeen = BATCHID_UNKNOWN;\n    this.pendingWrites = [];\n  }\n\n  /**\n   * Notifies that there are new mutations to process in the queue. This is\n   * typically called by SyncEngine after it has sent mutations to LocalStore.\n   *\n   */\n  fillWritePipeline(): Promise<void> {\n    if (!this.canWriteMutations()) {\n      return Promise.resolve();\n    } else {\n      return this.localStore\n        .nextMutationBatch(this.lastBatchSeen)\n        .then(batch => {\n          if (batch === null) {\n            return Promise.resolve();\n          } else {\n            this.commit(batch);\n            return this.fillWritePipeline();\n          }\n        });\n    }\n  }\n\n  /**\n   * Returns true if the backend can accept additional write requests.\n   *\n   * When sending mutations to the write stream (e.g. in fillWritePipeline),\n   * call this method first to check if more mutations can be sent.\n   *\n   * Currently the only thing that can prevent the backend from accepting\n   * write requests is if there are too many requests already outstanding. As\n   * writes complete the backend will be able to accept more.\n   */\n  canWriteMutations(): boolean {\n    return (\n      this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES\n    );\n  }\n\n  // For testing\n  outstandingWrites(): number {\n    return this.pendingWrites.length;\n  }\n\n  /**\n   * Given mutations to commit, actually commits them to the Datastore. Note\n   * that this does *not* return a Promise specifically because the AsyncQueue\n   * should not block operations for this.\n   */\n  private commit(batch: MutationBatch): void {\n    assert(\n      this.canWriteMutations(),\n      \"commit called when batches can't be written\"\n    );\n    this.lastBatchSeen = batch.batchId;\n\n    this.pendingWrites.push(batch);\n\n    if (this.shouldStartWriteStream()) {\n      this.startWriteStream();\n    } else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  }\n\n  private shouldStartWriteStream(): boolean {\n    return (\n      this.isNetworkEnabled() &&\n      !this.writeStream.isStarted() &&\n      this.pendingWrites.length > 0\n    );\n  }\n\n  private startWriteStream(): void {\n    assert(\n      this.shouldStartWriteStream(),\n      'startWriteStream() called when shouldStartWriteStream() is false.'\n    );\n    this.writeStream.start();\n  }\n\n  private onWriteStreamOpen(): Promise<void> {\n    this.writeStream.writeHandshake();\n\n    return Promise.resolve();\n  }\n\n  private onWriteHandshakeComplete(): Promise<void> {\n    // Record the stream token.\n    return this.localStore\n      .setLastStreamToken(this.writeStream.lastStreamToken)\n      .then(() => {\n        // Drain any pending writes.\n        //\n        // Note that at this point pendingWrites contains mutations that\n        // have already been accepted by fillWritePipeline/commitBatch. If\n        // the pipeline is full, canWriteMutations will be false, despite\n        // the fact that we actually need to send mutations over.\n        //\n        // This also means that this method indirectly respects the limits\n        // imposed by canWriteMutations since writes can't be added to the\n        // pendingWrites array when canWriteMutations is false. If the\n        // limits imposed by canWriteMutations actually protect us from\n        // DOSing ourselves then those limits won't be exceeded here and\n        // we'll continue to make progress.\n        for (const batch of this.pendingWrites) {\n          this.writeStream.writeMutations(batch.mutations);\n        }\n      });\n  }\n\n  private onMutationResult(\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ): Promise<void> {\n    // This is a response to a write containing mutations and should be\n    // correlated to the first pending write.\n    assert(\n      this.pendingWrites.length > 0,\n      'Got result for empty pending writes'\n    );\n    const batch = this.pendingWrites.shift()!;\n    const success = MutationBatchResult.from(\n      batch,\n      commitVersion,\n      results,\n      this.writeStream.lastStreamToken\n    );\n    return this.syncEngine.applySuccessfulWrite(success).then(() => {\n      // It's possible that with the completion of this mutation another\n      // slot has freed up.\n      return this.fillWritePipeline();\n    });\n  }\n\n  private onWriteStreamClose(error?: FirestoreError): Promise<void> {\n    assert(\n      this.isNetworkEnabled(),\n      'onWriteStreamClose() should only be called when the network is enabled'\n    );\n\n    // Ignore close if there are no pending writes.\n    if (this.pendingWrites.length > 0) {\n      assert(\n        !!error,\n        'We have pending writes, but the write stream closed without an error'\n      );\n      // A promise that is resolved after we processed the error\n      let errorHandling: Promise<void>;\n      if (this.writeStream.handshakeComplete) {\n        // This error affects the actual write.\n        errorHandling = this.handleWriteError(error!);\n      } else {\n        // If there was an error before the handshake has finished, it's\n        // possible that the server is unable to process the stream token\n        // we're sending. (Perhaps it's too old?)\n        errorHandling = this.handleHandshakeError(error!);\n      }\n\n      return errorHandling.then(() => {\n        // The write stream might have been started by refilling the write\n        // pipeline for failed writes\n        if (this.shouldStartWriteStream()) {\n          this.startWriteStream();\n        }\n      });\n    } else {\n      // No pending writes, nothing to do\n      return Promise.resolve();\n    }\n  }\n\n  private handleHandshakeError(error: FirestoreError): Promise<void> {\n    // Reset the token if it's a permanent error or the error code is\n    // ABORTED, signaling the write stream is no longer valid.\n    if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n      log.debug(\n        LOG_TAG,\n        'RemoteStore error before completed handshake; resetting stream token: ',\n        this.writeStream.lastStreamToken\n      );\n      this.writeStream.lastStreamToken = emptyByteString();\n\n      return this.localStore.setLastStreamToken(emptyByteString());\n    } else {\n      // Some other error, don't reset stream token. Our stream logic will\n      // just retry with exponential backoff.\n      return Promise.resolve();\n    }\n  }\n\n  private handleWriteError(error: FirestoreError): Promise<void> {\n    if (isPermanentError(error.code)) {\n      // This was a permanent error, the request itself was the problem\n      // so it's not going to succeed if we resend it.\n      const batch = this.pendingWrites.shift()!;\n\n      // In this case it's also unlikely that the server itself is melting\n      // down -- this was just a bad request so inhibit backoff on the next\n      // restart.\n      this.writeStream.inhibitBackoff();\n\n      return this.syncEngine\n        .rejectFailedWrite(batch.batchId, error)\n        .then(() => {\n          // It's possible that with the completion of this mutation\n          // another slot has freed up.\n          return this.fillWritePipeline();\n        });\n    } else {\n      // Transient error, just let the retry logic kick in.\n      return Promise.resolve();\n    }\n  }\n\n  createTransaction(): Transaction {\n    return new Transaction(this.datastore);\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n\n    // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n    // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n    // (since mutations are per-user).\n    this.disableNetwork();\n    return this.enableNetwork();\n  }\n}\n"]}