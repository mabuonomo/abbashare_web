{"version":3,"sources":["../src/core/transaction.ts"],"names":[],"mappings":"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","file":"transaction.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParsedSetData, ParsedUpdateData } from '../api/user_data_converter';\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { Datastore } from '../remote/datastore';\nimport { Code, FirestoreError } from '../util/error';\n\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nexport class Transaction {\n  // The version of each document that was read during this transaction.\n  private readVersions = documentVersionMap();\n  private mutations: Mutation[] = [];\n  private committed = false;\n\n  constructor(private datastore: Datastore) {}\n\n  private recordVersion(doc: MaybeDocument) {\n    let docVersion = doc.version;\n    if (doc instanceof NoDocument) {\n      // For deleted docs, we must use baseVersion 0 when we overwrite them.\n      docVersion = SnapshotVersion.forDeletedDoc();\n    }\n    const existingVersion = this.readVersions.get(doc.key);\n    if (existingVersion !== null) {\n      if (!docVersion.equals(existingVersion)) {\n        // This transaction will fail no matter what.\n        throw new FirestoreError(\n          Code.ABORTED,\n          'Document version changed between two reads.'\n        );\n      }\n    } else {\n      this.readVersions = this.readVersions.insert(doc.key, docVersion);\n    }\n  }\n\n  lookup(keys: DocumentKey[]): Promise<MaybeDocument[]> {\n    if (this.committed) {\n      return Promise.reject<MaybeDocument[]>(\n        'Transaction has already completed.'\n      );\n    }\n    if (this.mutations.length > 0) {\n      return Promise.reject<MaybeDocument[]>(\n        'Transactions lookups are invalid after writes.'\n      );\n    }\n    return this.datastore.lookup(keys).then(docs => {\n      docs.forEach(doc => this.recordVersion(doc));\n      return docs;\n    });\n  }\n\n  private write(mutations: Mutation[]) {\n    if (this.committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Transaction has already completed.'\n      );\n    }\n    this.mutations = this.mutations.concat(mutations);\n  }\n\n  /**\n   * Returns the version of this document when it was read in this transaction,\n   * as a precondition, or no precondition if it was not read.\n   */\n  private precondition(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key);\n    if (version) {\n      return Precondition.updateTime(version);\n    } else {\n      return Precondition.NONE;\n    }\n  }\n\n  /**\n   * Returns the precondition for a document if the operation is an update.\n   */\n  private preconditionForUpdate(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key);\n    if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n      // The document doesn't exist, so fail the transaction.\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        \"Can't update a document that doesn't exist.\"\n      );\n    } else if (version) {\n      // Document exists, base precondition on document update time.\n      return Precondition.updateTime(version);\n    } else {\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Precondition.exists(true);\n    }\n  }\n\n  set(key: DocumentKey, data: ParsedSetData) {\n    this.write(data.toMutations(key, this.precondition(key)));\n  }\n\n  update(key: DocumentKey, data: ParsedUpdateData) {\n    this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n  }\n\n  delete(key: DocumentKey) {\n    this.write([new DeleteMutation(key, this.precondition(key))]);\n    // Since the delete will be applied before all following writes, we need to\n    // ensure that the precondition for the next write will be exists: false.\n    this.readVersions = this.readVersions.insert(\n      key,\n      SnapshotVersion.forDeletedDoc()\n    );\n  }\n\n  commit(): Promise<void> {\n    let unwritten = this.readVersions;\n    // For each mutation, note that the doc was written.\n    this.mutations.forEach(mutation => {\n      unwritten = unwritten.remove(mutation.key);\n    });\n    if (!unwritten.isEmpty()) {\n      return Promise.reject(\n        Error('Every document read in a transaction must also be written.')\n      );\n    }\n    return this.datastore.commit(this.mutations).then(() => {\n      this.committed = true;\n    });\n  }\n}\n"]}