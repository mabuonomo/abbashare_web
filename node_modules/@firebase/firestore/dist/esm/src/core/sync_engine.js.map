{"version":3,"sources":["../src/core/sync_engine.ts"],"names":[],"mappings":"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","file":"sync_engine.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalStore } from '../local/local_store';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { MaybeDocumentMap } from '../model/collections';\nimport { MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { MutationBatchResult } from '../model/mutation_batch';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { RemoteStore } from '../remote/remote_store';\nimport { RemoteSyncer } from '../remote/remote_syncer';\nimport { assert, fail } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AnyJs, primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { Deferred } from '../util/promise';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\n\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { Transaction } from './transaction';\nimport { BatchId, ProtoByteString, TargetId } from './types';\nimport {\n  AddedLimboDocument,\n  LimboDocumentChange,\n  RemovedLimboDocument,\n  View,\n  ViewDocumentChanges\n} from './view';\nimport { ViewSnapshot } from './view_snapshot';\n\nconst LOG_TAG = 'SyncEngine';\n\nexport type ViewHandler = (viewSnaps: ViewSnapshot[]) => void;\nexport type ErrorHandler = (query: Query, error: Error) => void;\n\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n  constructor(\n    /**\n     * The query itself.\n     */\n    public query: Query,\n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    public targetId: TargetId,\n    /**\n     * An identifier from the datastore backend that indicates the last state\n     * of the results that was received. This can be used to indicate where\n     * to continue receiving new doc changes for the query.\n     */\n    public resumeToken: ProtoByteString,\n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    public view: View\n  ) {}\n}\n\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\nexport class SyncEngine implements RemoteSyncer {\n  private viewHandler: ViewHandler | null = null;\n  private errorHandler: ErrorHandler | null = null;\n\n  private queryViewsByQuery = new ObjectMap<Query, QueryView>(q =>\n    q.canonicalId()\n  );\n  private queryViewsByTarget: { [targetId: number]: QueryView } = {};\n  private limboTargetsByKey = new SortedMap<DocumentKey, TargetId>(\n    DocumentKey.comparator\n  );\n  private limboKeysByTarget: { [targetId: number]: DocumentKey } = {};\n  private limboDocumentRefs = new ReferenceSet();\n  private limboCollector = new EagerGarbageCollector();\n  /** Stores user completion handlers, indexed by User and BatchId. */\n  private mutationUserCallbacks = {} as {\n    [uidKey: string]: SortedMap<BatchId, Deferred<void>>;\n  };\n  private targetIdGenerator = TargetIdGenerator.forSyncEngine();\n\n  constructor(\n    private localStore: LocalStore,\n    private remoteStore: RemoteStore,\n    private currentUser: User\n  ) {}\n\n  /** Subscribes view and error handler. Can be called only once. */\n  subscribe(viewHandler: ViewHandler, errorHandler: ErrorHandler): void {\n    assert(\n      viewHandler !== null && errorHandler !== null,\n      'View and error handlers cannot be null'\n    );\n    assert(\n      this.viewHandler === null && this.errorHandler === null,\n      'SyncEngine already has a subscriber.'\n    );\n    this.viewHandler = viewHandler;\n    this.errorHandler = errorHandler;\n    this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n  }\n\n  /**\n   * Initiates the new listen, resolves promise when listen enqueued to the\n   * server. All the subsequent view snapshots or errors are sent to the\n   * subscribed handlers. Returns the targetId of the query.\n   */\n  listen(query: Query): Promise<TargetId> {\n    this.assertSubscribed('listen()');\n    assert(\n      !this.queryViewsByQuery.has(query),\n      'We already listen to the query: ' + query\n    );\n\n    return this.localStore.allocateQuery(query).then(queryData => {\n      return this.localStore\n        .executeQuery(query)\n        .then(docs => {\n          return this.localStore\n            .remoteDocumentKeys(queryData.targetId)\n            .then(remoteKeys => {\n              const view = new View(query, remoteKeys);\n              const viewDocChanges = view.computeDocChanges(docs);\n              const viewChange = view.applyChanges(viewDocChanges);\n              assert(\n                viewChange.limboChanges.length === 0,\n                'View returned limbo docs before target ack from the server.'\n              );\n              assert(\n                !!viewChange.snapshot,\n                'applyChanges for new view should always return a snapshot'\n              );\n\n              const data = new QueryView(\n                query,\n                queryData.targetId,\n                queryData.resumeToken,\n                view\n              );\n              this.queryViewsByQuery.set(query, data);\n              this.queryViewsByTarget[queryData.targetId] = data;\n              this.viewHandler!([viewChange.snapshot!]);\n              this.remoteStore.listen(queryData);\n            });\n        })\n        .then(() => {\n          return queryData.targetId;\n        });\n    });\n  }\n\n  /** Stops listening to the query. */\n  unlisten(query: Query): Promise<void> {\n    this.assertSubscribed('unlisten()');\n\n    const queryView = this.queryViewsByQuery.get(query)!;\n    assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n\n    return this.localStore.releaseQuery(query).then(() => {\n      this.remoteStore.unlisten(queryView.targetId);\n      return this.removeAndCleanupQuery(queryView).then(() => {\n        return this.localStore.collectGarbage();\n      });\n    });\n  }\n\n  /**\n   * Initiates the write of local mutation batch which involves adding the\n   * writes to the mutation queue, notifying the remote store about new\n   * mutations and raising events for any changes this write caused.\n   *\n   * The promise returned by this call is resolved when the above steps\n   * have completed, *not* when the write was acked by the backend. The\n   * userCallback is resolved once the write was acked/rejected by the\n   * backend (or failed locally for any other reason).\n   */\n  write(batch: Mutation[], userCallback: Deferred<void>): Promise<void> {\n    this.assertSubscribed('write()');\n    return this.localStore\n      .localWrite(batch)\n      .then(result => {\n        this.addMutationCallback(result.batchId, userCallback);\n        return this.emitNewSnapsAndNotifyLocalStore(result.changes);\n      })\n      .then(() => {\n        return this.remoteStore.fillWritePipeline();\n      });\n  }\n\n  // TODO(klimt): Wrap the given error in a standard Firestore error object.\n  private wrapUpdateFunctionError(error: AnyJs): AnyJs {\n    return error;\n  }\n\n  /**\n   * Takes an updateFunction in which a set of reads and writes can be performed\n   * atomically. In the updateFunction, the client can read and write values\n   * using the supplied transaction object. After the updateFunction, all\n   * changes will be committed. If some other client has changed any of the data\n   * referenced, then the updateFunction will be called again. If the\n   * updateFunction still fails after the given number of retries, then the\n   * transaction will be rejection.\n   *\n   * The transaction object passed to the updateFunction contains methods for\n   * accessing documents and collections. Unlike other datastore access, data\n   * accessed with the transaction will not reflect local changes that have not\n   * been committed. For this reason, it is required that all reads are\n   * performed before any writes. Transactions must be performed while online.\n   *\n   * The promise returned is resolved when the transaction is fully committed.\n   */\n  runTransaction<T>(\n    updateFunction: (transaction: Transaction) => Promise<T>,\n    retries = 5\n  ): Promise<T> {\n    assert(retries >= 0, 'Got negative number of retries for transaction.');\n    const transaction = this.remoteStore.createTransaction();\n    const wrappedUpdateFunction = () => {\n      try {\n        const userPromise = updateFunction(transaction);\n        if (\n          isNullOrUndefined(userPromise) ||\n          !userPromise.catch ||\n          !userPromise.then\n        ) {\n          return Promise.reject<T>(\n            Error('Transaction callback must return a Promise')\n          );\n        }\n        return userPromise.catch(e => {\n          return Promise.reject<T>(this.wrapUpdateFunctionError(e));\n        });\n      } catch (e) {\n        return Promise.reject<T>(this.wrapUpdateFunctionError(e));\n      }\n    };\n    return wrappedUpdateFunction().then(result => {\n      return transaction\n        .commit()\n        .then(() => {\n          return result;\n        })\n        .catch(error => {\n          if (retries === 0) {\n            return Promise.reject<T>(error);\n          }\n          // TODO(klimt): Put in a retry delay?\n          return this.runTransaction(updateFunction, retries - 1);\n        });\n    });\n  }\n\n  applyRemoteEvent(remoteEvent: RemoteEvent): Promise<void> {\n    this.assertSubscribed('applyRemoteEvent()');\n\n    // Make sure limbo documents are deleted if there were no results\n    objUtils.forEachNumber(\n      remoteEvent.targetChanges,\n      (targetId, targetChange) => {\n        const limboKey = this.limboKeysByTarget[targetId];\n        if (\n          limboKey &&\n          targetChange.currentStatusUpdate ===\n            CurrentStatusUpdate.MarkCurrent &&\n          !remoteEvent.documentUpdates.get(limboKey)\n        ) {\n          // When listening to a query the server responds with a snapshot\n          // containing documents matching the query and a current marker\n          // telling us we're now in sync. It's possible for these to arrive\n          // as separate remote events or as a single remote event.\n          // For a document query, there will be no documents sent in the\n          // response if the document doesn't exist.\n          //\n          // If the snapshot arrives separately from the current marker,\n          // we handle it normally and updateTrackedLimbos will resolve the\n          // limbo status of the document, removing it from limboDocumentRefs.\n          // This works because clients only initiate limbo resolution when\n          // a target is current and because all current targets are\n          // always at a consistent snapshot.\n          //\n          // However, if the document doesn't exist and the current marker\n          // arrives, the document is not present in the snapshot and our\n          // normal view handling would consider the document to remain in\n          // limbo indefinitely because there are no updates to the document.\n          // To avoid this, we specially handle this just this case here:\n          // synthesizing a delete.\n          //\n          // TODO(dimond): Ideally we would have an explicit lookup query\n          // instead resulting in an explicit delete message and we could\n          // remove this special logic.\n          remoteEvent.addDocumentUpdate(\n            new NoDocument(limboKey, remoteEvent.snapshotVersion)\n          );\n        }\n      }\n    );\n\n    return this.localStore.applyRemoteEvent(remoteEvent).then(changes => {\n      return this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n    });\n  }\n\n  rejectListen(targetId: TargetId, err: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectListens()');\n    const limboKey = this.limboKeysByTarget[targetId];\n    if (limboKey) {\n      // Since this query failed, we won't want to manually unlisten to it.\n      // So go ahead and remove it from bookkeeping.\n      this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n      delete this.limboKeysByTarget[targetId];\n\n      // TODO(klimt): We really only should do the following on permission\n      // denied errors, but we don't have the cause code here.\n\n      // It's a limbo doc. Create a synthetic event saying it was deleted.\n      // This is kind of a hack. Ideally, we would have a method in the local\n      // store to purge a document. However, it would be tricky to keep all of\n      // the local store's invariants with another method.\n      let docMap = new SortedMap<DocumentKey, MaybeDocument>(\n        DocumentKey.comparator\n      );\n      docMap = docMap.insert(\n        limboKey,\n        new NoDocument(limboKey, SnapshotVersion.forDeletedDoc())\n      );\n      const event = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n      return this.applyRemoteEvent(event);\n    } else {\n      const queryView = this.queryViewsByTarget[targetId];\n      assert(!!queryView, 'Unknown targetId: ' + targetId);\n      return this.localStore.releaseQuery(queryView.query).then(() => {\n        return this.removeAndCleanupQuery(queryView).then(() => {\n          this.errorHandler!(queryView.query, err);\n        });\n      });\n    }\n  }\n\n  applySuccessfulWrite(\n    mutationBatchResult: MutationBatchResult\n  ): Promise<void> {\n    this.assertSubscribed('applySuccessfulWrite()');\n\n    // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught\n    // up), so we raise user callbacks first so that they consistently happen\n    // before listen events.\n    this.processUserCallback(\n      mutationBatchResult.batch.batchId,\n      /*error=*/ null\n    );\n\n    return this.localStore\n      .acknowledgeBatch(mutationBatchResult)\n      .then(changes => {\n        return this.emitNewSnapsAndNotifyLocalStore(changes);\n      });\n  }\n\n  rejectFailedWrite(batchId: BatchId, error: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectFailedWrite()');\n\n    // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught up),\n    // so we raise user callbacks first so that they consistently happen before\n    // listen events.\n    this.processUserCallback(batchId, error);\n\n    return this.localStore.rejectBatch(batchId).then(changes => {\n      return this.emitNewSnapsAndNotifyLocalStore(changes);\n    });\n  }\n\n  private addMutationCallback(\n    batchId: BatchId,\n    callback: Deferred<void>\n  ): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n    if (!newCallbacks) {\n      newCallbacks = new SortedMap<BatchId, Deferred<void>>(\n        primitiveComparator\n      );\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n  }\n\n  /**\n   * Resolves or rejects the user callback for the given batch and then discards\n   * it.\n   */\n  private processUserCallback(batchId: BatchId, error: Error | null): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n      const callback = newCallbacks.get(batchId);\n      if (callback) {\n        assert(\n          batchId === newCallbacks.minKey(),\n          'Mutation callbacks processed out-of-order?'\n        );\n        if (error) {\n          callback.reject(error);\n        } else {\n          callback.resolve();\n        }\n        newCallbacks = newCallbacks.remove(batchId);\n      }\n      this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    }\n  }\n\n  private removeAndCleanupQuery(queryView: QueryView): Promise<void> {\n    this.queryViewsByQuery.delete(queryView.query);\n    delete this.queryViewsByTarget[queryView.targetId];\n\n    this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n    return this.gcLimboDocuments();\n  }\n\n  private updateTrackedLimbos(\n    targetId: TargetId,\n    limboChanges: LimboDocumentChange[]\n  ): Promise<void> {\n    for (const limboChange of limboChanges) {\n      if (limboChange instanceof AddedLimboDocument) {\n        this.limboDocumentRefs.addReference(limboChange.key, targetId);\n        this.trackLimboChange(limboChange);\n      } else if (limboChange instanceof RemovedLimboDocument) {\n        log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n        this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n      } else {\n        fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n      }\n    }\n    return this.gcLimboDocuments();\n  }\n\n  private trackLimboChange(limboChange: AddedLimboDocument): void {\n    const key = limboChange.key;\n    if (!this.limboTargetsByKey.get(key)) {\n      log.debug(LOG_TAG, 'New document in limbo: ' + key);\n      const limboTargetId = this.targetIdGenerator.next();\n      const query = Query.atPath(key.path);\n      this.limboKeysByTarget[limboTargetId] = key;\n      this.remoteStore.listen(\n        new QueryData(query, limboTargetId, QueryPurpose.Listen)\n      );\n      this.limboTargetsByKey = this.limboTargetsByKey.insert(\n        key,\n        limboTargetId\n      );\n    }\n  }\n\n  private gcLimboDocuments(): Promise<void> {\n    // HACK: We can use a null transaction here, because we know that the\n    // reference set is entirely within memory and doesn't need a store engine.\n    return this.limboCollector\n      .collectGarbage(null)\n      .next(keys => {\n        keys.forEach(key => {\n          const limboTargetId = this.limboTargetsByKey.get(key);\n          if (limboTargetId === null) {\n            // This target already got removed, because the query failed.\n            return;\n          }\n          this.remoteStore.unlisten(limboTargetId);\n          this.limboTargetsByKey = this.limboTargetsByKey.remove(key);\n          delete this.limboKeysByTarget[limboTargetId];\n        });\n      })\n      .toPromise();\n  }\n\n  // Visible for testing\n  currentLimboDocs(): SortedMap<DocumentKey, TargetId> {\n    return this.limboTargetsByKey;\n  }\n\n  private emitNewSnapsAndNotifyLocalStore(\n    changes: MaybeDocumentMap,\n    remoteEvent?: RemoteEvent\n  ): Promise<void> {\n    const newSnaps: ViewSnapshot[] = [];\n    const docChangesInAllViews: LocalViewChanges[] = [];\n    const queriesProcessed: Array<Promise<void>> = [];\n\n    this.queryViewsByQuery.forEach((_, queryView) => {\n      queriesProcessed.push(\n        Promise.resolve()\n          .then(() => {\n            const viewDocChanges = queryView.view.computeDocChanges(changes);\n            if (!viewDocChanges.needsRefill) {\n              return viewDocChanges;\n            }\n            // The query has a limit and some docs were removed, so we need\n            // to re-run the query against the local store to make sure we\n            // didn't lose any good docs that had been past the limit.\n            return this.localStore.executeQuery(queryView.query).then(docs => {\n              return queryView.view.computeDocChanges(docs, viewDocChanges);\n            });\n          })\n          .then((viewDocChanges: ViewDocumentChanges) => {\n            const targetChange =\n              remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n            const viewChange = queryView.view.applyChanges(\n              viewDocChanges,\n              targetChange\n            );\n            return this.updateTrackedLimbos(\n              queryView.targetId,\n              viewChange.limboChanges\n            ).then(() => {\n              if (viewChange.snapshot) {\n                newSnaps.push(viewChange.snapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(\n                  viewChange.snapshot\n                );\n                docChangesInAllViews.push(docChanges);\n              }\n            });\n          })\n      );\n    });\n\n    return Promise.all(queriesProcessed)\n      .then(() => {\n        this.viewHandler!(newSnaps);\n        return this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n      })\n      .then(() => {\n        return this.localStore.collectGarbage();\n      });\n  }\n\n  private assertSubscribed(fnName: string): void {\n    assert(\n      this.viewHandler !== null && this.errorHandler !== null,\n      'Trying to call ' + fnName + ' before calling subscribe().'\n    );\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    this.currentUser = user;\n    return this.localStore\n      .handleUserChange(user)\n      .then(changes => {\n        return this.emitNewSnapsAndNotifyLocalStore(changes);\n      })\n      .then(() => {\n        return this.remoteStore.handleUserChange(user);\n      });\n  }\n}\n"]}