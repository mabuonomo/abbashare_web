{"version":3,"sources":["../src/core/view.ts"],"names":[],"mappings":"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","file":"view.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport {\n  CurrentStatusUpdate,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\n\nimport { Query } from './query';\nimport {\n  ChangeType,\n  DocumentChangeSet,\n  SyncState,\n  ViewSnapshot\n} from './view_snapshot';\n\nexport type LimboDocumentChange = AddedLimboDocument | RemovedLimboDocument;\nexport class AddedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\nexport class RemovedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\n\n/** The result of applying a set of doc changes to a view. */\nexport interface ViewDocumentChanges {\n  /** The new set of docs that should be in the view. */\n  documentSet: DocumentSet;\n  /** The diff of this these docs with the previous set of docs. */\n  changeSet: DocumentChangeSet;\n  /**\n   * Whether the set of documents passed in was not sufficient to calculate the\n   * new state of the view and there needs to be another pass based on the\n   * local cache.\n   */\n  needsRefill: boolean;\n\n  mutatedKeys: DocumentKeySet;\n}\n\nexport interface ViewChange {\n  snapshot?: ViewSnapshot;\n  limboChanges: LimboDocumentChange[];\n}\n\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nexport class View {\n  private syncState: SyncState | null = null;\n  /**\n   * A flag whether the view is current with the backend. A view is considered\n   * current after it has seen the current flag from the backend and did not\n   * lose consistency within the watch stream (e.g. because of an existence\n   * filter mismatch).\n   */\n  private current = false;\n  private documentSet: DocumentSet;\n  /** Documents in the view but not in the remote target */\n  private limboDocuments = documentKeySet();\n  /** Document Keys that have local changes */\n  private mutatedKeys = documentKeySet();\n\n  constructor(\n    private query: Query,\n    /** Documents included in the remote target */\n    private syncedDocuments: DocumentKeySet\n  ) {\n    this.documentSet = new DocumentSet(query.docComparator.bind(query));\n  }\n\n  /**\n   * Iterates over a set of doc changes, applies the query limit, and computes\n   * what the new results should be, what the changes were, and whether we may\n   * need to go back to the local cache for more results. Does not make any\n   * changes to the view.\n   * @param docChanges The doc changes to apply to this view.\n   * @param previousChanges If this is being called with a refill, then start\n   *        with this set of docs and changes instead of the current view.\n   * @return a new set of docs, changes, and refill flag.\n   */\n  computeDocChanges(\n    docChanges: MaybeDocumentMap,\n    previousChanges?: ViewDocumentChanges\n  ): ViewDocumentChanges {\n    const changeSet = previousChanges\n      ? previousChanges.changeSet\n      : new DocumentChangeSet();\n    const oldDocumentSet = previousChanges\n      ? previousChanges.documentSet\n      : this.documentSet;\n    let newMutatedKeys = previousChanges\n      ? previousChanges.mutatedKeys\n      : this.mutatedKeys;\n    let newDocumentSet = oldDocumentSet;\n    let needsRefill = false;\n\n    // Track the last doc in a (full) limit. This is necessary, because some\n    // update (a delete, or an update moving a doc past the old limit) might\n    // mean there is some other document in the local cache that either should\n    // come (1) between the old last limit doc and the new last document, in the\n    // case of updates, or (2) after the new last document, in the case of\n    // deletes. So we keep this doc at the old limit to compare the updates to.\n    //\n    // Note that this should never get used in a refill (when previousChanges is\n    // set), because there will only be adds -- no deletes or updates.\n    const lastDocInLimit =\n      this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n        ? oldDocumentSet.last()\n        : null;\n\n    docChanges.inorderTraversal(\n      (key: DocumentKey, newMaybeDoc: MaybeDocument) => {\n        const oldDoc = oldDocumentSet.get(key);\n        let newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n        if (newDoc) {\n          assert(\n            key.equals(newDoc.key),\n            'Mismatching keys found in document changes: ' +\n              key +\n              ' != ' +\n              newDoc.key\n          );\n          newDoc = this.query.matches(newDoc) ? newDoc : null;\n        }\n        if (newDoc) {\n          newDocumentSet = newDocumentSet.add(newDoc);\n          if (newDoc.hasLocalMutations) {\n            newMutatedKeys = newMutatedKeys.add(key);\n          } else {\n            newMutatedKeys = newMutatedKeys.delete(key);\n          }\n        } else {\n          newDocumentSet = newDocumentSet.delete(key);\n          newMutatedKeys = newMutatedKeys.delete(key);\n        }\n\n        // Calculate change\n        if (oldDoc && newDoc) {\n          const docsEqual = oldDoc.data.equals(newDoc.data);\n          if (\n            !docsEqual ||\n            oldDoc.hasLocalMutations !== newDoc.hasLocalMutations\n          ) {\n            // only report a change if document actually changed\n            if (docsEqual) {\n              changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n            } else {\n              changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n            }\n\n            if (\n              lastDocInLimit &&\n              this.query.docComparator(newDoc, lastDocInLimit) > 0\n            ) {\n              // This doc moved from inside the limit to after the limit.\n              // That means there may be some doc in the local cache that's\n              // actually less than this one.\n              needsRefill = true;\n            }\n          }\n        } else if (!oldDoc && newDoc) {\n          changeSet.track({ type: ChangeType.Added, doc: newDoc });\n        } else if (oldDoc && !newDoc) {\n          changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n          if (lastDocInLimit) {\n            // A doc was removed from a full limit query. We'll need to\n            // requery from the local cache to see if we know about some other\n            // doc that should be in the results.\n            needsRefill = true;\n          }\n        }\n      }\n    );\n    if (this.query.hasLimit()) {\n      // TODO(klimt): Make DocumentSet size be constant time.\n      while (newDocumentSet.size > this.query.limit!) {\n        const oldDoc = newDocumentSet.last();\n        newDocumentSet = newDocumentSet.delete(oldDoc!.key);\n        changeSet.track({ type: ChangeType.Removed, doc: oldDoc! });\n      }\n    }\n    assert(\n      !needsRefill || !previousChanges,\n      'View was refilled using docs that themselves needed refilling.'\n    );\n    return {\n      documentSet: newDocumentSet,\n      changeSet,\n      needsRefill,\n      mutatedKeys: newMutatedKeys\n    };\n  }\n\n  /**\n   * Updates the view with the given ViewDocumentChanges and updates limbo docs\n   * and sync state from the given (optional) target change.\n   * @param docChanges The set of changes to make to the view's docs.\n   * @param targetChange A target change to apply for computing limbo docs and\n   *        sync state.\n   * @return A new ViewChange with the given docs, changes, and sync state.\n   */\n  applyChanges(\n    docChanges: ViewDocumentChanges,\n    targetChange?: TargetChange\n  ): ViewChange {\n    assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n    const oldDocs = this.documentSet;\n    this.documentSet = docChanges.documentSet;\n    this.mutatedKeys = docChanges.mutatedKeys;\n    // Sort changes based on type and query comparator\n    const changes = docChanges.changeSet.getChanges();\n    changes.sort((c1, c2) => {\n      return (\n        compareChangeType(c1.type, c2.type) ||\n        this.query.docComparator(c1.doc, c2.doc)\n      );\n    });\n\n    const limboChanges = this.applyTargetChange(targetChange);\n    const synced = this.limboDocuments.size === 0 && this.current;\n    const newSyncState = synced ? SyncState.Synced : SyncState.Local;\n    const syncStateChanged = newSyncState !== this.syncState;\n    this.syncState = newSyncState;\n\n    if (changes.length === 0 && !syncStateChanged) {\n      // no changes\n      return { limboChanges };\n    } else {\n      return {\n        snapshot: {\n          query: this.query,\n          docs: docChanges.documentSet,\n          oldDocs,\n          docChanges: changes,\n          fromCache: newSyncState === SyncState.Local,\n          syncStateChanged,\n          hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n        },\n        limboChanges\n      };\n    }\n  }\n\n  /**\n   * Returns whether the doc for the given key should be in limbo.\n   */\n  private shouldBeInLimbo(key: DocumentKey): boolean {\n    // If the remote end says it's part of this query, it's not in limbo.\n    if (this.syncedDocuments.has(key)) {\n      return false;\n    }\n    // The local store doesn't think it's a result, so it shouldn't be in limbo.\n    if (!this.documentSet.has(key)) {\n      return false;\n    }\n    // If there are local changes to the doc, they might explain why the server\n    // doesn't know that it's part of the query. So don't put it in limbo.\n    // TODO(klimt): Ideally, we would only consider changes that might actually\n    // affect this specific query.\n    if (this.documentSet.get(key)!.hasLocalMutations) {\n      return false;\n    }\n    // Everything else is in limbo.\n    return true;\n  }\n\n  /**\n   * Updates syncedDocuments, current, and limbo docs based on the given change.\n   * Returns the list of changes to which docs are in limbo.\n   */\n  private applyTargetChange(\n    targetChange?: TargetChange\n  ): LimboDocumentChange[] {\n    if (targetChange) {\n      const targetMapping = targetChange.mapping;\n      if (targetMapping instanceof ResetMapping) {\n        this.syncedDocuments = targetMapping.documents;\n      } else if (targetMapping instanceof UpdateMapping) {\n        this.syncedDocuments = targetMapping.applyToKeySet(\n          this.syncedDocuments\n        );\n      }\n\n      switch (targetChange.currentStatusUpdate) {\n        case CurrentStatusUpdate.MarkCurrent:\n          this.current = true;\n          break;\n        case CurrentStatusUpdate.MarkNotCurrent:\n          this.current = false;\n          break;\n        case CurrentStatusUpdate.None:\n          break;\n        default:\n          fail(\n            'Unknown current status update: ' + targetChange.currentStatusUpdate\n          );\n      }\n    }\n\n    // Recompute the set of limbo docs.\n    // TODO(klimt): Do this incrementally so that it's not quadratic when\n    // updating many documents.\n    const oldLimboDocuments = this.limboDocuments;\n    this.limboDocuments = documentKeySet();\n    if (this.current) {\n      this.documentSet.forEach(doc => {\n        if (this.shouldBeInLimbo(doc.key)) {\n          this.limboDocuments = this.limboDocuments.add(doc.key);\n        }\n      });\n    }\n\n    // Diff the new limbo docs with the old limbo docs.\n    const changes: LimboDocumentChange[] = [];\n    oldLimboDocuments.forEach(key => {\n      if (!this.limboDocuments.has(key)) {\n        changes.push(new RemovedLimboDocument(key));\n      }\n    });\n    this.limboDocuments.forEach(key => {\n      if (!oldLimboDocuments.has(key)) {\n        changes.push(new AddedLimboDocument(key));\n      }\n    });\n    return changes;\n  }\n}\n\nfunction compareChangeType(c1: ChangeType, c2: ChangeType): number {\n  const order = (change: ChangeType) => {\n    switch (change) {\n      case ChangeType.Added:\n        return 1;\n      case ChangeType.Modified:\n        return 2;\n      case ChangeType.Metadata:\n        // A metadata change is converted to a modified change at the public\n        // api layer.  Since we sort by document key and then change type,\n        // metadata and modified changes must be sorted equivalently.\n        return 2;\n      case ChangeType.Removed:\n        return 0;\n      default:\n        return fail('Unknown ChangeType: ' + change);\n    }\n  };\n\n  return order(c1) - order(c2);\n}\n"]}