{"version":3,"sources":["../src/remote/watch_change.ts"],"names":[],"mappings":"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","file":"watch_change.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as objUtils from '../util/obj';\n\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  CurrentStatusUpdate,\n  RemoteEvent,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from './remote_event';\n\n/**\n * Internal representation of the watcher API protocol buffers.\n */\nexport type WatchChange =\n  | DocumentWatchChange\n  | WatchTargetChange\n  | ExistenceFilterChange;\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nexport class DocumentWatchChange {\n  constructor(\n    /** The new document applies to all of these targets. */\n    public updatedTargetIds: TargetId[],\n    /** The new document is removed from all of these targets. */\n    public removedTargetIds: TargetId[],\n    /** The key of the document for this change. */\n    public key: DocumentKey,\n    /**\n       * The new document or NoDocument if it was deleted. Is null if the\n       * document went out of view without the server sending a new document.\n       */\n    public newDoc: Document | NoDocument | null\n  ) {}\n}\n\nexport class ExistenceFilterChange {\n  constructor(\n    public targetId: TargetId,\n    public existenceFilter: ExistenceFilter\n  ) {}\n}\n\nexport enum WatchTargetChangeState {\n  NoChange,\n  Added,\n  Removed,\n  Current,\n  Reset\n}\n\nexport class WatchTargetChange {\n  constructor(\n    /** What kind of change occurred to the watch target. */\n    public state: WatchTargetChangeState,\n    /** The target IDs that were added/removed/set. */\n    public targetIds: TargetId[],\n    /**\n       * An opaque, server-assigned token that allows watching a query to be\n       * resumed after disconnecting without retransmitting all the data that\n       * matches the query. The resume token essentially identifies a point in\n       * time from which the server should resume sending results.\n       */\n    public resumeToken: ProtoByteString = emptyByteString(),\n    /** An RPC error indicating why the watch failed. */\n    public cause: FirestoreError | null = null\n  ) {}\n}\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nexport class WatchChangeAggregator {\n  constructor(\n    private snapshotVersion: SnapshotVersion,\n    private readonly listenTargets: { [targetId: number]: QueryData },\n    pendingTargetResponses: { [targetId: number]: number }\n  ) {\n    this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n  }\n\n  /** The existence filter - if any - for the given target IDs. */\n  readonly existenceFilters: { [targetId: number]: ExistenceFilter } = {};\n\n  /** The number of pending responses that we are waiting on from watch. */\n  readonly pendingTargetResponses: { [targetId: number]: number };\n\n  /** Keeps track of the current target mappings */\n  private targetChanges: { [targetId: number]: TargetChange } = {};\n\n  /** Keeps track of document to update */\n  private documentUpdates = maybeDocumentMap();\n\n  /** Whether this aggregator was frozen and can no longer be modified */\n  private frozen = false;\n\n  /** Aggregates a watch change into the current state */\n  add(watchChange: WatchChange): void {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    if (watchChange instanceof DocumentWatchChange) {\n      this.addDocumentChange(watchChange);\n    } else if (watchChange instanceof WatchTargetChange) {\n      this.addTargetChange(watchChange);\n    } else if (watchChange instanceof ExistenceFilterChange) {\n      this.addExistenceFilterChange(watchChange);\n    } else {\n      fail('Unknown watch change: ' + watchChange);\n    }\n  }\n\n  /** Aggregates all provided watch changes to the current state in order */\n  addChanges(watchChanges: WatchChange[]): void {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    watchChanges.forEach(change => this.add(change));\n  }\n\n  /**\n   * Converts the current state into a remote event with the snapshot version\n   * provided via the constructor.\n   */\n  createRemoteEvent(): RemoteEvent {\n    const targetChanges = this.targetChanges;\n\n    // Remove all the non-active targets from the remote event.\n    objUtils.forEachNumber(this.targetChanges, targetId => {\n      if (!this.isActiveTarget(targetId)) {\n        delete targetChanges[targetId];\n      }\n    });\n\n    // Mark this aggregator as frozen so no further modifications are made\n    this.frozen = true;\n    return new RemoteEvent(\n      this.snapshotVersion,\n      targetChanges,\n      this.documentUpdates\n    );\n  }\n\n  private ensureTargetChange(targetId: TargetId): TargetChange {\n    let change = this.targetChanges[targetId];\n    if (!change) {\n      // Create an UpdateMapping by default, since resets are always explicit.\n      change = {\n        currentStatusUpdate: CurrentStatusUpdate.None,\n        snapshotVersion: this.snapshotVersion,\n        mapping: new UpdateMapping(),\n        resumeToken: emptyByteString()\n      };\n      this.targetChanges[targetId] = change;\n    }\n    return change;\n  }\n\n  /**\n   * We need to wait for watch to ack targets before we process those events,\n   * so to know if a target is active, there must be no pending acks we're\n   * waiting for and it must be in the current list of targets that the client\n   * cares about.\n   *\n   * This method is visible for testing.\n   */\n  protected isActiveTarget(targetId: TargetId): boolean {\n    return (\n      !objUtils.contains(this.pendingTargetResponses, targetId) &&\n      objUtils.contains(this.listenTargets, targetId)\n    );\n  }\n\n  private addDocumentChange(docChange: DocumentWatchChange) {\n    let relevant = false;\n\n    for (const targetId of docChange.updatedTargetIds) {\n      if (this.isActiveTarget(targetId)) {\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.add(docChange.key);\n        relevant = true;\n      }\n    }\n\n    for (const targetId of docChange.removedTargetIds) {\n      if (this.isActiveTarget(targetId)) {\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.delete(docChange.key);\n        relevant = true;\n      }\n    }\n\n    // Only update the document if there is a new document to replace to an\n    // active target that is being listened to, this might be just a target\n    // update instead.\n    if (docChange.newDoc && relevant) {\n      this.documentUpdates = this.documentUpdates.insert(\n        docChange.key,\n        docChange.newDoc\n      );\n    }\n  }\n\n  private addTargetChange(targetChange: WatchTargetChange) {\n    targetChange.targetIds.forEach(targetId => {\n      const change = this.ensureTargetChange(targetId);\n      switch (targetChange.state) {\n        case WatchTargetChangeState.NoChange:\n          if (this.isActiveTarget(targetId)) {\n            // Creating the change above satisfies the semantics of no-change.\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          if (!objUtils.contains(this.pendingTargetResponses, targetId)) {\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            change.mapping = new UpdateMapping();\n            change.currentStatusUpdate = CurrentStatusUpdate.None;\n            delete this.existenceFilters[targetId];\n          }\n          applyResumeToken(change, targetChange.resumeToken);\n          break;\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can\n          // post-filter and remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          assert(\n            !targetChange.cause,\n            'WatchChangeAggregator does not handle errored targets'\n          );\n          break;\n        case WatchTargetChangeState.Current:\n          if (this.isActiveTarget(targetId)) {\n            change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Reset:\n          if (this.isActiveTarget(targetId)) {\n            // Overwrite any existing target mapping with a reset\n            // mapping. Every subsequent update will modify the reset\n            // mapping, not an update mapping.\n            change.mapping = new ResetMapping();\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      }\n    });\n  }\n\n  /**\n   * Record that we get a watch target add/remove by decrementing the number of\n   * pending target responses that we have.\n   */\n  private recordTargetResponse(targetId: TargetId): void {\n    const newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n    if (newCount === 0) {\n      delete this.pendingTargetResponses[targetId];\n    } else {\n      this.pendingTargetResponses[targetId] = newCount;\n    }\n  }\n\n  private addExistenceFilterChange(change: ExistenceFilterChange): void {\n    if (this.isActiveTarget(change.targetId)) {\n      this.existenceFilters[change.targetId] = change.existenceFilter;\n    }\n  }\n}\n\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(\n  change: TargetChange,\n  resumeToken: ProtoByteString\n): void {\n  if (resumeToken.length > 0) {\n    change.resumeToken = resumeToken;\n  }\n}\n"]}