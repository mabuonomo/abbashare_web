{"version":3,"sources":["../src/remote/persistent_stream.ts"],"names":[],"mappings":"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","file":"persistent_stream.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider, Token } from '../api/credentials';\nimport { DatabaseInfo } from '../core/database_info';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\n\nimport { ExponentialBackoff } from './backoff';\nimport { Connection, Stream } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport { WatchChange } from './watch_change';\n\nconst LOG_TAG = 'PersistentStream';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface ListenRequest extends api.ListenRequest {\n  database?: string;\n}\nexport interface WriteRequest extends api.WriteRequest {\n  database?: string;\n}\n\nenum PersistentStreamState {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  Initial,\n\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n  Auth,\n\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n  Open,\n\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n  Error,\n\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n  Backoff,\n\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n  Stopped\n}\n\n/**\n * Provides a common interface that is shared by the listeners for stream\n * events by the concrete implementation classes.\n */\nexport interface PersistentStreamListener {\n  /**\n   * Called after the stream was established and can accept outgoing\n   * messages\n   */\n  onOpen: () => Promise<void>;\n  /**\n   * Called after the stream has closed. If there was an error, the\n   * FirestoreError will be set.\n   */\n  onClose: (err?: FirestoreError) => Promise<void>;\n}\n\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst BACKOFF_INITIAL_DELAY_MS = 1000;\n\n/** Maximum backoff time in milliseconds */\nconst BACKOFF_MAX_DELAY_MS = 60 * 1000;\n\nconst BACKOFF_FACTOR = 1.5;\n\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nexport abstract class PersistentStream<\n  SendType,\n  ReceiveType,\n  ListenerType extends PersistentStreamListener\n> {\n  private state: PersistentStreamState;\n\n  protected stream: Stream<SendType, ReceiveType> | null = null;\n\n  protected backoff: ExponentialBackoff;\n\n  protected listener: ListenerType | null = null;\n\n  constructor(\n    private queue: AsyncQueue,\n    protected connection: Connection,\n    private credentialsProvider: CredentialsProvider,\n    listener: ListenerType,\n    // Used for faster retries in testing\n    initialBackoffDelay?: number\n  ) {\n    this.backoff = new ExponentialBackoff(\n      initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS,\n      BACKOFF_FACTOR,\n      BACKOFF_MAX_DELAY_MS\n    );\n    this.state = PersistentStreamState.Initial;\n    this.listener = listener;\n  }\n\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n  isStarted(): boolean {\n    return (\n      this.state === PersistentStreamState.Backoff ||\n      this.state === PersistentStreamState.Auth ||\n      this.state === PersistentStreamState.Open\n    );\n  }\n\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n  isOpen(): boolean {\n    return this.state === PersistentStreamState.Open;\n  }\n\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n  start(): void {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff();\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n\n    this.auth();\n  }\n\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n  stop(): void {\n    // Prevent any possible future restart of this stream\n    this.state = PersistentStreamState.Stopped;\n\n    // Clear the listener to avoid bleeding of events from the underlying\n    // streams\n    this.listener = null;\n\n    // Clean up the underlying stream because we are no longer interested in\n    // events\n    if (this.stream !== null) {\n      this.stream.close();\n      this.stream = null;\n    }\n  }\n\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n  inhibitBackoff(): void {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  }\n\n  /**\n   * Used by subclasses to start the concrete RPC and return the underlying\n   * connection stream.\n   */\n  protected abstract startRpc(\n    token: Token | null\n  ): Stream<SendType, ReceiveType>;\n\n  /**\n   * Called after the stream has received a message. The function will be\n   * called on the right queue and must return a Promise.\n   * @param message The message received from the stream.\n   */\n  protected abstract onMessage(message: ReceiveType): Promise<void>;\n\n  private auth(): void {\n    assert(\n      this.state === PersistentStreamState.Initial,\n      'Must be in initial state to auth'\n    );\n\n    this.state = PersistentStreamState.Auth;\n\n    this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(\n      token => {\n        // Normally we'd have to schedule the callback on the AsyncQueue.\n        // However, the following calls are safe to be called outside the\n        // AsyncQueue since they don't chain asynchronous calls\n        this.startStream(token);\n      },\n      (error: Error) => {\n        this.queue.schedule(() => {\n          if (this.state !== PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            const rpcError = new FirestoreError(\n              Code.UNKNOWN,\n              'Fetching auth token failed: ' + error.message\n            );\n            return this.handleStreamClose(rpcError);\n          } else {\n            return Promise.resolve();\n          }\n        });\n      }\n    );\n  }\n\n  private startStream(token: Token | null): void {\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(\n      this.state === PersistentStreamState.Auth,\n      'Trying to start stream in a non-auth state'\n    );\n    // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n    const dispatchIfNotStopped = (fn: () => Promise<void>) => {\n      this.queue.schedule(() => {\n        // Only raise events if the listener has not changed\n        if (this.state !== PersistentStreamState.Stopped) {\n          return fn();\n        } else {\n          return Promise.resolve();\n        }\n      });\n    };\n\n    // Only start stream if listener has not changed\n    if (this.listener !== null) {\n      this.stream = this.startRpc(token);\n      this.stream.onOpen(() => {\n        dispatchIfNotStopped(() => {\n          assert(\n            this.state === PersistentStreamState.Auth,\n            'Expected stream to be in state auth, but was ' + this.state\n          );\n          this.state = PersistentStreamState.Open;\n          return this.listener!.onOpen();\n        });\n      });\n      this.stream.onClose((error: FirestoreError) => {\n        dispatchIfNotStopped(() => {\n          return this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage((msg: ReceiveType) => {\n        dispatchIfNotStopped(() => {\n          return this.onMessage(msg);\n        });\n      });\n    }\n  }\n\n  private performBackoff(): void {\n    assert(\n      this.state === PersistentStreamState.Error,\n      'Should only perform backoff in an error case'\n    );\n    this.state = PersistentStreamState.Backoff;\n\n    this.backoff.backoffAndWait().then(() => {\n      // Backoff does not run on the AsyncQueue, so we need to reschedule to\n      // make sure the queue blocks\n      this.queue.schedule(() => {\n        if (this.state === PersistentStreamState.Stopped) {\n          // Stream can be stopped while waiting for backoff to complete.\n          return Promise.resolve();\n        }\n\n        this.state = PersistentStreamState.Initial;\n        this.start();\n        assert(this.isStarted(), 'PersistentStream should have started');\n        return Promise.resolve();\n      });\n    });\n  }\n\n  private handleStreamClose(error?: FirestoreError): Promise<void> {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, `close with error: ${error}`);\n\n    this.stream = null;\n\n    // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n    this.state = PersistentStreamState.Error;\n\n    if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      log.debug(\n        LOG_TAG,\n        'Using maximum backoff delay to prevent overloading the backend.'\n      );\n      this.backoff.resetToMax();\n    }\n\n    return this.listener!.onClose(error);\n  }\n}\n\n/** Listener for the PersistentWatchStream */\nexport interface WatchStreamListener extends PersistentStreamListener {\n  /**\n   * Called on a watchChange. The snapshot parameter will be MIN if the watch\n   * change did not have a snapshot associated with it.\n   */\n  onWatchChange: (\n    watchChange: WatchChange,\n    snapshot: SnapshotVersion\n  ) => Promise<void>;\n}\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nexport class PersistentListenStream extends PersistentStream<\n  api.ListenRequest,\n  api.ListenResponse,\n  WatchStreamListener\n> {\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    listener: WatchStreamListener,\n    initialBackoffDelay?: number\n  ) {\n    super(queue, connection, credentials, listener, initialBackoffDelay);\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.ListenRequest, api.ListenResponse> {\n    return this.connection.openStream('Listen', token);\n  }\n\n  protected onMessage(watchChangeProto: api.ListenResponse): Promise<void> {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n\n    const watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    const snapshot = this.serializer.versionFromListenResponse(\n      watchChangeProto\n    );\n    return this.listener!.onWatchChange(watchChange, snapshot);\n  }\n\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n  watch(queryData: QueryData): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n\n    const labels = this.serializer.toListenRequestLabels(queryData);\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.stream!.send(request);\n  }\n\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n  unwatch(targetId: TargetId): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.stream!.send(request);\n  }\n}\n\n/** Listener for the PersistentWriteStream */\nexport interface WriteStreamListener extends PersistentStreamListener {\n  /**\n   * Called by the PersistentWriteStream upon a successful handshake response\n   * from the server, which is the receiver's cue to send any pending writes.\n   */\n  onHandshakeComplete: () => Promise<void>;\n\n  /**\n   * Called by the PersistentWriteStream upon receiving a StreamingWriteResponse\n   * from the server that contains a mutation result.\n   */\n  onMutationResult: (\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ) => Promise<void>;\n}\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nexport class PersistentWriteStream extends PersistentStream<\n  api.WriteRequest,\n  api.WriteResponse,\n  WriteStreamListener\n> {\n  private handshakeComplete_ = false;\n\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    listener: WriteStreamListener,\n    initialBackoffDelay?: number\n  ) {\n    super(queue, connection, credentials, listener, initialBackoffDelay);\n  }\n\n  /**\n   * The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   *\n   * PersistentWriteStream manages propagating this value from responses to the\n   * next request.\n   */\n  public lastStreamToken: ProtoByteString;\n\n  /**\n   * Tracks whether or not a handshake has been successfully exchanged and\n   * the stream is ready to accept mutations.\n   */\n  get handshakeComplete(): boolean {\n    return this.handshakeComplete_;\n  }\n\n  // Override of PersistentStream.start\n  start(): void {\n    this.handshakeComplete_ = false;\n    super.start();\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.WriteRequest, api.WriteResponse> {\n    return this.connection.openStream('Write', token);\n  }\n\n  protected onMessage(responseProto: api.WriteResponse): Promise<void> {\n    // Always capture the last stream token.\n    assert(\n      !!responseProto.streamToken,\n      'Got a write response without a stream token'\n    );\n    this.lastStreamToken = responseProto.streamToken!;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(\n        !responseProto.writeResults || responseProto.writeResults.length === 0,\n        'Got mutation results for handshake'\n      );\n      this.handshakeComplete_ = true;\n      return this.listener!.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n\n      const results = this.serializer.fromWriteResults(\n        responseProto.writeResults\n      );\n      const commitVersion = this.serializer.fromVersion(\n        responseProto.commitTime!\n      );\n      return this.listener!.onMutationResult(commitVersion, results);\n    }\n  }\n\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n  writeHandshake(): void {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed');\n    // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n    const request: WriteRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.stream!.send(request);\n  }\n\n  /** Sends a group of mutations to the Firestore backend to apply. */\n  writeMutations(mutations: Mutation[]): void {\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(\n      this.handshakeComplete_,\n      'Handshake must be complete before writing mutations'\n    );\n    assert(\n      this.lastStreamToken.length > 0,\n      'Trying to write mutation without a token'\n    );\n\n    const request: WriteRequest = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken as any,\n      writes: mutations.map(mutation => this.serializer.toMutation(mutation))\n    };\n\n    this.stream!.send(request);\n  }\n}\n"]}