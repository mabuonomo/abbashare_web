{"version":3,"sources":["../src/model/path.ts"],"names":[],"mappings":"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","file":"path.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n\nexport const DOCUMENT_KEY_NAME = '__name__';\n\n/**\n * Path represents an ordered sequence of string segments.\n */\nexport abstract class Path {\n  private segments: string[];\n  private offset: number;\n  private len: number;\n\n  public constructor(segments: string[], offset?: number, length?: number) {\n    this.init(segments, offset, length);\n  }\n\n  /**\n   * An initialization method that can be called from outside the constructor.\n   * We need this so that we can have a non-static construct method that returns\n   * the polymorphic `this` type.\n   */\n  private init(segments: string[], offset?: number, length?: number) {\n    if (offset === undefined) {\n      offset = 0;\n    } else if (offset > segments.length) {\n      fail('offset ' + offset + ' out of range ' + segments.length);\n    }\n\n    if (length === undefined) {\n      length = segments.length - offset;\n    } else if (length > segments.length - offset) {\n      fail('length ' + length + ' out of range ' + (segments.length - offset));\n    }\n    this.segments = segments;\n    this.offset = offset;\n    this.len = length;\n  }\n\n  /**\n   * Constructs a new instance of Path using the same concrete type as `this`.\n   * We need this instead of using the normal constructor, because polymorphic\n   * `this` doesn't work on static methods.\n   */\n  private construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): this {\n    const path: this = Object.create(Object.getPrototypeOf(this));\n    path.init(segments, offset, length);\n    return path;\n  }\n\n  get length(): number {\n    return this.len;\n  }\n\n  equals(other: Path): boolean {\n    return Path.comparator(this, other) === 0;\n  }\n\n  child(nameOrPath: string | this): this {\n    const segments = this.segments.slice(this.offset, this.limit());\n    if (nameOrPath instanceof Path) {\n      nameOrPath.forEach(segment => {\n        segments.push(segment);\n      });\n    } else if (typeof nameOrPath === 'string') {\n      segments.push(nameOrPath);\n    } else {\n      fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n    }\n    return this.construct(segments);\n  }\n\n  /** The index of one past the last segment of the path. */\n  private limit(): number {\n    return this.offset + this.length;\n  }\n\n  popFirst(size?: number): this {\n    size = size === undefined ? 1 : size;\n    assert(this.length >= size, \"Can't call popFirst() with less segments\");\n    return this.construct(\n      this.segments,\n      this.offset + size,\n      this.length - size\n    );\n  }\n\n  popLast(): this {\n    assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n    return this.construct(this.segments, this.offset, this.length - 1);\n  }\n\n  firstSegment(): string {\n    assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n    return this.segments[this.offset];\n  }\n\n  lastSegment(): string {\n    assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n    return this.segments[this.limit() - 1];\n  }\n\n  get(index: number): string {\n    assert(index < this.length, 'Index out of range');\n    return this.segments[this.offset + index];\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  isPrefixOf(other: this): boolean {\n    if (other.length < this.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== other.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  forEach(fn: (segment: string) => void): void {\n    for (let i = this.offset, end = this.limit(); i < end; i++) {\n      fn(this.segments[i]);\n    }\n  }\n\n  toArray(): string[] {\n    return this.segments.slice(this.offset, this.limit());\n  }\n\n  static comparator(p1: Path, p2: Path): number {\n    const len = Math.min(p1.length, p2.length);\n    for (let i = 0; i < len; i++) {\n      const left = p1.get(i);\n      const right = p2.get(i);\n      if (left < right) return -1;\n      if (left > right) return 1;\n    }\n    if (p1.length < p2.length) return -1;\n    if (p1.length > p2.length) return 1;\n    return 0;\n  }\n}\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nexport class ResourcePath extends Path {\n  canonicalString(): string {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    return this.toArray().join('/');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Creates a resource path from the given slash-delimited string.\n   */\n  static fromString(path: string): ResourcePath {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    if (path.indexOf('//') >= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid path (${path}). Paths must not contain // in them.`\n      );\n    }\n\n    // We may still have an empty segment at the beginning or end if they had a\n    // leading or trailing slash (which we allow).\n    const segments = path.split('/').filter(segment => segment.length > 0);\n\n    return new ResourcePath(segments);\n  }\n\n  static EMPTY_PATH = new ResourcePath([]);\n}\n\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n/** A dot-separated path for navigating sub-objects within a document. */\nexport class FieldPath extends Path {\n  /**\n   * Returns true if the string could be used as a segment in a field path\n   * without escaping.\n   */\n  private static isValidIdentifier(segment: string) {\n    return identifierRegExp.test(segment);\n  }\n\n  canonicalString(): string {\n    return this.toArray()\n      .map(str => {\n        str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n        if (!FieldPath.isValidIdentifier(str)) {\n          str = '`' + str + '`';\n        }\n        return str;\n      })\n      .join('.');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Returns true if this field references the key of a document.\n   */\n  isKeyField(): boolean {\n    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n  }\n\n  /**\n   * The field designating the key of a document.\n   */\n  static keyField(): FieldPath {\n    return new FieldPath([DOCUMENT_KEY_NAME]);\n  }\n\n  /**\n   * Parses a field string from the given server-formatted string.\n   *\n   * - Splitting the empty string is not allowed (for now at least).\n   * - Empty segments within the string (e.g. if there are two consecutive\n   *   separators) are not allowed.\n   *\n   * TODO(b/37244157): we should make this more strict. Right now, it allows\n   * non-identifier path components, even if they aren't escaped.\n   */\n  static fromServerFormat(path: string): FieldPath {\n    const segments: string[] = [];\n    let current = '';\n    let i = 0;\n\n    const addCurrentSegment = () => {\n      if (current.length === 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid field path (${path}). Paths must not be empty, begin ` +\n            `with '.', end with '.', or contain '..'`\n        );\n      }\n      segments.push(current);\n      current = '';\n    };\n\n    let inBackticks = false;\n\n    while (i < path.length) {\n      const c = path[i];\n      if (c === '\\\\') {\n        if (i + 1 === path.length) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has trailing escape character: ' + path\n          );\n        }\n        const next = path[i + 1];\n        if (!(next === '\\\\' || next === '.' || next === '`')) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has invalid escape sequence: ' + path\n          );\n        }\n        current += next;\n        i += 2;\n      } else if (c === '`') {\n        inBackticks = !inBackticks;\n        i++;\n      } else if (c === '.' && !inBackticks) {\n        addCurrentSegment();\n        i++;\n      } else {\n        current += c;\n        i++;\n      }\n    }\n    addCurrentSegment();\n\n    if (inBackticks) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Unterminated ` in path: ' + path\n      );\n    }\n\n    return new FieldPath(segments);\n  }\n\n  static EMPTY_PATH = new FieldPath([]);\n}\n"]}