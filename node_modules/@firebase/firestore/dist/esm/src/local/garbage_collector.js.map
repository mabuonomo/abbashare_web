{"version":3,"sources":["../src/local/garbage_collector.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG","file":"garbage_collector.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\n\nimport { GarbageSource } from './garbage_source';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/**\n * Tracks different kinds of references to a document, for all the different\n * ways the client needs to retain a document.\n *\n * Usually the the local store this means tracking of three different types of\n * references to a document:\n *  - RemoteTarget reference identified by a target ID.\n *  - LocalView reference identified also by a target ID.\n *  - Local mutation reference identified by a batch ID.\n *\n * The idea is that we want to keep a document around at least as long as any\n * remote target or local (latency compensated) view is referencing it, or\n * there's an outstanding local mutation to that document.\n */\nexport interface GarbageCollector {\n  /**\n   * A property that describes whether or not the collector wants to eagerly\n   * collect keys.\n   *\n   * TODO(b/33384523) Delegate deleting released queries to the GC. This flag\n   * is a temporary workaround for dealing with a persistent query cache.\n   * The collector really should have an API for releasing queries that does\n   * the right thing for its policy.\n   */\n  readonly isEager: boolean;\n\n  /** Adds a garbage source to the collector. */\n  addGarbageSource(garbageSource: GarbageSource): void;\n\n  /** Removes a garbage source from the collector. */\n  removeGarbageSource(garbageSource: GarbageSource): void;\n\n  /**\n   * Notifies the garbage collector that a document with the given key may have\n   * become garbage.\n   *\n   * This is useful in both when a document has definitely been released (for\n   * example when removed from a garbage source) but also when a document has\n   * been updated. Documents should be marked in this way because the client\n   * accepts updates for the documents even after the document no longer\n   * matches any active targets. This behavior allows the client to avoid\n   * re-showing an old document in the next latency-compensated view.\n   */\n  addPotentialGarbageKey(key: DocumentKey): void;\n\n  /**\n   * Returns the contents of the garbage bin and clears it.\n   *\n   * @param transaction The persistence transaction used to collect garbage. Can\n   * be null if all garbage sources are non-persistent (and therefore ignore the\n   * transaction completely).\n   */\n  collectGarbage(\n    transaction: PersistenceTransaction | null\n  ): PersistencePromise<DocumentKeySet>;\n}\n"]}