{"version":3,"sources":["../src/local/persistence_promise.ts"],"names":[],"mappings":"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","file":"persistence_promise.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fail } from '../util/assert';\n\nexport type FulfilledHandler<T, R> =\n  | ((result: T) => R | PersistencePromise<R>)\n  | null;\nexport type RejectedHandler<R> =\n  | ((reason: any) => R | PersistencePromise<R>)\n  | null;\nexport type Resolver<T> = (value?: T) => void;\nexport type Rejector = (error: any) => void;\n\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nexport class PersistencePromise<T> {\n  // NOTE: next/catchCallback will always point to our own wrapper functions,\n  // not the user's raw next() or catch() callbacks.\n  private nextCallback: FulfilledHandler<T, any> = null;\n  private catchCallback: RejectedHandler<any> = null;\n\n  // When the operation resolves, we'll set result or error and mark isDone.\n  private result: T | undefined = undefined;\n  private error: any = null;\n  private isDone = false;\n\n  // Set to true when .then() or .catch() are called and prevents additional\n  // chaining.\n  private callbackAttached = false;\n\n  constructor(callback: (resolve: Resolver<T>, reject: Rejector) => void) {\n    callback(\n      value => {\n        this.isDone = true;\n        this.result = value;\n        if (this.nextCallback) {\n          // value should be defined unless T is Void, but we can't express\n          // that in the type system.\n          this.nextCallback(value!);\n        }\n      },\n      error => {\n        this.isDone = true;\n        this.error = error;\n        if (this.catchCallback) {\n          this.catchCallback(error);\n        }\n      }\n    );\n  }\n\n  catch<R>(\n    fn: (error: any) => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    return this.next(undefined, fn);\n  }\n\n  next<R>(\n    nextFn?: FulfilledHandler<T, R>,\n    catchFn?: RejectedHandler<R>\n  ): PersistencePromise<R> {\n    if (this.callbackAttached) {\n      fail('Called next() or catch() twice for PersistencePromise');\n    }\n    this.callbackAttached = true;\n    if (this.isDone) {\n      if (!this.error) {\n        return this.wrapSuccess(nextFn, this.result!);\n      } else {\n        return this.wrapFailure(catchFn, this.error);\n      }\n    } else {\n      return new PersistencePromise<R>((resolve, reject) => {\n        this.nextCallback = (value: T) => {\n          this.wrapSuccess(nextFn, value).next(resolve, reject);\n        };\n        this.catchCallback = (error: any) => {\n          this.wrapFailure(catchFn, error).next(resolve, reject);\n        };\n      });\n    }\n  }\n\n  toPromise(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.next(resolve, reject);\n    });\n  }\n\n  private wrapUserFunction<R>(\n    fn: () => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    try {\n      const result = fn();\n      if (result instanceof PersistencePromise) {\n        return result;\n      } else {\n        return PersistencePromise.resolve(result);\n      }\n    } catch (e) {\n      return PersistencePromise.reject<R>(e);\n    }\n  }\n\n  private wrapSuccess<R>(\n    nextFn: FulfilledHandler<T, R> | undefined,\n    value: T\n  ): PersistencePromise<R> {\n    if (nextFn) {\n      return this.wrapUserFunction(() => nextFn(value));\n    } else {\n      // If there's no nextFn, then R must be the same as T but we\n      // can't express that in the type system.\n      return PersistencePromise.resolve<R>(value as any);\n    }\n  }\n\n  private wrapFailure<R>(\n    catchFn: RejectedHandler<R> | undefined,\n    error: any\n  ): PersistencePromise<R> {\n    if (catchFn) {\n      return this.wrapUserFunction(() => catchFn(error));\n    } else {\n      return PersistencePromise.reject<R>(error);\n    }\n  }\n\n  static resolve(): PersistencePromise<void>;\n  static resolve<R>(result: R): PersistencePromise<R>;\n  static resolve<R>(result?: R): PersistencePromise<R | void> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      resolve(result);\n    });\n  }\n\n  static reject<R>(error: any): PersistencePromise<R> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  static waitFor(\n    all: Array<PersistencePromise<any>>\n  ): PersistencePromise<void> {\n    return all.reduce((promise, nextPromise, idx) => {\n      return promise.next(() => {\n        return nextPromise;\n      });\n    }, PersistencePromise.resolve());\n  }\n\n  static map<R>(all: Array<PersistencePromise<R>>): PersistencePromise<R[]> {\n    const results: R[] = [];\n    let first = true;\n    // initial is ignored, so we can cheat on the type.\n    const initial = PersistencePromise.resolve<R>(null as any);\n    return all\n      .reduce((promise, nextPromise) => {\n        return promise.next(result => {\n          if (!first) {\n            results.push(result);\n          }\n          first = false;\n          return nextPromise;\n        });\n      }, initial)\n      .next(result => {\n        results.push(result);\n        return results;\n      });\n  }\n}\n"]}