{"version":3,"sources":["../src/local/memory_persistence.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAGH,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AAEpC,OAAO,EAAE,mBAAmB,EAAE,MAAM,yBAAyB,CAAC;AAC9D,OAAO,EAAE,gBAAgB,EAAE,MAAM,sBAAsB,CAAC;AACxD,OAAO,EAAE,yBAAyB,EAAE,MAAM,gCAAgC,CAAC;AAO3E,IAAM,OAAO,GAAG,mBAAmB,CAAC;AAEpC;;;GAGG;AACH;IAAA;QACE;;;;;;WAMG;QACK,mBAAc,GAAsC,EAAE,CAAC;QACvD,wBAAmB,GAAG,IAAI,yBAAyB,EAAE,CAAC;QACtD,eAAU,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAEpC,YAAO,GAAG,KAAK,CAAC;IAwC1B,CAAC;IAtCC,iCAAK,GAAL;QACE,MAAM,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,mCAAmC,CAAC,CAAC;QAC3D,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,uCAAuC;QACvC,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,oCAAQ,GAAR;QACE,oDAAoD;QACpD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,2CAA2C,CAAC,CAAC;QAClE,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,4CAAgB,GAAhB,UAAiB,IAAU;QACzB,IAAI,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QAC9C,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,KAAK,GAAG,IAAI,mBAAmB,EAAE,CAAC;YAClC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC;QAC5C,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAED,yCAAa,GAAb;QACE,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED,kDAAsB,GAAtB;QACE,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC;IAClC,CAAC;IAED,0CAAc,GAAd,UACE,MAAc,EACd,SAAyE;QAEzE,KAAK,CAAC,OAAO,EAAE,uBAAuB,EAAE,MAAM,CAAC,CAAC;QAChD,MAAM,CAAC,SAAS,CAAC,IAAI,4BAA4B,EAAE,CAAC,CAAC,SAAS,EAAE,CAAC;IACnE,CAAC;IACH,wBAAC;AAAD,CApDA,AAoDC,IAAA;;AAED,8EAA8E;AAC9E;IAAA;IAAsE,CAAC;IAAD,mCAAC;AAAD,CAAtE,AAAuE,IAAA","file":"memory_persistence.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\n\nimport { MemoryMutationQueue } from './memory_mutation_queue';\nimport { MemoryQueryCache } from './memory_query_cache';\nimport { MemoryRemoteDocumentCache } from './memory_remote_document_cache';\nimport { MutationQueue } from './mutation_queue';\nimport { Persistence, PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\nconst LOG_TAG = 'MemoryPersistence';\n\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nexport class MemoryPersistence implements Persistence {\n  /**\n   * Note that these are retained here to make it easier to write tests\n   * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n   * can create a new LocalStore wrapping this Persistence instance and this\n   * will make the in-memory persistence layer behave as if it were actually\n   * persisting values.\n   */\n  private mutationQueues: { [user: string]: MutationQueue } = {};\n  private remoteDocumentCache = new MemoryRemoteDocumentCache();\n  private queryCache = new MemoryQueryCache();\n\n  private started = false;\n\n  start(): Promise<void> {\n    assert(!this.started, 'MemoryPersistence double-started!');\n    this.started = true;\n    // No durable state to read on startup.\n    return Promise.resolve();\n  }\n\n  shutdown(): Promise<void> {\n    // No durable state to ensure is closed on shutdown.\n    assert(this.started, 'MemoryPersistence shutdown without start!');\n    this.started = false;\n    return Promise.resolve();\n  }\n\n  getMutationQueue(user: User): MutationQueue {\n    let queue = this.mutationQueues[user.toKey()];\n    if (!queue) {\n      queue = new MemoryMutationQueue();\n      this.mutationQueues[user.toKey()] = queue;\n    }\n    return queue;\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache;\n  }\n\n  getRemoteDocumentCache(): RemoteDocumentCache {\n    return this.remoteDocumentCache;\n  }\n\n  runTransaction<T>(\n    action: string,\n    operation: (transaction: PersistenceTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    debug(LOG_TAG, 'Starting transaction:', action);\n    return operation(new MemoryPersistenceTransaction()).toPromise();\n  }\n}\n\n/** Dummy class since memory persistence doesn't actually use transactions. */\nclass MemoryPersistenceTransaction implements PersistenceTransaction {}\n"]}