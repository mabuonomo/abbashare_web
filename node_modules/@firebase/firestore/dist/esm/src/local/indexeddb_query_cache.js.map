{"version":3,"sources":["../src/local/indexeddb_query_cache.ts"],"names":[],"mappings":"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","file":"indexeddb_query_cache.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { TargetId } from '../core/types';\nimport { DocumentKeySet, documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\n\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { GarbageCollector } from './garbage_collector';\nimport {\n  DbQuery,\n  DbTarget,\n  DbTargetDocument,\n  DbTargetDocumentKey,\n  DbTargetGlobal,\n  DbTargetGlobalKey,\n  DbTargetKey,\n  DbTimestamp\n} from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData } from './query_data';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\nexport class IndexedDbQueryCache implements QueryCache {\n  constructor(private serializer: LocalSerializer) {}\n\n  /**\n   * The last received snapshot version. We store this seperately from the\n   * metadata to avoid the extra conversion to/from DbTimestamp.\n   */\n  private lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n\n  /**\n   * A cached copy of the metadata for the query cache.\n   */\n  private metadata = new DbTargetGlobal(\n    /*highestTargetId=*/ 0,\n    /*lastListenSequenceNumber=*/ 0,\n    SnapshotVersion.MIN.toTimestamp()\n  );\n\n  /** The garbage collector to notify about potential garbage keys. */\n  private garbageCollector: GarbageCollector | null = null;\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    return globalTargetStore(transaction)\n      .get(DbTargetGlobal.key)\n      .next(metadata => {\n        if (metadata !== null) {\n          this.metadata = metadata;\n          const lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n          this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(\n            new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos)\n          );\n        }\n        return PersistencePromise.resolve();\n      });\n  }\n\n  getHighestTargetId(): TargetId {\n    return this.metadata.highestTargetId;\n  }\n\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.lastRemoteSnapshotVersion;\n  }\n\n  setLastRemoteSnapshotVersion(\n    transaction: PersistenceTransaction,\n    snapshotVersion: SnapshotVersion\n  ): PersistencePromise<void> {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n    return globalTargetStore(transaction).put(\n      DbTargetGlobal.key,\n      this.metadata\n    );\n  }\n\n  addQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    const targetId = queryData.targetId;\n    const addedQueryPromise = targetsStore(transaction).put(\n      this.serializer.toDbTarget(queryData)\n    );\n    if (targetId > this.metadata.highestTargetId) {\n      this.metadata.highestTargetId = targetId;\n      return addedQueryPromise.next(() =>\n        globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata)\n      );\n    } else {\n      return addedQueryPromise;\n    }\n  }\n\n  removeQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    return this.removeMatchingKeysForTargetId(\n      transaction,\n      queryData.targetId\n    ).next(() => {\n      targetsStore(transaction).delete(queryData.targetId);\n    });\n  }\n\n  getQueryData(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<QueryData | null> {\n    // Iterating by the canonicalId may yield more than one result because\n    // canonicalId values are not required to be unique per target. This query\n    // depends on the queryTargets index to be efficent.\n    const canonicalId = query.canonicalId();\n    const range = IDBKeyRange.bound(\n      [canonicalId, Number.NEGATIVE_INFINITY],\n      [canonicalId, Number.POSITIVE_INFINITY]\n    );\n    let result: QueryData | null = null;\n    return targetsStore(transaction)\n      .iterate(\n        { range, index: DbTarget.queryTargetsIndexName },\n        (key, value, control) => {\n          const found = this.serializer.fromDbTarget(value);\n          // After finding a potential match, check that the query is\n          // actually equal to the requested query.\n          if (query.equals(found.query)) {\n            result = found;\n            control.done();\n          }\n        }\n      )\n      .next(() => result);\n  }\n\n  addMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // Indexeddb.\n    const promises: Array<PersistencePromise<void>> = [];\n    const store = documentTargetStore(txn);\n    keys.forEach(key => {\n      const path = EncodedResourcePath.encode(key.path);\n      promises.push(store.put(new DbTargetDocument(targetId, path)));\n    });\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // IndexedDb.\n    const promises: Array<PersistencePromise<void>> = [];\n    const store = documentTargetStore(txn);\n    keys.forEach(key => {\n      const path = EncodedResourcePath.encode(key.path);\n      promises.push(store.delete([targetId, path]));\n      if (this.garbageCollector !== null) {\n        this.garbageCollector.addPotentialGarbageKey(key);\n      }\n    });\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    const store = documentTargetStore(txn);\n    const range = IDBKeyRange.bound(\n      [targetId],\n      [targetId + 1],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    return this.notifyGCForRemovedKeys(txn, range).next(() =>\n      store.delete(range)\n    );\n  }\n\n  private notifyGCForRemovedKeys(\n    txn: PersistenceTransaction,\n    range: IDBKeyRange\n  ): PersistencePromise<void> {\n    const store = documentTargetStore(txn);\n    if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n      // In order to generate garbage events properly, we need to read these\n      // keys before deleting.\n      return store.iterate({ range, keysOnly: true }, (key, _, control) => {\n        const path = EncodedResourcePath.decode(key[1]);\n        const docKey = new DocumentKey(path);\n        // Paranoid assertion in case the the collector is set to null\n        // during the iteration.\n        assert(\n          this.garbageCollector !== null,\n          'GarbageCollector for query cache set to null during key removal.'\n        );\n        this.garbageCollector!.addPotentialGarbageKey(docKey);\n      });\n    } else {\n      return PersistencePromise.resolve();\n    }\n  }\n\n  getMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<DocumentKeySet> {\n    const promises: Array<PersistencePromise<void>> = [];\n    const range = IDBKeyRange.bound(\n      [targetId],\n      [targetId + 1],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    const store = documentTargetStore(txn);\n    let result = documentKeySet();\n\n    return store\n      .iterate({ range, keysOnly: true }, (key, _, control) => {\n        const path = EncodedResourcePath.decode(key[1]);\n        const docKey = new DocumentKey(path);\n        result = result.add(docKey);\n      })\n      .next(() => result);\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.garbageCollector = gc;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    assert(\n      txn !== null,\n      'Persistence Transaction cannot be null for query cache containsKey'\n    );\n    const path = EncodedResourcePath.encode(key.path);\n    const range = IDBKeyRange.bound(\n      [path],\n      [immediateSuccessor(path)],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    let count = 0;\n    return documentTargetStore(txn!)\n      .iterate(\n        {\n          index: DbTargetDocument.documentTargetsIndex,\n          keysOnly: true,\n          range\n        },\n        (key, _, control) => {\n          count++;\n          control.done();\n        }\n      )\n      .next(() => count > 0);\n  }\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetKey, DbTarget> {\n  return getStore<DbTargetKey, DbTarget>(txn, DbTarget.store);\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetGlobalKey, DbTargetGlobal> {\n  return getStore<DbTargetGlobalKey, DbTargetGlobal>(txn, DbTargetGlobal.store);\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetDocumentKey, DbTargetDocument> {\n  return getStore<DbTargetDocumentKey, DbTargetDocument>(\n    txn,\n    DbTargetDocument.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore<KeyType extends IDBValidKey, ValueType>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<KeyType, ValueType> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<KeyType, ValueType>(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n"]}