{"version":3,"sources":["../src/local/encoded_resource_path.ts"],"names":[],"mappings":"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","file":"encoded_resource_path.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\n\n/**\n * Helpers for dealing with resource paths stored in IndexedDB.\n *\n * Resource paths in their canonical string form do not sort as the server\n * sorts them. Specifically the server splits paths into segments first and then\n * sorts, putting end-of-segment before any character. In a UTF-8 string\n * encoding the slash ('/') that denotes the end-of-segment naturally comes\n * after other characters so the intent here is to encode the path delimiters in\n * such a way that the resulting strings sort naturally.\n *\n * Resource paths are also used for prefix scans so it's important to\n * distinguish whole segments from any longer segments of which they might be a\n * prefix. For example, it's important to make it possible to scan documents in\n * a collection \"foo\" without encountering documents in a collection \"foobar\".\n *\n * Separate from the concerns about resource path ordering and separation,\n * On Android, SQLite imposes additional restrictions since it does not handle\n * keys with embedded NUL bytes particularly well. Rather than change the\n * implementation we keep the encoding identical to keep the ports similar.\n *\n * Taken together this means resource paths when encoded for storage in\n * IndexedDB have the following characteristics:\n *\n *   * Segment separators (\"/\") sort before everything else.\n *   * All paths have a trailing separator.\n *   * NUL bytes do not exist in the output, since IndexedDB doesn't treat them\n * well.\n *\n * Therefore resource paths are encoded into string form using the following\n * rules:\n *\n *   * '\\x01' is used as an escape character.\n *   * Path separators are encoded as \"\\x01\\x01\"\n *   * NUL bytes are encoded as \"\\x01\\x10\"\n *   * '\\x01' is encoded as \"\\x01\\x11\"\n *\n * This encoding leaves some room between path separators and the NUL byte\n * just in case we decide to support integer document ids after all.\n *\n * Note that characters treated specially by the backend ('.', '/', and '~')\n * are not treated specially here. This class assumes that any unescaping of\n * resource path strings into actual ResourcePath objects will handle these\n * characters there.\n */\nexport type EncodedResourcePath = string;\n\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nexport function encode(path: ResourcePath): EncodedResourcePath {\n  let result = '';\n  for (let i = 0; i < path.length; i++) {\n    if (result.length > 0) {\n      result = encodeSeparator(result);\n    }\n    result = encodeSegment(path.get(i), result);\n  }\n  return encodeSeparator(result);\n}\n\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment: string, resultBuf: string) {\n  let result = resultBuf;\n  const length = segment.length;\n  for (let i = 0; i < length; i++) {\n    const c = segment.charAt(i);\n    switch (c) {\n      case '\\0':\n        result += escapeChar + encodedNul;\n        break;\n      case escapeChar:\n        result += escapeChar + encodedEscape;\n        break;\n      default:\n        result += c;\n    }\n  }\n  return result;\n}\n\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result: string): string {\n  return result + escapeChar + encodedSeparatorChar;\n}\n\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nexport function decode(path: EncodedResourcePath): ResourcePath {\n  // Event the empty path must encode as a path of at least length 2. A path\n  // with exactly 2 must be the empty path.\n  const length = path.length;\n  assert(length >= 2, 'Invalid path ' + path);\n  if (length === 2) {\n    assert(\n      path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar,\n      'Non-empty path ' + path + ' had length 2'\n    );\n    return ResourcePath.EMPTY_PATH;\n  }\n\n  // Escape characters cannot exist past the second-to-last position in the\n  // source value.\n  const lastReasonableEscapeIndex = length - 2;\n\n  const segments: string[] = [];\n  let segmentBuilder = '';\n\n  for (let start = 0; start < length; ) {\n    // The last two characters of a valid encoded path must be a separator, so\n    // there must be an end to this segment.\n    const end = path.indexOf(escapeChar, start);\n    if (end < 0 || end > lastReasonableEscapeIndex) {\n      fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    const next = path.charAt(end + 1);\n    switch (next) {\n      case encodedSeparatorChar:\n        const currentPiece = path.substring(start, end);\n        let segment;\n        if (segmentBuilder.length === 0) {\n          // Avoid copying for the common case of a segment that excludes \\0\n          // and \\001\n          segment = currentPiece;\n        } else {\n          segmentBuilder += currentPiece;\n          segment = segmentBuilder;\n          segmentBuilder = '';\n        }\n        segments.push(segment);\n        break;\n      case encodedNul:\n        segmentBuilder += path.substring(start, end);\n        segmentBuilder += '\\0';\n        break;\n      case encodedEscape:\n        // The escape character can be used in the output to encode itself.\n        segmentBuilder += path.substring(start, end + 1);\n        break;\n      default:\n        fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    start = end + 2;\n  }\n\n  return new ResourcePath(segments);\n}\n\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nexport function prefixSuccessor(path: EncodedResourcePath) {\n  const c = path.charCodeAt(path.length - 1);\n  // TODO(mcg): this really should be a general thing, but not worth it right\n  // now\n  assert(c === 1, 'successor may only operate on paths generated by encode');\n  return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n"]}