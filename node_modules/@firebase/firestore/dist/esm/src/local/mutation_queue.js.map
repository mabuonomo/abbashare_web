{"version":3,"sources":["../src/local/mutation_queue.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG","file":"mutation_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { MutationBatch } from '../model/mutation_batch';\n\nimport { GarbageSource } from './garbage_source';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/** A queue of mutations to apply to the remote store. */\nexport interface MutationQueue extends GarbageSource {\n  /**\n   * Starts the mutation queue, performing any initial reads that might be\n   * required to establish invariants, etc.\n   *\n   * After starting, the mutation queue must guarantee that the\n   * highestAcknowledgedBatchId is less than nextBatchId. This prevents the\n   * local store from creating new batches that the mutation queue would\n   * consider erroneously acknowledged.\n   */\n  start(transaction: PersistenceTransaction): PersistencePromise<void>;\n\n  /** Returns true if this queue contains no mutation batches. */\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean>;\n\n  /**\n   * Returns the next BatchId that will be assigned to a new mutation batch.\n   *\n   * Callers generally don't care about this value except to test that the\n   * mutation queue is properly maintaining the invariant that\n   * highestAcknowledgedBatchId is less than nextBatchId.\n   */\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId>;\n\n  /**\n   * Returns the highest batchId that has been acknowledged. If no batches have\n   * been acknowledged or if there are no batches in the queue this can return\n   * BATCHID_UNKNOWN.\n   */\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId>;\n\n  /**\n   * Acknowledges the given batch.\n   */\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void>;\n\n  /** Returns the current stream token for this mutation queue. */\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString>;\n\n  /** Sets the stream token for this mutation queue. */\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void>;\n\n  /** Creates a new mutation batch and adds it to this mutation queue. */\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch>;\n\n  /** Loads the mutation batch with the given batchId. */\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null>;\n\n  /**\n   * Gets the first unacknowledged mutation batch after the passed in batchId\n   * in the mutation queue or null if empty.\n   *\n   * @param batchId The batch to search after, or BATCHID_UNKNOWN for the first\n   * mutation in the queue.\n   *\n   * @return the next mutation or null if there wasn't one.\n   */\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null>;\n\n  /** Gets all mutation batches in the mutation queue. */\n  // TODO(mikelehen): PERF: Current consumer only needs mutated keys; if we can\n  // provide that cheaply, we should replace this.\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]>;\n\n  /**\n   * Finds all mutations with a batchId less than or equal to the given batchId.\n   *\n   * Generally the caller should be asking for the next unacknowledged batchId\n   * and the number of acknowledged batches should be very small when things are\n   * functioning well.\n   *\n   * @param batchId The batch to search through.\n   *\n   * @return an Array containing all batches with matching batchIds.\n   */\n  // TODO(mcg): This should really return an enumerator and the caller should be\n  // adjusted to only loop through these once.\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]>;\n\n  /**\n   * Finds all mutation batches that could possibly affect the given\n   * document key. Not all mutations in a batch will necessarily affect the\n   * document key, so when looping through the batch you'll need to check that\n   * the mutation itself matches the key.\n   *\n   * Note that because of this requirement implementations are free to return\n   * mutation batches that don't contain the document key at all if it's\n   * convenient.\n   */\n  // TODO(mcg): This should really return an enumerator\n  // also for b/32992024, all backing stores should really index by document key\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]>;\n\n  /**\n   * Finds all mutation batches that could affect the results for the given\n   * query. Not all mutations in a batch will necessarily affect the query, so\n   * when looping through the batch you'll need to check that the mutation\n   * itself matches the query.\n   *\n   * Note that because of this requirement implementations are free to return\n   * mutation batches that don't match the query at all if it's convenient.\n   *\n   * NOTE: A PatchMutation does not need to include all fields in the query\n   * filter criteria in order to be a match (but any fields it does contain do\n   * need to match).\n   */\n  // TODO(mikelehen): This should perhaps return an enumerator, though I'm not\n  // sure we can avoid loading them all in memory.\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]>;\n\n  /**\n   * Removes the given mutation batches from the queue. This is useful in two\n   * circumstances:\n   *\n   * + Removing applied mutations from the head of the queue\n   * + Removing rejected mutations from anywhere in the queue\n   *\n   * In both cases, the array of mutations to remove must be a contiguous range\n   * of batchIds. This is most easily accomplished by loading mutations with\n   * getAllMutationBatchesThroughBatchId()\n   */\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void>;\n\n  /**\n   * Performs a consistency check, examining the mutation queue for any\n   * leaks, if possible.\n   */\n  performConsistencyCheck(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<void>;\n}\n"]}