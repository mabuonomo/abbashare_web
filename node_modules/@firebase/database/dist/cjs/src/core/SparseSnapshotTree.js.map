{"version":3,"sources":["../src/core/SparseSnapshotTree.ts"],"names":[],"mappings":"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","file":"SparseSnapshotTree.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { CountedSet } from './util/CountedSet';\nimport { Node } from './snap/Node';\n\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nexport class SparseSnapshotTree {\n  /**\n   * @private\n   * @type {Node}\n   */\n  private value_: Node | null = null;\n\n  /**\n   * @private\n   * @type {CountedSet}\n   */\n  private children_: CountedSet<string, SparseSnapshotTree> | null = null;\n\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n  find(path: Path): Node | null {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      const childKey = path.getFront();\n      path = path.popFront();\n      if (this.children_.contains(childKey)) {\n        const childTree = this.children_.get(childKey) as SparseSnapshotTree;\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n  remember(path: Path, data: Node) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet<string, SparseSnapshotTree>();\n      }\n\n      const childKey = path.getFront();\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      const child = this.children_.get(childKey) as SparseSnapshotTree;\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  }\n\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n  forget(path: Path): boolean {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          const value = this.value_;\n          this.value_ = null;\n\n          const self = this;\n          value.forEachChild(PRIORITY_INDEX, function(key, tree) {\n            self.remember(new Path(key), tree);\n          });\n\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        const childKey = path.getFront();\n        path = path.popFront();\n        if (this.children_.contains(childKey)) {\n          const safeToRemove = (this.children_.get(\n            childKey\n          ) as SparseSnapshotTree).forget(path);\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n  forEachTree(prefixPath: Path, func: (a: Path, b: Node) => any) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild((key, tree) => {\n        const path = new Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  }\n\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n  forEachChild(func: (a: string, b: SparseSnapshotTree) => void) {\n    if (this.children_ !== null) {\n      this.children_.each((key, tree) => {\n        func(key, tree);\n      });\n    }\n  }\n}\n"]}