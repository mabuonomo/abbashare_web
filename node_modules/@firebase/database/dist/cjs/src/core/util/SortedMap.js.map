{"version":3,"sources":["../src/core/util/SortedMap.ts"],"names":[],"mappings":"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","file":"SortedMap.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\n// TODO: There are some improvements I'd like to make to improve memory / perf:\n//  * Create two prototypes, LLRedNode and LLBlackNode, instead of storing a\n//    color property in every node.\n// TODO: It would also be good (and possibly necessary) to create a base\n// interface for LLRBNode and LLRBEmptyNode.\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\n/**\n * An iterator over an LLRBNode.\n */\nexport class SortedMapIterator<K, V, T> {\n  /** @private\n   * @type {Array.<!LLRBNode>}\n   */\n  private nodeStack_: (LLRBNode<K, V> | LLRBEmptyNode<K, V>)[] = [];\n\n  /**\n   * @template K, V, T\n   * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\n   * @param {?K} startKey\n   * @param {function(K, K): number} comparator\n   * @param {boolean} isReverse_ Whether or not to iterate in reverse\n   * @param {(function(K, V):T)=} resultGenerator_\n   */\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    private isReverse_: boolean,\n    private resultGenerator_: ((k: K, v: V) => T) | null = null\n  ) {\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      node = node as LLRBNode<K, V>;\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse_) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse_) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n        this.nodeStack_.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move to the next one\n        this.nodeStack_.push(node);\n        if (this.isReverse_) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    let node = this.nodeStack_.pop();\n    let result: T;\n    if (this.resultGenerator_)\n      result = this.resultGenerator_(node.key, node.value);\n    else result = { key: node.key, value: node.value } as any;\n\n    if (this.isReverse_) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack_.length > 0;\n  }\n\n  peek(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    const node = this.nodeStack_[this.nodeStack_.length - 1];\n    if (this.resultGenerator_) {\n      return this.resultGenerator_(node.key, node.value);\n    } else {\n      return { key: node.key, value: node.value } as any;\n    }\n  }\n}\n\n/**\n * Represents a node in a Left-leaning Red-Black tree.\n */\nexport class LLRBNode<K, V> {\n  color: boolean;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  /**\n   * @template K, V\n   * @param {!K} key Key associated with this node.\n   * @param {!V} value Value associated with this node.\n   * @param {?boolean} color Whether this node is red.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\n   */\n  constructor(\n    public key: K,\n    public value: V,\n    color: boolean | null,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left =\n      left != null ? left : SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n    this.right =\n      right != null ? right : SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n  }\n\n  static RED = true;\n  static BLACK = false;\n\n  /**\n   * Returns a copy of the current node, optionally replacing pieces of it.\n   *\n   * @param {?K} key New key for the node, or null.\n   * @param {?V} value New value for the node, or null.\n   * @param {?boolean} color New color for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\n   * @return {!LLRBNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBNode<K, V> {\n    return new LLRBNode(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return this.left.count() + 1 + this.right.count();\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   *   node.  If it returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return (\n      this.left.inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      this.right.inorderTraversal(action)\n    );\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {*} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return (\n      this.right.reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      this.left.reverseTraversal(action)\n    );\n  }\n\n  /**\n   * @return {!Object} The minimum node in the tree.\n   * @private\n   */\n  private min_(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min_();\n    }\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  minKey(): K {\n    return this.min_().key;\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  maxKey(): K {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  /**\n   *\n   * @param {!Object} key Key to insert.\n   * @param {!Object} value Value to insert.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with the key/value added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let cmp, n;\n    n = this;\n    cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\n   */\n  private removeMin_(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed_() && !n.left.left.isRed_()) n = n.moveRedLeft_();\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin_(), null);\n    return n.fixUp_();\n  }\n\n  /**\n   * @param {!Object} key The key of the item to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\n   */\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let n, smallest;\n    n = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n        n = n.moveRedLeft_();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed_()) n = n.rotateRight_();\n      if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n        n = n.moveRedRight_();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min_();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin_()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this is a RED node.\n   */\n  isRed_(): boolean {\n    return this.color;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree after performing any needed rotations.\n   */\n  private fixUp_(): LLRBNode<K, V> {\n    let n = this as any;\n    if (n.right.isRed_() && !n.left.isRed_()) n = n.rotateLeft_();\n    if (n.left.isRed_() && n.left.left.isRed_()) n = n.rotateRight_();\n    if (n.left.isRed_() && n.right.isRed_()) n = n.colorFlip_();\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedLeft.\n   */\n  private moveRedLeft_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.right.left.isRed_()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight_()\n      );\n      n = n.rotateLeft_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedRight.\n   */\n  private moveRedRight_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.left.left.isRed_()) {\n      n = n.rotateRight_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateLeft.\n   */\n  private rotateLeft_(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateRight.\n   */\n  private rotateRight_(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after colorFlip.\n   */\n  private colorFlip_(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  /**\n   * For testing.\n   *\n   * @private\n   * @return {boolean} True if all is well.\n   */\n  private checkMaxDepth_(): boolean {\n    const blackDepth = this.check_();\n    return Math.pow(2.0, blackDepth) <= this.count() + 1;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    let blackDepth;\n    if (this.isRed_() && this.left.isRed_()) {\n      throw new Error(\n        'Red node has red child(' + this.key + ',' + this.value + ')'\n      );\n    }\n    if (this.right.isRed_()) {\n      throw new Error(\n        'Right child of (' + this.key + ',' + this.value + ') is red'\n      );\n    }\n    blackDepth = this.left.check_();\n    if (blackDepth !== this.right.check_()) {\n      throw new Error('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed_() ? 0 : 1);\n    }\n  }\n}\n\n/**\n * Represents an empty node (a leaf node in the Red-Black Tree).\n */\nexport class LLRBEmptyNode<K, V> {\n  key: K;\n  value: V;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  color: boolean;\n\n  /**\n   * Returns a copy of the current node.\n   *\n   * @return {!LLRBEmptyNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key/value added.\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with item added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode(key, value, null);\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBEmptyNode} New tree, with item removed.\n   */\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return true;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return false;\n  }\n\n  /**\n   * @return {null}\n   */\n  minKey(): null {\n    return null;\n  }\n\n  /**\n   * @return {null}\n   */\n  maxKey(): null {\n    return null;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    return 0;\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this node is red.\n   */\n  isRed_() {\n    return false;\n  }\n}\n\n/**\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\n * tree.\n */\nexport class SortedMap<K, V> {\n  /**\n   * Always use the same empty node, to reduce memory.\n   * @const\n   */\n  static EMPTY_NODE = new LLRBEmptyNode();\n\n  /**\n   * @template K, V\n   * @param {function(K, K):number} comparator_ Key comparator.\n   * @param {LLRBNode=} root_ (Optional) Root node for the map.\n   */\n  constructor(\n    private comparator_: Comparator<K>,\n    private root_:\n      | LLRBNode<K, V>\n      | LLRBEmptyNode<K, V> = SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>\n  ) {}\n\n  /**\n   * Returns a copy of the map, with the specified key/value added or replaced.\n   * (TODO: We should perhaps rename this method to 'put')\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @return {!SortedMap.<K, V>} New map, with item added.\n   */\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .insert(key, value, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns a copy of the map, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @return {!SortedMap.<K, V>} New map, with item removed.\n   */\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .remove(key, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns the value of the node with the given key, or null.\n   *\n   * @param {!K} key The key to look up.\n   * @return {?V} The value of the node with the given key, or null if the\n   * key doesn't exist.\n   */\n  get(key: K): V | null {\n    let cmp;\n    let node = this.root_;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the key of the item *before* the specified key, or null if key is the first item.\n   * @param {K} key The key to find the predecessor of\n   * @return {?K} The predecessor key.\n   */\n  getPredecessorKey(key: K): K | null {\n    let cmp,\n      node = this.root_,\n      rightParent = null;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) node = node.right;\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw new Error(\n      'Attempted to find predecessor key for a nonexistent key.  What gives?'\n    );\n  }\n\n  /**\n   * @return {boolean} True if the map is empty.\n   */\n  isEmpty(): boolean {\n    return this.root_.isEmpty();\n  }\n\n  /**\n   * @return {number} The total number of nodes in the map.\n   */\n  count(): number {\n    return this.root_.count();\n  }\n\n  /**\n   * @return {?K} The minimum key in the map.\n   */\n  minKey(): K | null {\n    return this.root_.minKey();\n  }\n\n  /**\n   * @return {?K} The maximum key in the map.\n   */\n  maxKey(): K | null {\n    return this.root_.maxKey();\n  }\n\n  /**\n   * Traverses the map in key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return this.root_.inorderTraversal(action);\n  }\n\n  /**\n   * Traverses the map in reverse key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} True if the traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return this.root_.reverseTraversal(action);\n  }\n\n  /**\n   * Returns an iterator over the SortedMap.\n   * @template T\n   * @param {(function(K, V):T)=} resultGenerator\n   * @return {SortedMapIterator.<K, V, T>} The iterator.\n   */\n  getIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n\n  getReverseIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n}\n"]}