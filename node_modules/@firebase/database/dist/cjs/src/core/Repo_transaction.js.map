{"version":3,"sources":["../src/core/Repo_transaction.ts"],"names":[],"mappings":"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","file":"Repo_transaction.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Reference } from '../api/Reference';\nimport { DataSnapshot } from '../api/DataSnapshot';\nimport { Path } from './util/Path';\nimport { Tree } from './util/Tree';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\nimport { LUIDGenerator, warn, exceptionGuard } from './util/util';\nimport { resolveDeferredValueSnapshot } from './util/ServerValues';\nimport { isValidPriority, validateFirebaseData } from './util/validation';\nimport { contains, safeGet } from '@firebase/util';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Repo } from './Repo';\nimport { Event } from './view/Event';\n\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\nexport enum TransactionStatus {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  RUN,\n\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  SENT,\n\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  COMPLETED,\n\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  SENT_NEEDS_ABORT,\n\n  // Temporary state used to mark transactions that need to be aborted.\n  NEEDS_ABORT\n}\n\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n(Repo as any).MAX_TRANSACTION_RETRIES_ = 25;\n\n/**\n * @typedef {{\n *   path: !Path,\n *   update: function(*):*,\n *   onComplete: ?function(?Error, boolean, ?DataSnapshot),\n *   status: ?TransactionStatus,\n *   order: !number,\n *   applyLocally: boolean,\n *   retryCount: !number,\n *   unwatcher: function(),\n *   abortReason: ?string,\n *   currentWriteId: !number,\n *   currentInputSnapshot: ?Node,\n *   currentOutputSnapshotRaw: ?Node,\n *   currentOutputSnapshotResolved: ?Node\n * }}\n */\ntype Transaction = {\n  path: Path;\n  update: (a: any) => any;\n  onComplete: (a: Error | null, b: boolean, c: DataSnapshot | null) => void;\n  status: TransactionStatus;\n  order: number;\n  applyLocally: boolean;\n  retryCount: number;\n  unwatcher: () => void;\n  abortReason: string | null;\n  currentWriteId: number;\n  currentInputSnapshot: Node | null;\n  currentOutputSnapshotRaw: Node | null;\n  currentOutputSnapshotResolved: Node | null;\n};\n\n/**\n * Setup the transaction data structures\n * @private\n */\n(Repo.prototype as any).transactions_init_ = function() {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree<Transaction[]>();\n};\n\ndeclare module './Repo' {\n  interface Repo {\n    startTransaction(\n      path: Path,\n      transactionUpdate: (a: any) => void,\n      onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n      applyLocally: boolean\n    ): void;\n  }\n}\n\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo.prototype.startTransaction = function(\n  path: Path,\n  transactionUpdate: (a: any) => any,\n  onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n  applyLocally: boolean\n) {\n  this.log_('transaction on ' + path);\n\n  // Add a watch to make sure we get server updates.\n  const valueCallback = function() {};\n  const watchRef = new Reference(this, path);\n  watchRef.on('value', valueCallback);\n  const unwatcher = function() {\n    watchRef.off('value', valueCallback);\n  };\n\n  // Initialize transaction.\n  const transaction: Transaction = {\n    path,\n    update: transactionUpdate,\n    onComplete,\n\n    // One of TransactionStatus enums.\n    status: null,\n\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: LUIDGenerator(),\n\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n\n    // Function to call to clean up our .on() listener.\n    unwatcher,\n\n    // Stores why a transaction was aborted.\n    abortReason: null,\n\n    currentWriteId: null,\n\n    currentInputSnapshot: null,\n\n    currentOutputSnapshotRaw: null,\n\n    currentOutputSnapshotResolved: null\n  };\n\n  // Run transaction initially.\n  const currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  const newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      const snapshot = new DataSnapshot(\n        transaction.currentInputSnapshot,\n        new Reference(this, transaction.path),\n        PRIORITY_INDEX\n      );\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validateFirebaseData(\n      'transaction failed: Data returned ',\n      newVal,\n      transaction.path\n    );\n\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    const queueNode = this.transactionQueueTree_.subTree(path);\n    const nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n\n    queueNode.setValue(nodeQueue);\n\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    let priorityForNode;\n    if (\n      typeof newVal === 'object' &&\n      newVal !== null &&\n      contains(newVal, '.priority')\n    ) {\n      priorityForNode = safeGet(newVal, '.priority');\n      assert(\n        isValidPriority(priorityForNode),\n        'Invalid priority returned by transaction. ' +\n          'Priority must be a valid string, finite number, server value, or null.'\n      );\n    } else {\n      const currentNode =\n        this.serverSyncTree_.calcCompleteEventCache(path) ||\n        ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      transaction.currentWriteId,\n      transaction.applyLocally\n    );\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n    this.sendReadyTransactions_();\n  }\n};\n\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n(Repo.prototype as any).getLatestState_ = function(\n  path: Path,\n  excludeSets?: number[]\n): Node {\n  return (\n    this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n    ChildrenNode.EMPTY_NODE\n  );\n};\n\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n(Repo.prototype as any).sendReadyTransactions_ = function(\n  node: Tree<Transaction[]> = this.transactionQueueTree_\n) {\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    const queue = this.buildTransactionQueue_(node);\n    assert(queue.length > 0, 'Sending zero length transaction queue');\n\n    const allRun = queue.every(\n      (transaction: Transaction) => transaction.status === TransactionStatus.RUN\n    );\n\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(childNode => {\n      this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n(Repo.prototype as any).sendTransactionQueue_ = function(\n  path: Path,\n  queue: Array<Transaction>\n) {\n  // Mark transactions as sent and increment retry count!\n  const setsToIgnore = queue.map(function(txn) {\n    return txn.currentWriteId;\n  });\n  const latestState = this.getLatestState_(path, setsToIgnore);\n  let snapToSend = latestState;\n  const latestHash = latestState.hash();\n  for (let i = 0; i < queue.length; i++) {\n    const txn = queue[i];\n    assert(\n      txn.status === TransactionStatus.RUN,\n      'tryToSendTransactionQueue_: items in queue should all be run.'\n    );\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    const relativePath = Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(\n      relativePath /**@type {!Node} */,\n      txn.currentOutputSnapshotRaw\n    );\n  }\n\n  const dataToSend = snapToSend.val(true);\n  const pathToSend = path;\n\n  // Send the put.\n  this.server_.put(\n    pathToSend.toString(),\n    dataToSend,\n    (status: string) => {\n      this.log_('transaction put response', {\n        path: pathToSend.toString(),\n        status\n      });\n\n      let events: Event[] = [];\n      if (status === 'ok') {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        const callbacks = [];\n        for (let i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.COMPLETED;\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId)\n          );\n          if (queue[i].onComplete) {\n            // We never unset the output snapshot, and given that this transaction is complete, it should be set\n            const node = queue[i].currentOutputSnapshotResolved as Node;\n            const ref = new Reference(this, queue[i].path);\n            const snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\n            callbacks.push(\n              queue[i].onComplete.bind(null, null, true, snapshot)\n            );\n          }\n          queue[i].unwatcher();\n        }\n\n        // Now remove the completed transactions.\n        this.pruneCompletedTransactionsBelowNode_(\n          this.transactionQueueTree_.subTree(path)\n        );\n        // There may be pending transactions that we can now send.\n        this.sendReadyTransactions_();\n\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n        // Finally, trigger onComplete callbacks.\n        for (let i = 0; i < callbacks.length; i++) {\n          exceptionGuard(callbacks[i]);\n        }\n      } else {\n        // transactions are no longer sent.  Update their status appropriately.\n        if (status === 'datastale') {\n          for (let i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n              queue[i].status = TransactionStatus.NEEDS_ABORT;\n            else queue[i].status = TransactionStatus.RUN;\n          }\n        } else {\n          warn(\n            'transaction at ' + pathToSend.toString() + ' failed: ' + status\n          );\n          for (let i = 0; i < queue.length; i++) {\n            queue[i].status = TransactionStatus.NEEDS_ABORT;\n            queue[i].abortReason = status;\n          }\n        }\n\n        this.rerunTransactions_(path);\n      }\n    },\n    latestHash\n  );\n};\n\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n(Repo.prototype as any).rerunTransactions_ = function(changedPath: Path): Path {\n  const rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  const path = rootMostTransactionNode.path();\n\n  const queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n\n  return path;\n};\n\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n(Repo.prototype as any).rerunTransactionQueue_ = function(\n  queue: Array<Transaction>,\n  path: Path\n) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  const callbacks = [];\n  let events: Event[] = [];\n  // Ignore all of the sets we're going to re-run.\n  const txnsToRerun = queue.filter(function(q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  const setsToIgnore = txnsToRerun.map(function(q) {\n    return q.currentWriteId;\n  });\n  for (let i = 0; i < queue.length; i++) {\n    const transaction = queue[i];\n    const relativePath = Path.relativePath(path, transaction.path);\n    let abortTransaction = false,\n      abortReason;\n    assert(\n      relativePath !== null,\n      'rerunTransactionsUnderNode_: relativePath should not be null.'\n    );\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(\n        this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n      );\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= (Repo as any).MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n        );\n      } else {\n        // This code reruns a transaction\n        const currentNode = this.getLatestState_(\n          transaction.path,\n          setsToIgnore\n        );\n        transaction.currentInputSnapshot = currentNode;\n        const newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validateFirebaseData(\n            'transaction failed: Data returned ',\n            newData,\n            transaction.path\n          );\n          let newDataNode = nodeFromJSON(newData);\n          const hasExplicitPriority =\n            typeof newData === 'object' &&\n            newData != null &&\n            contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          const oldWriteId = transaction.currentWriteId;\n          const serverValues = this.generateServerValues();\n          const newNodeResolved = resolveDeferredValueSnapshot(\n            newDataNode,\n            serverValues\n          );\n\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(\n            this.serverSyncTree_.applyUserOverwrite(\n              transaction.path,\n              newNodeResolved,\n              transaction.currentWriteId,\n              transaction.applyLocally\n            )\n          );\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(oldWriteId, true)\n          );\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n          );\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function(unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          const ref = new Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          const lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          const snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error(abortReason), false, null)\n          );\n        }\n      }\n    }\n  }\n\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n\n  // Now fire callbacks, now that we're in a good, known state.\n  for (let i = 0; i < callbacks.length; i++) {\n    exceptionGuard(callbacks[i]);\n  }\n\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n(Repo.prototype as any).getAncestorTransactionNode_ = function(\n  path: Path\n): Tree<Transaction[]> {\n  let front;\n\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  let transactionNode = this.transactionQueueTree_;\n  while (\n    (front = path.getFront()) !== null &&\n    transactionNode.getValue() === null\n  ) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n(Repo.prototype as any).buildTransactionQueue_ = function(\n  transactionNode: Tree<Transaction[]>\n): Array<Transaction> {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  const transactionQueue: Transaction[] = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function(a, b) {\n    return a.order - b.order;\n  });\n\n  return transactionQueue;\n};\n\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n(Repo.prototype as any).aggregateTransactionQueuesForNode_ = function(\n  node: Tree<Transaction[]>,\n  queue: Array<Transaction>\n) {\n  const nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (let i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(child => {\n    this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n(Repo.prototype as any).pruneCompletedTransactionsBelowNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue) {\n    let to = 0;\n    for (let from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(childNode => {\n    this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n(Repo.prototype as any).abortTransactions_ = function(path: Path): Path {\n  const affectedPath = this.getAncestorTransactionNode_(path).path();\n\n  const transactionNode = this.transactionQueueTree_.subTree(path);\n\n  transactionNode.forEachAncestor((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  this.abortTransactionsOnNode_(transactionNode);\n\n  transactionNode.forEachDescendant((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  return affectedPath;\n};\n\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n(Repo.prototype as any).abortTransactionsOnNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    const callbacks = [];\n\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    let events: Event[] = [];\n    let lastSent = -1;\n    for (let i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        assert(\n          lastSent === i - 1,\n          'All SENT items should be at beginning of queue.'\n        );\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        assert(\n          queue[i].status === TransactionStatus.RUN,\n          'Unexpected transaction status in abort'\n        );\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true)\n        );\n        if (queue[i].onComplete) {\n          const snapshot: DataSnapshot | null = null;\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error('set'), false, snapshot)\n          );\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (let i = 0; i < callbacks.length; i++) {\n      exceptionGuard(callbacks[i]);\n    }\n  }\n};\n"]}