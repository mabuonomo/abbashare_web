{"version":3,"sources":["../src/core/WriteTree.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;AAEH,uCAA2D;AAC3D,uCAAwD;AACxD,oCAAmC;AACnC,iDAAgD;AAChD,8DAA8D;AAC9D,oDAAmD;AAiBnD;;;;;;GAMG;AACH;IAAA;QACE;;;;;;WAMG;QACK,mBAAc,GAAkB,6BAAa,CAAC,KAAK,CAAC;QAE5D;;;;;;;WAOG;QACK,eAAU,GAAkB,EAAE,CAAC;QAE/B,iBAAY,GAAG,CAAC,CAAC,CAAC;IA6iB5B,CAAC;IA3iBC;;;;;OAKG;IACH,+BAAW,GAAX,UAAY,IAAU;QACpB,MAAM,CAAC,IAAI,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACtC,CAAC;IAED;;;;;;;OAOG;IACH,gCAAY,GAAZ,UAAa,IAAU,EAAE,IAAU,EAAE,OAAe,EAAE,OAAiB;QACrE,aAAM,CACJ,OAAO,GAAG,IAAI,CAAC,YAAY,EAC3B,8CAA8C,CAC/C,CAAC;QACF,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC;YAC1B,OAAO,GAAG,IAAI,CAAC;QACjB,CAAC;QACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YACnB,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,IAAI;YACV,OAAO,EAAE,OAAO;YAChB,OAAO,EAAE,OAAO;SACjB,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACZ,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACjE,CAAC;QACD,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC;IAC9B,CAAC;IAED;;;;;;OAMG;IACH,4BAAQ,GAAR,UACE,IAAU,EACV,eAAsC,EACtC,OAAe;QAEf,aAAM,CACJ,OAAO,GAAG,IAAI,CAAC,YAAY,EAC3B,8CAA8C,CAC/C,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YACnB,IAAI,EAAE,IAAI;YACV,QAAQ,EAAE,eAAe;YACzB,OAAO,EAAE,OAAO;YAChB,OAAO,EAAE,IAAI;SACd,CAAC,CAAC;QAEH,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;QAC3E,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACH,4BAAQ,GAAR,UAAS,OAAe;QACtB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAChD,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,KAAK,OAAO,CAAC,CAAC,CAAC;gBAC/B,MAAM,CAAC,MAAM,CAAC;YAChB,CAAC;QACH,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;OAOG;IACH,+BAAW,GAAX,UAAY,OAAe;QACzB,iHAAiH;QACjH,gBAAgB;QAChB,qGAAqG;QACrG,4FAA4F;QAJ9F,iBAyDC;QAnDC,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,UAAS,CAAC;YAC9C,MAAM,CAAC,CAAC,CAAC,OAAO,KAAK,OAAO,CAAC;QAC/B,CAAC,CAAC,CAAC;QACH,aAAM,CAAC,GAAG,IAAI,CAAC,EAAE,8CAA8C,CAAC,CAAC;QACjE,IAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;QAC3C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;QAE/B,IAAI,sBAAsB,GAAG,aAAa,CAAC,OAAO,CAAC;QACnD,IAAI,mCAAmC,GAAG,KAAK,CAAC;QAEhD,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;QAEnC,OAAO,sBAAsB,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YACxC,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACxC,EAAE,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;gBACzB,EAAE,CAAC,CACD,CAAC,IAAI,GAAG;oBACR,IAAI,CAAC,mBAAmB,CAAC,YAAY,EAAE,aAAa,CAAC,IAAI,CAC3D,CAAC,CAAC,CAAC;oBACD,mEAAmE;oBACnE,sBAAsB,GAAG,KAAK,CAAC;gBACjC,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC1D,oGAAoG;oBACpG,mCAAmC,GAAG,IAAI,CAAC;gBAC7C,CAAC;YACH,CAAC;YACD,CAAC,EAAE,CAAC;QACN,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,mCAAmC,CAAC,CAAC,CAAC;YAC/C,iFAAiF;YACjF,IAAI,CAAC,UAAU,EAAE,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,oFAAoF;YACpF,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;gBACvB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CACnD,aAAa,CAAC,IAAI,CACnB,CAAC;YACJ,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAM,QAAQ,GAAG,aAAa,CAAC,QAAQ,CAAC;gBACxC,cAAO,CAAC,QAAQ,EAAE,UAAC,SAAiB;oBAClC,KAAI,CAAC,cAAc,GAAG,KAAI,CAAC,cAAc,CAAC,WAAW,CACnD,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CACpC,CAAC;gBACJ,CAAC,CAAC,CAAC;YACL,CAAC;YACD,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACH,wCAAoB,GAApB,UAAqB,IAAU;QAC7B,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC;IAED;;;;;;;;;OASG;IACH,0CAAsB,GAAtB,UACE,QAAc,EACd,mBAAgC,EAChC,iBAA4B,EAC5B,mBAA6B;QAE7B,EAAE,CAAC,CAAC,CAAC,iBAAiB,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC;YAC/C,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YACpE,EAAE,CAAC,CAAC,aAAa,IAAI,IAAI,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,aAAa,CAAC;YACvB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;gBAClE,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;oBACvB,MAAM,CAAC,mBAAmB,CAAC;gBAC7B,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CACR,mBAAmB,IAAI,IAAI;oBAC3B,CAAC,QAAQ,CAAC,gBAAgB,CAAC,WAAI,CAAC,KAAK,CACvC,CAAC,CAAC,CAAC;oBACD,gGAAgG;oBAChG,MAAM,CAAC,IAAI,CAAC;gBACd,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAM,YAAY,GAAG,mBAAmB,IAAI,2BAAY,CAAC,UAAU,CAAC;oBACpE,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBACtC,CAAC;YACH,CAAC;QACH,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAC/D,EAAE,CAAC,CAAC,CAAC,mBAAmB,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAC5C,MAAM,CAAC,mBAAmB,CAAC;YAC7B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,0FAA0F;gBAC1F,EAAE,CAAC,CACD,CAAC,mBAAmB;oBACpB,mBAAmB,IAAI,IAAI;oBAC3B,CAAC,KAAK,CAAC,gBAAgB,CAAC,WAAI,CAAC,KAAK,CACpC,CAAC,CAAC,CAAC;oBACD,MAAM,CAAC,IAAI,CAAC;gBACd,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAM,MAAM,GAAG,UAAS,KAAkB;wBACxC,MAAM,CAAC,CACL,CAAC,KAAK,CAAC,OAAO,IAAI,mBAAmB,CAAC;4BACtC,CAAC,CAAC,iBAAiB;gCACjB,CAAC,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;4BAC7C,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CACjE,CAAC;oBACJ,CAAC,CAAC;oBACF,IAAM,WAAW,GAAG,SAAS,CAAC,UAAU,CACtC,IAAI,CAAC,UAAU,EACf,MAAM,EACN,QAAQ,CACT,CAAC;oBACF,IAAM,YAAY,GAAG,mBAAmB,IAAI,2BAAY,CAAC,UAAU,CAAC;oBACpE,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBACzC,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;;;OAOG;IACH,6CAAyB,GAAzB,UACE,QAAc,EACd,sBAA2C;QAE3C,IAAI,gBAAgB,GAAG,2BAAY,CAAC,UAAkB,CAAC;QACvD,IAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;QAClE,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YAChB,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;gBAC9B,mDAAmD;gBACnD,WAAW,CAAC,YAAY,CAAC,8BAAc,EAAE,UACvC,SAAS,EACT,SAAS;oBAET,gBAAgB,GAAG,gBAAgB,CAAC,oBAAoB,CACtD,SAAS,EACT,SAAS,CACV,CAAC;gBACJ,CAAC,CAAC,CAAC;YACL,CAAC;YACD,MAAM,CAAC,gBAAgB,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAClC,4CAA4C;YAC5C,6EAA6E;YAC7E,IAAM,OAAK,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAC/D,sBAAsB,CAAC,YAAY,CAAC,8BAAc,EAAE,UAClD,SAAS,EACT,SAAS;gBAET,IAAM,IAAI,GAAG,OAAK;qBACf,kBAAkB,CAAC,IAAI,WAAI,CAAC,SAAS,CAAC,CAAC;qBACvC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACpB,gBAAgB,GAAG,gBAAgB,CAAC,oBAAoB,CACtD,SAAS,EACT,IAAI,CACL,CAAC;YACJ,CAAC,CAAC,CAAC;YACH,iDAAiD;YACjD,OAAK,CAAC,mBAAmB,EAAE,CAAC,OAAO,CAAC,UAAS,SAAS;gBACpD,gBAAgB,GAAG,gBAAgB,CAAC,oBAAoB,CACtD,SAAS,CAAC,IAAI,EACd,SAAS,CAAC,IAAI,CACf,CAAC;YACJ,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,gBAAgB,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,2EAA2E;YAC3E,oEAAoE;YACpE,IAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAC/D,KAAK,CAAC,mBAAmB,EAAE,CAAC,OAAO,CAAC,UAAS,SAAS;gBACpD,gBAAgB,GAAG,gBAAgB,CAAC,oBAAoB,CACtD,SAAS,CAAC,IAAI,EACd,SAAS,CAAC,IAAI,CACf,CAAC;YACJ,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,gBAAgB,CAAC;QAC1B,CAAC;IACH,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,sDAAkC,GAAlC,UACE,QAAc,EACd,SAAe,EACf,iBAA8B,EAC9B,kBAA+B;QAE/B,aAAM,CACJ,iBAAiB,IAAI,kBAAkB,EACvC,2DAA2D,CAC5D,CAAC;QACF,IAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACvC,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC/C,kFAAkF;YAClF,6EAA6E;YAC7E,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,mFAAmF;YACnF,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;YAChE,EAAE,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBACzB,qCAAqC;gBACrC,MAAM,CAAC,kBAAkB,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAChD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,wFAAwF;gBACxF,2FAA2F;gBAC3F,qGAAqG;gBACrG,oFAAoF;gBACpF,mDAAmD;gBACnD,wGAAwG;gBACxG,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,kBAAkB,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;YAClE,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;;;;OAQG;IACH,qCAAiB,GAAjB,UACE,QAAc,EACd,QAAgB,EAChB,kBAA6B;QAE7B,IAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACtC,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAChE,EAAE,CAAC,CAAC,aAAa,IAAI,IAAI,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC,aAAa,CAAC;QACvB,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,EAAE,CAAC,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACpD,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAChE,MAAM,CAAC,UAAU,CAAC,KAAK,CACrB,kBAAkB,CAAC,OAAO,EAAE,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CACzD,CAAC;YACJ,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,IAAI,CAAC;YACd,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;;;OAOG;IACH,kCAAc,GAAd,UAAe,IAAU;QACvB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC;IAED;;;;;;;;;;;OAWG;IACH,oCAAgB,GAAhB,UACE,QAAc,EACd,kBAA+B,EAC/B,SAAoB,EACpB,KAAa,EACb,OAAgB,EAChB,KAAY;QAEZ,IAAI,SAAe,CAAC;QACpB,IAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC/D,IAAM,aAAa,GAAG,KAAK,CAAC,eAAe,CAAC,WAAI,CAAC,KAAK,CAAC,CAAC;QACxD,EAAE,CAAC,CAAC,aAAa,IAAI,IAAI,CAAC,CAAC,CAAC;YAC1B,SAAS,GAAG,aAAa,CAAC;QAC5B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,kBAAkB,IAAI,IAAI,CAAC,CAAC,CAAC;YACtC,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;QAC9C,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,4BAA4B;YAC5B,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;QACD,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACvC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;YACpD,IAAM,KAAK,GAAG,EAAE,CAAC;YACjB,IAAM,GAAG,GAAG,KAAK,CAAC,UAAU,EAAE,CAAC;YAC/B,IAAM,IAAI,GAAG,OAAO;gBAClB,CAAC,CAAE,SAA0B,CAAC,sBAAsB,CAAC,SAAS,EAAE,KAAK,CAAC;gBACtE,CAAC,CAAE,SAA0B,CAAC,eAAe,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;YAClE,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC1B,OAAO,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,KAAK,EAAE,CAAC;gBACpC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC/B,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACnB,CAAC;gBACD,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YACxB,CAAC;YACD,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACK,uCAAmB,GAA3B,UAA4B,WAAwB,EAAE,IAAU;QAC9D,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,+DAA+D;YAC/D,MAAM,CAAC,CAAC,CAAC,cAAO,CAAC,WAAW,CAAC,QAAQ,EAAE,UACrC,SAAe,EACf,SAAiB;gBAEjB,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAC1D,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED;;;OAGG;IACK,8BAAU,GAAlB;QACE,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC,UAAU,CACxC,IAAI,CAAC,UAAU,EACf,SAAS,CAAC,cAAc,EACxB,WAAI,CAAC,KAAK,CACX,CAAC;QACF,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC;QAC1E,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;QACzB,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACY,wBAAc,GAA7B,UAA8B,KAAkB;QAC9C,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;IACvB,CAAC;IAED;;;;;;;;;OASG;IACY,oBAAU,GAAzB,UACE,MAAqB,EACrB,MAAmC,EACnC,QAAc;QAEd,IAAI,aAAa,GAAG,6BAAa,CAAC,KAAK,CAAC;QACxC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;YACvC,IAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACxB,mCAAmC;YACnC,4GAA4G;YAC5G,gHAAgH;YAChH,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAClB,IAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC;gBAC7B,IAAI,YAAY,SAAA,CAAC;gBACjB,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;oBACf,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;wBACjC,YAAY,GAAG,WAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;wBACtD,aAAa,GAAG,aAAa,CAAC,QAAQ,CAAC,YAAY,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;oBACnE,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACxC,YAAY,GAAG,WAAI,CAAC,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;wBACtD,aAAa,GAAG,aAAa,CAAC,QAAQ,CACpC,WAAI,CAAC,KAAK,EACV,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAClC,CAAC;oBACJ,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,qEAAqE;oBACvE,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC1B,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;wBACjC,YAAY,GAAG,WAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;wBACtD,aAAa,GAAG,aAAa,CAAC,SAAS,CACrC,YAAY,EACZ,KAAK,CAAC,QAAQ,CACf,CAAC;oBACJ,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACxC,YAAY,GAAG,WAAI,CAAC,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;wBACtD,EAAE,CAAC,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;4BAC3B,aAAa,GAAG,aAAa,CAAC,SAAS,CACrC,WAAI,CAAC,KAAK,EACV,KAAK,CAAC,QAAQ,CACf,CAAC;wBACJ,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,IAAM,KAAK,GAAG,cAAO,CAAC,KAAK,CAAC,QAAQ,EAAE,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;4BAC/D,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gCACV,+DAA+D;gCAC/D,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;gCACzD,aAAa,GAAG,aAAa,CAAC,QAAQ,CAAC,WAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;4BAC/D,CAAC;wBACH,CAAC;oBACH,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,qEAAqE;oBACvE,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,qBAAc,CAAC,4CAA4C,CAAC,CAAC;gBACrE,CAAC;YACH,CAAC;QACH,CAAC;QACD,MAAM,CAAC,aAAa,CAAC;IACvB,CAAC;IACH,gBAAC;AAAD,CAjkBA,AAikBC,IAAA;AAjkBY,8BAAS;AAmkBtB;;;;;GAKG;AACH;IAwBE;;;OAGG;IACH,sBAAY,IAAU,EAAE,SAAoB;QAC1C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;IAC9B,CAAC;IAED;;;;;;;;;OASG;IACH,6CAAsB,GAAtB,UACE,mBAAgC,EAChC,iBAA4B,EAC5B,mBAA6B;QAE7B,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,sBAAsB,CAC3C,IAAI,CAAC,SAAS,EACd,mBAAmB,EACnB,iBAAiB,EACjB,mBAAmB,CACpB,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACH,gDAAyB,GAAzB,UACE,sBAA2C;QAE3C,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,yBAAyB,CAC9C,IAAI,CAAC,SAAS,EACd,sBAAsB,CACP,CAAC;IACpB,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IACH,yDAAkC,GAAlC,UACE,IAAU,EACV,iBAA8B,EAC9B,kBAA+B;QAE/B,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,kCAAkC,CACvD,IAAI,CAAC,SAAS,EACd,IAAI,EACJ,iBAAiB,EACjB,kBAAkB,CACnB,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,qCAAc,GAAd,UAAe,IAAU;QACvB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACpE,CAAC;IAED;;;;;;;;;;OAUG;IACH,uCAAgB,GAAhB,UACE,kBAA+B,EAC/B,SAAoB,EACpB,KAAa,EACb,OAAgB,EAChB,KAAY;QAEZ,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,gBAAgB,CACrC,IAAI,CAAC,SAAS,EACd,kBAAkB,EAClB,SAAS,EACT,KAAK,EACL,OAAO,EACP,KAAK,CACN,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,wCAAiB,GAAjB,UACE,QAAgB,EAChB,mBAA8B;QAE9B,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,iBAAiB,CACtC,IAAI,CAAC,SAAS,EACd,QAAQ,EACR,mBAAmB,CACpB,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACH,4BAAK,GAAL,UAAM,SAAiB;QACrB,MAAM,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;IAC5E,CAAC;IACH,mBAAC;AAAD,CA5KA,AA4KC,IAAA;AA5KY,oCAAY","file":"WriteTree.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { findKey, forEach, safeGet } from '@firebase/util';\nimport { assert, assertionError } from '@firebase/util';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { NamedNode, Node } from './snap/Node';\nimport { CacheNode } from './view/CacheNode';\nimport { Index } from './snap/indexes/Index';\n\n/**\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\n */\nexport interface WriteRecord {\n  writeId: number;\n  path: Path;\n  snap?: Node | null;\n  children?: { [k: string]: Node } | null;\n  visible: boolean;\n}\n\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nexport class WriteTree {\n  /**\n   * A tree tracking the result of applying all visible writes.  This does not include transactions with\n   * applyLocally=false or writes that are completely shadowed by other writes.\n   *\n   * @type {!CompoundWrite}\n   * @private\n   */\n  private visibleWrites_: CompoundWrite = CompoundWrite.Empty;\n\n  /**\n   * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n   * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n   * used by transactions).\n   *\n   * @type {!Array.<!WriteRecord>}\n   * @private\n   */\n  private allWrites_: WriteRecord[] = [];\n\n  private lastWriteId_ = -1;\n\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  childWrites(path: Path): WriteTreeRef {\n    return new WriteTreeRef(path, this);\n  }\n\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older write on top of newer ones'\n    );\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  addMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older merge on top of newer ones'\n    );\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  getWrite(writeId: number): WriteRecord | null {\n    for (let i = 0; i < this.allWrites_.length; i++) {\n      const record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  removeWrite(writeId: number): boolean {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n\n    const idx = this.allWrites_.findIndex(function(s) {\n      return s.writeId === writeId;\n    });\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    const writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n\n    let i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      const currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (\n          i >= idx &&\n          this.recordContainsPath_(currentWrite, writeToRemove.path)\n        ) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(\n          writeToRemove.path\n        );\n      } else {\n        const children = writeToRemove.children;\n        forEach(children, (childName: string) => {\n          this.visibleWrites_ = this.visibleWrites_.removeWrite(\n            writeToRemove.path.child(childName)\n          );\n        });\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteWriteData(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    treePath: Path,\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      const shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        const subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (\n          completeServerCache == null &&\n          !subMerge.hasCompleteWrite(Path.Empty)\n        ) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (\n          !includeHiddenWrites &&\n          completeServerCache == null &&\n          !merge.hasCompleteWrite(Path.Empty)\n        ) {\n          return null;\n        } else {\n          const filter = function(write: WriteRecord) {\n            return (\n              (write.visible || includeHiddenWrites) &&\n              (!writeIdsToExclude ||\n                !~writeIdsToExclude.indexOf(write.writeId)) &&\n              (write.path.contains(treePath) || treePath.contains(write.path))\n            );\n          };\n          const mergeAtPath = WriteTree.layerTree_(\n            this.allWrites_,\n            filter,\n            treePath\n          );\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  }\n\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    treePath: Path,\n    completeServerChildren: ChildrenNode | null\n  ) {\n    let completeChildren = ChildrenNode.EMPTY_NODE as Node;\n    const topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childSnap\n        ) {\n          completeChildren = completeChildren.updateImmediateChild(\n            childName,\n            childSnap\n          );\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PRIORITY_INDEX, function(\n        childName,\n        childNode\n      ) {\n        const node = merge\n          .childCompoundWrite(new Path(childName))\n          .apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(\n          childName,\n          node\n        );\n      });\n      // Add any complete children we have from the set\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    }\n  }\n\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    treePath: Path,\n    childPath: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    assert(\n      existingEventSnap || existingServerSnap,\n      'Either existingEventSnap or existingServerSnap must exist'\n    );\n    const path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      const childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    treePath: Path,\n    childKey: string,\n    existingServerSnap: CacheNode\n  ): Node | null {\n    const path = treePath.child(childKey);\n    const shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        const childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(\n          existingServerSnap.getNode().getImmediateChild(childKey)\n        );\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    treePath: Path,\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    let toIterate: Node;\n    const merge = this.visibleWrites_.childCompoundWrite(treePath);\n    const shadowingNode = merge.getCompleteNode(Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      const nodes = [];\n      const cmp = index.getCompare();\n      const iter = reverse\n        ? (toIterate as ChildrenNode).getReverseIteratorFrom(startPost, index)\n        : (toIterate as ChildrenNode).getIteratorFrom(startPost, index);\n      let next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n  private recordContainsPath_(writeRecord: WriteRecord, path: Path): boolean {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!findKey(writeRecord.children, function(\n        childSnap: Node,\n        childName: string\n      ) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  }\n\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n  private resetTree_() {\n    this.visibleWrites_ = WriteTree.layerTree_(\n      this.allWrites_,\n      WriteTree.DefaultFilter_,\n      Path.Empty\n    );\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  }\n\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n  private static DefaultFilter_(write: WriteRecord) {\n    return write.visible;\n  }\n\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n  private static layerTree_(\n    writes: WriteRecord[],\n    filter: (w: WriteRecord) => boolean,\n    treeRoot: Path\n  ): CompoundWrite {\n    let compoundWrite = CompoundWrite.Empty;\n    for (let i = 0; i < writes.length; ++i) {\n      const write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        const writePath = write.path;\n        let relativePath;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(\n              Path.Empty,\n              write.snap.getChild(relativePath)\n            );\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(\n              relativePath,\n              write.children\n            );\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(\n                Path.Empty,\n                write.children\n              );\n            } else {\n              const child = safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                const deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  }\n}\n\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nexport class WriteTreeRef {\n  /**\n   * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\n   * interface to callers.\n   *\n   * @type {!Path}\n   * @private\n   * @const\n   */\n  private readonly treePath_: Path;\n\n  /**\n   * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\n   * path prefixed.\n   *\n   * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\n   * the data.\n   *\n   * @type {!WriteTree}\n   * @private\n   * @const\n   */\n  private readonly writeTree_: WriteTree;\n\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  constructor(path: Path, writeTree: WriteTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    return this.writeTree_.calcCompleteEventCache(\n      this.treePath_,\n      completeServerCache,\n      writeIdsToExclude,\n      includeHiddenWrites\n    );\n  }\n\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    completeServerChildren: ChildrenNode | null\n  ): ChildrenNode {\n    return this.writeTree_.calcCompleteEventChildren(\n      this.treePath_,\n      completeServerChildren\n    ) as ChildrenNode;\n  }\n\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    path: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(\n      this.treePath_,\n      path,\n      existingEventSnap,\n      existingServerSnap\n    );\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    return this.writeTree_.calcIndexedSlice(\n      this.treePath_,\n      completeServerData,\n      startPost,\n      count,\n      reverse,\n      index\n    );\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    childKey: string,\n    existingServerCache: CacheNode\n  ): Node | null {\n    return this.writeTree_.calcCompleteChild(\n      this.treePath_,\n      childKey,\n      existingServerCache\n    );\n  }\n\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  child(childName: string): WriteTreeRef {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  }\n}\n"]}