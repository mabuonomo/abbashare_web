{"version":3,"sources":["../src/core/view/filter/IndexedFilter.ts"],"names":[],"mappings":"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","file":"IndexedFilter.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {}\n\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    assert(\n      snap.isIndexed(this.index_),\n      'A node must be indexed if only a child is updated'\n    );\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (\n      oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))\n    ) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(\n            Change.childRemovedChange(key, oldChild)\n          );\n        } else {\n          assert(\n            snap.isLeafNode(),\n            'A child remove without an old child only makes sense on a leaf node'\n          );\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(\n          Change.childAddedChange(key, newChild)\n        );\n      } else {\n        optChangeAccumulator.trackChildChange(\n          Change.childChangedChange(key, newChild, oldChild)\n        );\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(\n              Change.childRemovedChange(key, childNode)\n            );\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(\n                Change.childChangedChange(key, childNode, oldChild)\n              );\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(\n              Change.childAddedChange(key, childNode)\n            );\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n}\n"]}