{"version":3,"sources":["../src/core/SyncTree.ts"],"names":[],"mappings":"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","file":"SyncTree.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { errorForServerCode } from './util/util';\nimport { AckUserWrite } from './operation/AckUserWrite';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { forEach, safeGet } from '@firebase/util';\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { ListenComplete } from './operation/ListenComplete';\nimport { Merge } from './operation/Merge';\nimport { Operation, OperationSource } from './operation/Operation';\nimport { Overwrite } from './operation/Overwrite';\nimport { Path } from './util/Path';\nimport { SyncPoint } from './SyncPoint';\nimport { WriteTree, WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { Node } from './snap/Node';\nimport { Event } from './view/Event';\nimport { EventRegistration } from './view/EventRegistration';\nimport { View } from './view/View';\n\n/**\n * @typedef {{\n *   startListening: function(\n *     !Query,\n *     ?number,\n *     function():string,\n *     function(!string, *):!Array.<!Event>\n *   ):!Array.<!Event>,\n *\n *   stopListening: function(!Query, ?number)\n * }}\n */\nexport interface ListenProvider {\n  startListening(\n    query: Query,\n    tag: number | null,\n    hashFn: () => string,\n    onComplete: (a: string, b?: any) => Event[]\n  ): Event[];\n\n  stopListening(a: Query, b: number | null): void;\n}\n\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\nexport class SyncTree {\n  /**\n   * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n   * @type {!ImmutableTree.<!SyncPoint>}\n   * @private\n   */\n  private syncPointTree_: ImmutableTree<SyncPoint> = ImmutableTree.Empty;\n\n  /**\n   * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n   * @type {!WriteTree}\n   * @private\n   */\n  private pendingWriteTree_ = new WriteTree();\n\n  private tagToQueryMap_: { [k: string]: string } = {};\n  private queryToTagMap_: { [k: string]: number } = {};\n\n  /**\n   * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n   *   to server data.\n   */\n  constructor(private listenProvider_: ListenProvider) {}\n\n  /**\n   * Apply the data changes for a user-generated set() or transaction() call.\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @param {number} writeId\n   * @param {boolean=} visible\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyUserOverwrite(\n    path: Path,\n    newData: Node,\n    writeId: number,\n    visible?: boolean\n  ): Event[] {\n    // Record pending write.\n    this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n\n    if (!visible) {\n      return [];\n    } else {\n      return this.applyOperationToSyncPoints_(\n        new Overwrite(OperationSource.User, path, newData)\n      );\n    }\n  }\n\n  /**\n   * Apply the data from a user-generated update() call\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyUserMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ): Event[] {\n    // Record pending merge.\n    this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.User, path, changeTree)\n    );\n  }\n\n  /**\n   * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n   *\n   * @param {!number} writeId\n   * @param {boolean=} revert True if the given write failed and needs to be reverted\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  ackUserWrite(writeId: number, revert: boolean = false) {\n    const write = this.pendingWriteTree_.getWrite(writeId);\n    const needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n    if (!needToReevaluate) {\n      return [];\n    } else {\n      let affectedTree = ImmutableTree.Empty;\n      if (write.snap != null) {\n        // overwrite\n        affectedTree = affectedTree.set(Path.Empty, true);\n      } else {\n        forEach(write.children, function(pathString: string, node: Node) {\n          affectedTree = affectedTree.set(new Path(pathString), node);\n        });\n      }\n      return this.applyOperationToSyncPoints_(\n        new AckUserWrite(write.path, affectedTree, revert)\n      );\n    }\n  }\n\n  /**\n   * Apply new server data for the specified path..\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyServerOverwrite(path: Path, newData: Node): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new Overwrite(OperationSource.Server, path, newData)\n    );\n  }\n\n  /**\n   * Apply new server data to be merged in at the specified path.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyServerMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node }\n  ): Event[] {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.Server, path, changeTree)\n    );\n  }\n\n  /**\n   * Apply a listen complete for a query\n   *\n   * @param {!Path} path\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyListenComplete(path: Path): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new ListenComplete(OperationSource.Server, path)\n    );\n  }\n\n  /**\n   * Apply new server data for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedQueryOverwrite(path: Path, snap: Node, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey != null) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new Overwrite(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath,\n        snap\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // Query must have been removed already\n      return [];\n    }\n  }\n\n  /**\n   * Apply server data to be merged in for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedQueryMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    tag: number\n  ): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const changeTree = ImmutableTree.fromObject(changedChildren);\n      const op = new Merge(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath,\n        changeTree\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Apply a listen complete for a tagged query\n   *\n   * @param {!Path} path\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedListenComplete(path: Path, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new ListenComplete(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration\n  ): Event[] {\n    const path = query.path;\n\n    let serverCache: Node | null = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    this.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {\n      const relativePath = Path.relativePath(pathToSyncPoint, path);\n      serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n      foundAncestorDefaultView =\n        foundAncestorDefaultView || sp.hasCompleteView();\n    });\n    let syncPoint = this.syncPointTree_.get(path);\n    if (!syncPoint) {\n      syncPoint = new SyncPoint();\n      this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n    } else {\n      foundAncestorDefaultView =\n        foundAncestorDefaultView || syncPoint.hasCompleteView();\n      serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let serverCacheComplete;\n    if (serverCache != null) {\n      serverCacheComplete = true;\n    } else {\n      serverCacheComplete = false;\n      serverCache = ChildrenNode.EMPTY_NODE;\n      const subtree = this.syncPointTree_.subtree(path);\n      subtree.foreachChild(function(childName, childSyncPoint) {\n        const completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);\n        if (completeCache) {\n          serverCache = serverCache.updateImmediateChild(\n            childName,\n            completeCache\n          );\n        }\n      });\n    }\n\n    const viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n    if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n      // We need to track a tag for this query\n      const queryKey = SyncTree.makeQueryKey_(query);\n      assert(\n        !(queryKey in this.queryToTagMap_),\n        'View does not exist, but we have a tag'\n      );\n      const tag = SyncTree.getNextQueryTag_();\n      this.queryToTagMap_[queryKey] = tag;\n      // Coerce to string to avoid sparse arrays.\n      this.tagToQueryMap_['_' + tag] = queryKey;\n    }\n    const writesCache = this.pendingWriteTree_.childWrites(path);\n    let events = syncPoint.addEventRegistration(\n      query,\n      eventRegistration,\n      writesCache,\n      serverCache,\n      serverCacheComplete\n    );\n    if (!viewAlreadyExists && !foundAncestorDefaultView) {\n      const view /** @type !View */ = syncPoint.viewForQuery(query);\n      events = events.concat(this.setupListener_(query, view));\n    }\n    return events;\n  }\n\n  /**\n   * Remove event callback(s).\n   *\n   * If query is the default query, we'll check all queries for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): Event[] {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query.path;\n    const maybeSyncPoint = this.syncPointTree_.get(path);\n    let cancelEvents: Event[] = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (\n      maybeSyncPoint &&\n      (query.queryIdentifier() === 'default' ||\n        maybeSyncPoint.viewExistsForQuery(query))\n    ) {\n      /**\n       * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n       */\n      const removedAndEvents = maybeSyncPoint.removeEventRegistration(\n        query,\n        eventRegistration,\n        cancelError\n      );\n      if (maybeSyncPoint.isEmpty()) {\n        this.syncPointTree_ = this.syncPointTree_.remove(path);\n      }\n      const removed = removedAndEvents.removed;\n      cancelEvents = removedAndEvents.events;\n      // We may have just removed one of many listeners and can short-circuit this whole process\n      // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n      // properly set up.\n      //\n      // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n      // queryId === 'default'\n      const removingDefault =\n        -1 !==\n        removed.findIndex(function(query) {\n          return query.getQueryParams().loadsAllData();\n        });\n      const covered = this.syncPointTree_.findOnPath(path, function(\n        relativePath,\n        parentSyncPoint\n      ) {\n        return parentSyncPoint.hasCompleteView();\n      });\n\n      if (removingDefault && !covered) {\n        const subtree = this.syncPointTree_.subtree(path);\n        // There are potentially child listeners. Determine what if any listens we need to send before executing the\n        // removal\n        if (!subtree.isEmpty()) {\n          // We need to fold over our subtree and collect the listeners to send\n          const newViews = this.collectDistinctViewsForSubTree_(subtree);\n\n          // Ok, we've collected all the listens we need. Set them up.\n          for (let i = 0; i < newViews.length; ++i) {\n            const view = newViews[i],\n              newQuery = view.getQuery();\n            const listener = this.createListenerForView_(view);\n            this.listenProvider_.startListening(\n              SyncTree.queryForListening_(newQuery),\n              this.tagForQuery_(newQuery),\n              listener.hashFn,\n              listener.onComplete\n            );\n          }\n        } else {\n          // There's nothing below us, so nothing we need to start listening on\n        }\n      }\n      // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n      // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n      // Also, note that if we have a cancelError, it's already been removed at the provider level.\n      if (!covered && removed.length > 0 && !cancelError) {\n        // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n        // default. Otherwise, we need to iterate through and cancel each individual query\n        if (removingDefault) {\n          // We don't tag default listeners\n          const defaultTag: number | null = null;\n          this.listenProvider_.stopListening(\n            SyncTree.queryForListening_(query),\n            defaultTag\n          );\n        } else {\n          removed.forEach((queryToRemove: Query) => {\n            const tagToRemove = this.queryToTagMap_[\n              SyncTree.makeQueryKey_(queryToRemove)\n            ];\n            this.listenProvider_.stopListening(\n              SyncTree.queryForListening_(queryToRemove),\n              tagToRemove\n            );\n          });\n        }\n      }\n      // Now, clear all of the tags we're tracking for the removed listens\n      this.removeTags_(removed);\n    } else {\n      // No-op, this listener must've been already removed\n    }\n    return cancelEvents;\n  }\n\n  /**\n   * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n   * it, but as this is only used by transaction code, that should always be the case anyways.\n   *\n   * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n   * @param {!Path} path The path to the data we want\n   * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    path: Path,\n    writeIdsToExclude?: number[]\n  ): Node | null {\n    const includeHiddenSets = true;\n    const writeTree = this.pendingWriteTree_;\n    const serverCache = this.syncPointTree_.findOnPath(path, function(\n      pathSoFar,\n      syncPoint\n    ) {\n      const relativePath = Path.relativePath(pathSoFar, path);\n      const serverCache = syncPoint.getCompleteServerCache(relativePath);\n      if (serverCache) {\n        return serverCache;\n      }\n    });\n    return writeTree.calcCompleteEventCache(\n      path,\n      serverCache,\n      writeIdsToExclude,\n      includeHiddenSets\n    );\n  }\n\n  /**\n   * This collapses multiple unfiltered views into a single view, since we only need a single\n   * listener for them.\n   *\n   * @param {!ImmutableTree.<!SyncPoint>} subtree\n   * @return {!Array.<!View>}\n   * @private\n   */\n  private collectDistinctViewsForSubTree_(\n    subtree: ImmutableTree<SyncPoint>\n  ): View[] {\n    return subtree.fold<\n      View[]\n    >((relativePath, maybeChildSyncPoint, childMap) => {\n      if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n        const completeView = maybeChildSyncPoint.getCompleteView();\n        return [completeView];\n      } else {\n        // No complete view here, flatten any deeper listens into an array\n        let views: View[] = [];\n        if (maybeChildSyncPoint) {\n          views = maybeChildSyncPoint.getQueryViews();\n        }\n        forEach(childMap, function(key: string, childViews: View[]) {\n          views = views.concat(childViews);\n        });\n        return views;\n      }\n    });\n  }\n\n  /**\n   * @param {!Array.<!Query>} queries\n   * @private\n   */\n  private removeTags_(queries: Query[]) {\n    for (let j = 0; j < queries.length; ++j) {\n      const removedQuery = queries[j];\n      if (!removedQuery.getQueryParams().loadsAllData()) {\n        // We should have a tag for this\n        const removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n        const removedQueryTag = this.queryToTagMap_[removedQueryKey];\n        delete this.queryToTagMap_[removedQueryKey];\n        delete this.tagToQueryMap_['_' + removedQueryTag];\n      }\n    }\n  }\n\n  /**\n   * Normalizes a query to a query we send the server for listening\n   * @param {!Query} query\n   * @return {!Query} The normalized query\n   * @private\n   */\n  private static queryForListening_(query: Query): Query {\n    if (\n      query.getQueryParams().loadsAllData() &&\n      !query.getQueryParams().isDefault()\n    ) {\n      // We treat queries that load all data as default queries\n      // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n      // from Query\n      return /** @type {!Query} */ query.getRef();\n    } else {\n      return query;\n    }\n  }\n\n  /**\n   * For a given new listen, manage the de-duplication of outstanding subscriptions.\n   *\n   * @param {!Query} query\n   * @param {!View} view\n   * @return {!Array.<!Event>} This method can return events to support synchronous data sources\n   * @private\n   */\n  private setupListener_(query: Query, view: View): Event[] {\n    const path = query.path;\n    const tag = this.tagForQuery_(query);\n    const listener = this.createListenerForView_(view);\n\n    const events = this.listenProvider_.startListening(\n      SyncTree.queryForListening_(query),\n      tag,\n      listener.hashFn,\n      listener.onComplete\n    );\n\n    const subtree = this.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n      assert(\n        !subtree.value.hasCompleteView(),\n        \"If we're adding a query, it shouldn't be shadowed\"\n      );\n    } else {\n      // Shadow everything at or below this location, this is a default listener.\n      const queriesToStop = subtree.fold<Query[]>(function(\n        relativePath,\n        maybeChildSyncPoint,\n        childMap\n      ) {\n        if (\n          !relativePath.isEmpty() &&\n          maybeChildSyncPoint &&\n          maybeChildSyncPoint.hasCompleteView()\n        ) {\n          return [maybeChildSyncPoint.getCompleteView().getQuery()];\n        } else {\n          // No default listener here, flatten any deeper queries into an array\n          let queries: Query[] = [];\n          if (maybeChildSyncPoint) {\n            queries = queries.concat(\n              maybeChildSyncPoint.getQueryViews().map(view => view.getQuery())\n            );\n          }\n          forEach(childMap, function(key: string, childQueries: Query[]) {\n            queries = queries.concat(childQueries);\n          });\n          return queries;\n        }\n      });\n      for (let i = 0; i < queriesToStop.length; ++i) {\n        const queryToStop = queriesToStop[i];\n        this.listenProvider_.stopListening(\n          SyncTree.queryForListening_(queryToStop),\n          this.tagForQuery_(queryToStop)\n        );\n      }\n    }\n    return events;\n  }\n\n  /**\n   *\n   * @param {!View} view\n   * @return {{hashFn: function(), onComplete: function(!string, *)}}\n   * @private\n   */\n  private createListenerForView_(\n    view: View\n  ): { hashFn(): string; onComplete(a: string, b?: any): Event[] } {\n    const query = view.getQuery();\n    const tag = this.tagForQuery_(query);\n\n    return {\n      hashFn: () => {\n        const cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;\n        return cache.hash();\n      },\n      onComplete: (status: string): Event[] => {\n        if (status === 'ok') {\n          if (tag) {\n            return this.applyTaggedListenComplete(query.path, tag);\n          } else {\n            return this.applyListenComplete(query.path);\n          }\n        } else {\n          // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n          // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n          const error = errorForServerCode(status, query);\n          return this.removeEventRegistration(\n            query,\n            /*eventRegistration*/ null,\n            error\n          );\n        }\n      }\n    };\n  }\n\n  /**\n   * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n   * @private\n   * @param {!Query} query\n   * @return {string}\n   */\n  private static makeQueryKey_(query: Query): string {\n    return query.path.toString() + '$' + query.queryIdentifier();\n  }\n\n  /**\n   * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n   * @private\n   * @param {!string} queryKey\n   * @return {{queryId: !string, path: !Path}}\n   */\n  private static parseQueryKey_(\n    queryKey: string\n  ): { queryId: string; path: Path } {\n    const splitIndex = queryKey.indexOf('$');\n    assert(\n      splitIndex !== -1 && splitIndex < queryKey.length - 1,\n      'Bad queryKey.'\n    );\n    return {\n      queryId: queryKey.substr(splitIndex + 1),\n      path: new Path(queryKey.substr(0, splitIndex))\n    };\n  }\n\n  /**\n   * Return the query associated with the given tag, if we have one\n   * @param {!number} tag\n   * @return {?string}\n   * @private\n   */\n  private queryKeyForTag_(tag: number): string | null {\n    return this.tagToQueryMap_['_' + tag];\n  }\n\n  /**\n   * Return the tag associated with the given query.\n   * @param {!Query} query\n   * @return {?number}\n   * @private\n   */\n  private tagForQuery_(query: Query): number | null {\n    const queryKey = SyncTree.makeQueryKey_(query);\n    return safeGet(this.queryToTagMap_, queryKey);\n  }\n\n  /**\n   * Static tracker for next query tag.\n   * @type {number}\n   * @private\n   */\n  private static nextQueryTag_ = 1;\n\n  /**\n   * Static accessor for query tags.\n   * @return {number}\n   * @private\n   */\n  private static getNextQueryTag_(): number {\n    return SyncTree.nextQueryTag_++;\n  }\n\n  /**\n   * A helper method to apply tagged operations\n   *\n   * @param {!Path} queryPath\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n  private applyTaggedOperation_(\n    queryPath: Path,\n    operation: Operation\n  ): Event[] {\n    const syncPoint = this.syncPointTree_.get(queryPath);\n    assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    const writesCache = this.pendingWriteTree_.childWrites(queryPath);\n    return syncPoint.applyOperation(\n      operation,\n      writesCache,\n      /*serverCache=*/ null\n    );\n  }\n\n  /**\n   * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n   *\n   * NOTES:\n   * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n\n   * - We call applyOperation() on each SyncPoint passing three things:\n   *   1. A version of the Operation that has been made relative to the SyncPoint location.\n   *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n   *   3. A snapshot Node with cached server data, if we have it.\n\n   * - We concatenate all of the events returned by each SyncPoint and return the result.\n   *\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n  private applyOperationToSyncPoints_(operation: Operation): Event[] {\n    return this.applyOperationHelper_(\n      operation,\n      this.syncPointTree_,\n      /*serverCache=*/ null,\n      this.pendingWriteTree_.childWrites(Path.Empty)\n    );\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n  private applyOperationHelper_(\n    operation: Operation,\n    syncPointTree: ImmutableTree<SyncPoint>,\n    serverCache: Node | null,\n    writesCache: WriteTreeRef\n  ): Event[] {\n    if (operation.path.isEmpty()) {\n      return this.applyOperationDescendantsHelper_(\n        operation,\n        syncPointTree,\n        serverCache,\n        writesCache\n      );\n    } else {\n      const syncPoint = syncPointTree.get(Path.Empty);\n\n      // If we don't have cached server data, see if we can get it from this SyncPoint.\n      if (serverCache == null && syncPoint != null) {\n        serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n      }\n\n      let events: Event[] = [];\n      const childName = operation.path.getFront();\n      const childOperation = operation.operationForChild(childName);\n      const childTree = syncPointTree.children.get(childName);\n      if (childTree && childOperation) {\n        const childServerCache = serverCache\n          ? serverCache.getImmediateChild(childName)\n          : null;\n        const childWritesCache = writesCache.child(childName);\n        events = events.concat(\n          this.applyOperationHelper_(\n            childOperation,\n            childTree,\n            childServerCache,\n            childWritesCache\n          )\n        );\n      }\n\n      if (syncPoint) {\n        events = events.concat(\n          syncPoint.applyOperation(operation, writesCache, serverCache)\n        );\n      }\n\n      return events;\n    }\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n  private applyOperationDescendantsHelper_(\n    operation: Operation,\n    syncPointTree: ImmutableTree<SyncPoint>,\n    serverCache: Node | null,\n    writesCache: WriteTreeRef\n  ): Event[] {\n    const syncPoint = syncPointTree.get(Path.Empty);\n\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n      serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let events: Event[] = [];\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\n      const childServerCache = serverCache\n        ? serverCache.getImmediateChild(childName)\n        : null;\n      const childWritesCache = writesCache.child(childName);\n      const childOperation = operation.operationForChild(childName);\n      if (childOperation) {\n        events = events.concat(\n          this.applyOperationDescendantsHelper_(\n            childOperation,\n            childTree,\n            childServerCache,\n            childWritesCache\n          )\n        );\n      }\n    });\n\n    if (syncPoint) {\n      events = events.concat(\n        syncPoint.applyOperation(operation, writesCache, serverCache)\n      );\n    }\n\n    return events;\n  }\n}\n"]}