{
  "version": 3,
  "file": "resolveContext.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/resolve/resolveContext.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @module resolve */\n/** for typedoc */\nimport { find, tail, uniqR, unnestR, inArray } from \"../common/common\";\nimport { propEq, not } from \"../common/hof\";\nimport { trace } from \"../common/trace\";\nimport { services, $InjectorLike } from \"../common/coreservices\";\nimport { resolvePolicies, PolicyWhen, ResolvePolicy } from \"./interface\";\nimport { PathNode } from \"../path/pathNode\";\nimport { Resolvable } from \"./resolvable\";\nimport { StateObject } from \"../state/stateObject\";\nimport { PathUtils } from \"../path/pathFactory\";\nimport { stringify } from \"../common/strings\";\nimport { Transition } from \"../transition/transition\";\nimport { UIInjector } from \"../interface\";\nimport { isUndefined } from '../common';\n\nconst whens = resolvePolicies.when;\nconst ALL_WHENS = [whens.EAGER, whens.LAZY];\nconst EAGER_WHENS = [whens.EAGER];\n\nexport const NATIVE_INJECTOR_TOKEN: string = \"Native Injector\";\n\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nexport class ResolveContext {\n  _injector: UIInjector;\n\n  constructor(private _path: PathNode[]) { }\n\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n  getTokens(): any[] {\n    return this._path.reduce((acc, node) => acc.concat(node.resolvables.map(r => r.token)), []).reduce(uniqR, []);\n  }\n\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   */\n  getResolvable(token: any): Resolvable {\n    let matching = this._path.map(node => node.resolvables)\n        .reduce(unnestR, [])\n        .filter((r: Resolvable) => r.token === token);\n    return tail(matching);\n  }\n\n  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n  getPolicy(resolvable: Resolvable): ResolvePolicy {\n    let node = this.findNode(resolvable);\n    return resolvable.getPolicy(node.state);\n  }\n\n  /**\n   * Returns a ResolveContext that includes a portion of this one\n   *\n   * Given a state, this method creates a new ResolveContext from this one.\n   * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n   *\n   * #### Why\n   *\n   * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n   * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n   * This method is used to create a narrower context when injecting ancestor nodes.\n   *\n   * @example\n   * `let ABCD = new ResolveContext([A, B, C, D]);`\n   *\n   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n   * However, `B` should only be able to access resolvables from `A`, `B`.\n   *\n   * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n   * `let AB = ABCD.subcontext(a)`\n   */\n  subContext(state: StateObject): ResolveContext {\n    return new ResolveContext(PathUtils.subPath(this._path, node => node.state === state));\n  }\n\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param newResolvables the new Resolvables\n   * @param state Used to find the node to put the resolvable on\n   */\n  addResolvables(newResolvables: Resolvable[], state: StateObject) {\n    let node = <PathNode> find(this._path, propEq('state', state));\n    let keys = newResolvables.map(r => r.token);\n    node.resolvables = node.resolvables.filter(r => keys.indexOf(r.token) === -1).concat(newResolvables);\n  }\n\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param when\n   * @param trans\n   * @returns {Promise<any>|any}\n   */\n  resolvePath(when: PolicyWhen = \"LAZY\", trans?: Transition): Promise<{ token: any, value: any }[]> {\n    // This option determines which 'when' policy Resolvables we are about to fetch.\n    let whenOption: string = inArray(ALL_WHENS, when) ? when : \"LAZY\";\n    // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n    let matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\n    // get the subpath to the state argument, if provided\n    trace.traceResolvePath(this._path, when, trans);\n\n    const matchesPolicy = (acceptedVals: string[], whenOrAsync: \"when\"|\"async\") =>\n        (resolvable: Resolvable) =>\n            inArray(acceptedVals, this.getPolicy(resolvable)[whenOrAsync]);\n\n    // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n    let promises: Promise<any>[] = this._path.reduce((acc, node) => {\n      let nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n      let nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n      let wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));\n\n      // For the matching Resolvables, start their async fetch process.\n      let subContext = this.subContext(node.state);\n      let getResult = (r: Resolvable) => r.get(subContext, trans)\n          // Return a tuple that includes the Resolvable's token\n          .then(value => ({ token: r.token, value: value }));\n      nowait.forEach(getResult);\n      return acc.concat(wait.map(getResult));\n    }, []);\n\n    // Wait for all the \"WAIT\" resolvables\n    return services.$q.all(promises);\n  }\n\n  injector(): UIInjector {\n    return this._injector || (this._injector = new UIInjectorImpl(this));\n  }\n\n  findNode(resolvable: Resolvable): PathNode {\n    return find(this._path, (node: PathNode) => inArray(node.resolvables, resolvable));\n  }\n\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   */\n  getDependencies(resolvable: Resolvable): Resolvable[] {\n    let node = this.findNode(resolvable);\n    // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n    let subPath: PathNode[] = PathUtils.subPath(this._path, x => x === node) || this._path;\n    let availableResolvables: Resolvable[] = subPath\n        .reduce((acc, _node) => acc.concat(_node.resolvables), []) //all of subpath's resolvables\n        .filter(res => res !== resolvable); // filter out the `resolvable` argument\n\n    const getDependency = (token: any) => {\n      let matching = availableResolvables.filter(r => r.token === token);\n      if (matching.length) return tail(matching);\n\n      let fromInjector = this.injector().getNative(token);\n      if (isUndefined(fromInjector)) {\n        throw new Error(\"Could not find Dependency Injection token: \" + stringify(token));\n      }\n\n      return new Resolvable(token, () => fromInjector, [], fromInjector);\n    };\n\n    return resolvable.deps.map(getDependency);\n  }\n}\n\nclass UIInjectorImpl implements UIInjector {\n  native: $InjectorLike;\n\n  constructor(public context: ResolveContext) {\n    this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n  }\n\n  get(token: any) {\n    let resolvable = this.context.getResolvable(token);\n    if (resolvable) {\n      if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n        return resolvable.get(this.context);\n      }\n\n      if (!resolvable.resolved) {\n        throw new Error(\"Resolvable async .get() not complete:\" + stringify(resolvable.token))\n      }\n      return resolvable.data;\n    }\n\n    return this.getNative(token);\n  }\n\n  getAsync(token: any) {\n    let resolvable = this.context.getResolvable(token);\n    if (resolvable) return resolvable.get(this.context);\n    return services.$q.when(this.native.get(token));\n  }\n\n  getNative(token: any) {\n    return this.native && this.native.get(token);\n  }\n}\n"
  ]
}