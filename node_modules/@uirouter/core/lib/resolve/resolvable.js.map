{
  "version": 3,
  "file": "resolvable.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/resolve/resolvable.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nimport {extend, equals, inArray, identity} from \"../common/common\";\nimport {services} from \"../common/coreservices\";\nimport {trace} from \"../common/trace\";\nimport {ResolvePolicy, ResolvableLiteral, resolvePolicies} from \"./interface\";\n\nimport {ResolveContext} from \"./resolveContext\";\nimport {stringify} from \"../common/strings\";\nimport {isFunction, isObject} from \"../common/predicates\";\nimport {Transition} from \"../transition/transition\";\nimport {StateObject} from \"../state/stateObject\";\nimport {PathNode} from \"../path/pathNode\";\nimport { isNullOrUndefined } from '../common';\n\n\n// TODO: explicitly make this user configurable\nexport let defaultResolvePolicy: ResolvePolicy = {\n  when: \"LAZY\",\n  async: \"WAIT\"\n};\n\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nexport class Resolvable implements ResolvableLiteral {\n  token: any;\n  policy: ResolvePolicy;\n  resolveFn: Function;\n  deps: any[];\n\n  data: any;\n  resolved: boolean = false;\n  promise: Promise<any> = undefined;\n\n  /** This constructor creates a Resolvable copy */\n  constructor(resolvable: Resolvable)\n\n  /** This constructor creates a new Resolvable from the plain old [[ResolvableLiteral]] javascript object */\n  constructor(resolvable: ResolvableLiteral)\n\n  /**\n   * This constructor creates a new `Resolvable`\n   *\n   * #### Example:\n   * ```js\n   * var resolvable1 = new Resolvable('mytoken', http => http.get('foo.json').toPromise(), [Http]);\n   *\n   * var resolvable2 = new Resolvable(UserService, dep => new UserService(dep.data), [SomeDependency]);\n   *\n   * var resolvable1Clone = new Resolvable(resolvable1);\n   * ```\n   *\n   * @param token The new resolvable's injection token, such as `\"userList\"` (a string) or `UserService` (a class).\n   *              When this token is used during injection, the resolved value will be injected.\n   * @param resolveFn The function that returns the resolved value, or a promise for the resolved value\n   * @param deps An array of dependencies, which will be injected into the `resolveFn`\n   * @param policy the [[ResolvePolicy]] defines when and how the Resolvable is processed\n   * @param data Pre-resolved data. If the resolve value is already known, it may be provided here.\n   */\n  constructor(token: any, resolveFn: Function, deps?: any[], policy?: ResolvePolicy, data?: any)\n  constructor(arg1: any, resolveFn?: Function, deps?: any[], policy?: ResolvePolicy, data?: any) {\n    if (arg1 instanceof Resolvable) {\n      extend(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      if (isNullOrUndefined(arg1)) throw new Error(\"new Resolvable(): token argument is required\");\n      if (!isFunction(resolveFn)) throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n    } else if (isObject(arg1) && arg1.token && isFunction(arg1.resolveFn)) {\n      let literal = <ResolvableLiteral> arg1;\n      return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n    }\n  }\n\n  getPolicy(state: StateObject): ResolvePolicy {\n    let thisPolicy = this.policy || {};\n    let statePolicy = state && state.resolvePolicy || {};\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n    };\n  }\n\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   */\n  resolve(resolveContext: ResolveContext, trans?: Transition) {\n    let $q = services.$q;\n\n    // Gets all dependencies from ResolveContext and wait for them to be resolved\n    const getResolvableDependencies = () =>\n        $q.all(resolveContext.getDependencies(this).map(resolvable =>\n            resolvable.get(resolveContext, trans))) as Promise<any[]>;\n\n    // Invokes the resolve function passing the resolved dependencies as arguments\n    const invokeResolveFn = (resolvedDeps: any[]) =>\n        this.resolveFn.apply(null, resolvedDeps);\n\n    /**\n     * For RXWAIT policy:\n     *\n     * Given an observable returned from a resolve function:\n     * - enables .cache() mode (this allows multicast subscribers)\n     * - then calls toPromise() (this triggers subscribe() and thus fetches)\n     * - Waits for the promise, then return the cached observable (not the first emitted value).\n     */\n    const waitForRx = (observable$: any) => {\n      let cached = observable$.cache(1);\n      return cached.take(1).toPromise().then(() => cached);\n    };\n\n    // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n    let node: PathNode = resolveContext.findNode(this);\n    let state: StateObject = node && node.state;\n    let maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : identity;\n\n    // After the final value has been resolved, update the state of the Resolvable\n    const applyResolvedValue = (resolvedValue: any) => {\n      this.data = resolvedValue;\n      this.resolved = true;\n      trace.traceResolvableResolved(this, trans);\n      return this.data;\n    };\n\n    // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n    return this.promise = $q.when()\n        .then(getResolvableDependencies)\n        .then(invokeResolveFn)\n        .then(maybeWaitForRx)\n        .then(applyResolvedValue);\n  }\n\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   */\n  get(resolveContext: ResolveContext, trans?: Transition): Promise<any> {\n    return this.promise || this.resolve(resolveContext, trans);\n  }\n\n  toString() {\n    return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;\n  }\n\n  clone(): Resolvable {\n    return new Resolvable(this);\n  }\n  \n  static fromData = (token: any, data: any) =>  \n      new Resolvable(token, () => data, null, null, data);\n}\n"
  ]
}