{
  "version": 3,
  "file": "lazyLoad.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/hooks/lazyLoad.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @module hooks */ /** */\nimport {Transition} from \"../transition/transition\";\nimport {TransitionService} from \"../transition/transitionService\";\nimport {TransitionHookFn} from \"../transition/interface\";\nimport {StateDeclaration, LazyLoadResult} from \"../state/interface\";\nimport {services} from \"../common/coreservices\";\nimport { StateRule } from \"../url/interface\";\n\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nconst lazyLoadHook: TransitionHookFn = (transition: Transition) => {\n  let router = transition.router;\n\n  function retryTransition() {\n    if (transition.originalTransition().options().source !== 'url') {\n      // The original transition was not triggered via url sync\n      // The lazy state should be loaded now, so re-try the original transition\n      let orig = transition.targetState();\n      return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n    }\n\n    // The original transition was triggered via url sync\n    // Run the URL rules and find the best match\n    let $url = router.urlService;\n    let result = $url.match($url.parts());\n    let rule = result && result.rule;\n\n    // If the best match is a state, redirect the transition (instead\n    // of calling sync() which supersedes the current transition)\n    if (rule && rule.type === \"STATE\") {\n      let state = (rule as StateRule).state;\n      let params = result.match;\n      return router.stateService.target(state, params, transition.options());\n    }\n\n    // No matching state found, so let .sync() choose the best non-state match/otherwise\n    router.urlService.sync();\n  }\n\n  let promises = transition.entering()\n      .filter(state => !!state.$$state().lazyLoad)\n      .map(state => lazyLoadState(transition, state));\n\n  return services.$q.all(promises).then(retryTransition);\n};\n\nexport const registerLazyLoadHook = (transitionService: TransitionService) =>\n    transitionService.onBefore({ entering: (state) => !!state.lazyLoad }, lazyLoadHook);\n\n\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nexport function lazyLoadState(transition: Transition, state: StateDeclaration): Promise<LazyLoadResult> {\n  let lazyLoadFn = state.$$state().lazyLoad;\n\n  // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n  let promise = lazyLoadFn['_promise'];\n  if (!promise) {\n    const success = (result) => {\n      delete state.lazyLoad;\n      delete state.$$state().lazyLoad;\n      delete lazyLoadFn['_promise'];\n      return result;\n    };\n\n    const error = (err) => {\n      delete lazyLoadFn['_promise'];\n      return services.$q.reject(err);\n    };\n\n    promise = lazyLoadFn['_promise'] =\n        services.$q.when(lazyLoadFn(transition, state))\n            .then(updateStateRegistry)\n            .then(success, error);\n  }\n\n  /** Register any lazy loaded state definitions */\n  function updateStateRegistry(result: LazyLoadResult) {\n    if (result && Array.isArray(result.states)) {\n      result.states.forEach(state => transition.router.stateRegistry.register(state));\n    }\n    return result;\n  }\n\n  return promise;\n}\n"
  ]
}