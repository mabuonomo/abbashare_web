{
  "version": 3,
  "file": "urlRule.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/url/urlRule.ts"
  ],
  "names": [],
  "mappings": ";;AAAA;;;GAGG,CAAC,MAAM;AACV,2CAA0C;AAC1C,mDAAgF;AAEhF,2CAAoD;AACpD,qCAA4C;AAO5C;;;;;;;;;;GAUG;AACH;IACE,wBAAmB,MAAgB;QAAhB,WAAM,GAAN,MAAM,CAAU;IAAI,CAAC;IAExC,gCAAO,GAAP,UAAQ,GAAW;QACjB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACpD,CAAC;IAKD,+BAAM,GAAN,UAAO,IAAyD,EAAE,OAAiC;QAAnG,iBAYC;QAXC,IAAM,QAAQ,GAAG,aAAO,CAAC;YACvB,CAAC,qBAAQ,EAAQ,UAAC,KAAa,IAAa,OAAA,QAAQ,CAAC,KAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAA7B,CAA6B,CAAC;YAC1E,CAAC,QAAE,CAAC,uBAAU,CAAC,EAAE,UAAC,KAAiB,IAAS,OAAA,KAAI,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,CAAC,EAAnC,CAAmC,CAAC;YAChF,CAAC,oBAAO,EAAS,UAAC,KAAkB,IAAQ,OAAA,KAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAI,CAAC,MAAM,CAAC,EAAlC,CAAkC,CAAC;YAC/E,CAAC,QAAE,CAAC,MAAM,CAAC,EAAM,UAAC,KAAa,IAAa,OAAA,KAAI,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,EAA/B,CAA+B,CAAC;YAC5E,CAAC,uBAAU,EAAM,UAAC,KAAqB,IAAK,OAAA,IAAI,WAAW,CAAC,KAAK,EAAE,OAA2B,CAAC,EAAnD,CAAmD,CAAC;SACjG,CAAC,CAAC;QAEH,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC1B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;YAAC,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;QACvD,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmCG;IACH,uCAAc,GAAd,UAAe,UAAsB,EAAE,OAA2C;QAChF,IAAI,QAAQ,GAAqB,OAAc,CAAC;QAChD,EAAE,CAAC,CAAC,qBAAQ,CAAC,OAAO,CAAC,CAAC;YAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAChF,EAAE,CAAC,CAAC,QAAE,CAAC,uBAAU,CAAC,CAAC,OAAO,CAAC,CAAC;YAAC,QAAQ,GAAG,UAAC,KAAgB,IAAK,OAAC,OAAsB,CAAC,MAAM,CAAC,KAAK,CAAC,EAArC,CAAqC,CAAC;QAEpG,eAAe,GAAa;YAC1B,IAAI,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;YAC5D,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC;QAC9C,CAAC;QAED,sCAAsC;QACtC,mDAAmD;QACnD,kCAAkC;QAClC,2CAA2C;QAC3C,0CAA0C;QAC1C,uBAAuB,MAAiB;YACtC,IAAI,QAAQ,GAAG,UAAU,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,UAAU,EAAhB,CAAgB,CAAC,CAAC;YACzE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;gBAAC,MAAM,CAAC,QAAQ,CAAC;YACtC,IAAI,OAAO,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,EAAhB,CAAgB,CAAC,CAAC;YACzD,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;QAC1C,CAAC;QAED,IAAI,OAAO,GAAG,EAAE,UAAU,YAAA,EAAE,aAAa,eAAA,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC;QAChE,MAAM,CAAC,eAAM,CAAC,IAAI,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE,OAAO,CAAmB,CAAC;IAC7E,CAAC;IAGD;;;;;;;;;;OAUG;IACH,kCAAS,GAAT,UAAU,KAAkB,EAAE,MAAgB;QAC5C;;;;;;WAMG;QACH,IAAM,OAAO,GAAG,UAAC,KAAgB;YAC/B,IAAI,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC;YACjC,IAAI,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;YAC7B,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC/E,MAAM,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YACtE,CAAC;QACH,CAAC,CAAC;QAEF,IAAI,OAAO,GAAG,EAAE,KAAK,OAAA,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;QACvC,MAAM,CAAC,eAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,EAAE,OAAO,CAAc,CAAC;IAC/E,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+BG;IACH,mCAAU,GAAV,UAAW,MAAc,EAAE,OAAgC;QACzD,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC;YAAC,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;QAEhG;;;;WAIG;QACH,IAAM,aAAa,GAAG,UAAC,KAAsB;YACzC,qFAAqF;YACrF,OAAC,OAAkB,CAAC,OAAO,CAAC,gBAAgB,EAAE,UAAC,CAAC,EAAE,IAAI;gBAClD,OAAA,KAAK,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAAtC,CAAsC,CAAC;QAD3C,CAC2C,CAAC;QAEhD,IAAM,QAAQ,GAAG,qBAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,CAAC;QAE7D,IAAM,KAAK,GAAG,UAAC,GAAa;YACxB,OAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;QAArB,CAAqB,CAAC;QAE1B,IAAI,OAAO,GAAG,EAAE,MAAM,QAAA,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;QACzC,MAAM,CAAC,eAAM,CAAC,IAAI,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE,OAAO,CAAe,CAAA;IACxE,CAAC;IAnKM,wBAAS,GAAG,UAAA,GAAG;QAClB,OAAA,GAAG,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC,KAAK,CAAC,UAAA,GAAG,IAAI,OAAA,sBAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAnB,CAAmB,CAAC;IAArE,CAAqE,CAAC;IAmK5E,qBAAC;CAAA,AA3KD,IA2KC;AA3KY,wCAAc;AA6K3B;;;;;GAKG;AACH;IAOE,qBAAmB,KAAqB,EAAE,OAA0B;QAApE,iBAEC;QAFkB,UAAK,GAAL,KAAK,CAAgB;QAJxC,SAAI,GAAgB,KAAK,CAAC;QAE1B,kBAAa,GAAG,UAAC,KAAK,IAAK,OAAA,CAAC,GAAG,KAAI,CAAC,GAAG,EAAZ,CAAY,CAAC;QAGtC,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,iBAAQ,CAAC;IACrC,CAAC;IACH,kBAAC;AAAD,CAAC,AAVD,IAUC;AAVY,kCAAW",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module url\n */ /** */\nimport { UrlMatcher } from \"./urlMatcher\";\nimport { isString, isDefined, isFunction, isState } from \"../common/predicates\";\nimport { UIRouter } from \"../router\";\nimport { identity, extend } from \"../common/common\";\nimport { is, pattern } from \"../common/hof\";\nimport { StateObject } from \"../state/stateObject\";\nimport { RawParams } from \"../params/interface\";\nimport {\n    UrlRule, UrlRuleMatchFn, UrlRuleHandlerFn, UrlRuleType, UrlParts, MatcherUrlRule, StateRule, RegExpRule\n} from \"./interface\";\n\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nexport class UrlRuleFactory {\n  constructor(public router: UIRouter) { }\n\n  compile(str: string) {\n    return this.router.urlMatcherFactory.compile(str);\n  }\n\n  static isUrlRule = obj =>\n      obj && ['type', 'match', 'handler'].every(key => isDefined(obj[key]));\n\n  create(what: string|UrlMatcher|StateObject|RegExp|UrlRuleMatchFn, handler?: string|UrlRuleHandlerFn): UrlRule {\n    const makeRule = pattern([\n      [isString,       (_what: string)         => makeRule(this.compile(_what))],\n      [is(UrlMatcher), (_what: UrlMatcher)     => this.fromUrlMatcher(_what, handler)],\n      [isState,        (_what: StateObject)    => this.fromState(_what, this.router)],\n      [is(RegExp),     (_what: RegExp)         => this.fromRegExp(_what, handler)],\n      [isFunction,     (_what: UrlRuleMatchFn) => new BaseUrlRule(_what, handler as UrlRuleHandlerFn)],\n    ]);\n\n    let rule = makeRule(what);\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n    return rule;\n  }\n\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   */\n  fromUrlMatcher(urlMatcher: UrlMatcher, handler: string|UrlMatcher|UrlRuleHandlerFn): MatcherUrlRule {\n    let _handler: UrlRuleHandlerFn = handler as any;\n    if (isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);\n    if (is(UrlMatcher)(handler)) _handler = (match: RawParams) => (handler as UrlMatcher).format(match);\n\n    function match(url: UrlParts) {\n      let match = urlMatcher.exec(url.path, url.search, url.hash);\n      return urlMatcher.validates(match) && match;\n    }\n\n    // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n    function matchPriority(params: RawParams): number {\n      let optional = urlMatcher.parameters().filter(param => param.isOptional);\n      if (!optional.length) return 0.000001;\n      let matched = optional.filter(param => params[param.id]);\n      return matched.length / optional.length;\n    }\n\n    let details = { urlMatcher, matchPriority, type: \"URLMATCHER\" };\n    return extend(new BaseUrlRule(match, _handler), details) as MatcherUrlRule;\n  }\n\n\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   */\n  fromState(state: StateObject, router: UIRouter): StateRule {\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n    const handler = (match: RawParams) => {\n      let $state = router.stateService;\n      let globals = router.globals;\n      if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n        $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n      }\n    };\n\n    let details = { state, type: \"STATE\" };\n    return extend(this.fromUrlMatcher(state.url, handler), details) as StateRule;\n  }\n\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   */\n  fromRegExp(regexp: RegExp, handler: string|UrlRuleHandlerFn): RegExpRule {\n    if (regexp.global || regexp.sticky) throw new Error(\"Rule RegExp must not be global or sticky\");\n\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n    const redirectUrlTo = (match: RegExpExecArray) =>\n        // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n        (handler as string).replace(/\\$(\\$|\\d{1,2})/, (m, what) =>\n            match[what === '$' ? 0 : Number(what)]);\n\n    const _handler = isString(handler) ? redirectUrlTo : handler;\n\n    const match = (url: UrlParts): RegExpExecArray =>\n        regexp.exec(url.path);\n\n    let details = { regexp, type: \"REGEXP\" };\n    return extend(new BaseUrlRule(match, _handler), details) as RegExpRule\n  }\n}\n\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nexport class BaseUrlRule implements UrlRule {\n  $id: number;\n  priority: number;\n  type: UrlRuleType = \"RAW\";\n  handler: UrlRuleHandlerFn;\n  matchPriority = (match) => 0 - this.$id;\n\n  constructor(public match: UrlRuleMatchFn, handler?: UrlRuleHandlerFn) {\n    this.handler = handler || identity;\n  }\n}"
  ]
}