{
  "version": 3,
  "file": "hookBuilder.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/hookBuilder.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\nimport {extend, tail, assertPredicate, unnestR, identity} from \"../common/common\";\nimport {isArray} from \"../common/predicates\";\n\nimport {\n    TransitionOptions, TransitionHookOptions, IHookRegistry, TreeChanges, IMatchingNodes,\n    TransitionHookPhase, TransitionHookScope\n} from \"./interface\";\n\nimport {Transition} from \"./transition\";\nimport {TransitionHook} from \"./transitionHook\";\nimport {StateObject} from \"../state/stateObject\";\nimport {PathNode} from \"../path/pathNode\";\nimport {TransitionService} from \"./transitionService\";\nimport {TransitionEventType} from \"./transitionEventType\";\nimport {RegisteredHook} from \"./hookRegistry\";\n\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nexport class HookBuilder {\n  constructor(private transition: Transition) { }\n\n  buildHooksForPhase(phase: TransitionHookPhase): TransitionHook[] {\n    let $transitions = this.transition.router.transitionService;\n    return $transitions._pluginapi._getEvents(phase)\n        .map(type => this.buildHooks(type))\n        .reduce(unnestR, [])\n        .filter(identity);\n  }\n\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   */\n  buildHooks(hookType: TransitionEventType): TransitionHook[] {\n    let transition = this.transition;\n    let treeChanges = transition.treeChanges();\n\n    // Find all the matching registered hooks for a given hook type\n    let matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n    if (!matchingHooks) return [];\n\n    let baseHookOptions = <TransitionHookOptions> {\n      transition: transition,\n      current: transition.options().current\n    };\n\n    const makeTransitionHooks = (hook: RegisteredHook) => {\n       // Fetch the Nodes that caused this hook to match.\n       let matches: IMatchingNodes = hook.matches(treeChanges);\n       // Select the PathNode[] that will be used as TransitionHook context objects\n       let matchingNodes: PathNode[] = matches[hookType.criteriaMatchPath.name];\n\n       // Return an array of HookTuples\n       return matchingNodes.map(node => {\n         let _options = extend({\n           bind: hook.bind,\n           traceData: { hookType: hookType.name, context: node }\n         }, baseHookOptions);\n\n         let state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;\n         let transitionHook = new TransitionHook(transition, state, hook, _options);\n         return <HookTuple> { hook, node, transitionHook };\n       });\n    };\n\n    return matchingHooks.map(makeTransitionHooks)\n        .reduce(unnestR, [])\n        .sort(tupleSort(hookType.reverseSort))\n        .map(tuple => tuple.transitionHook);\n  }\n\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   *\n   * @returns an array of matched [[RegisteredHook]]s\n   */\n  public getMatchingHooks(hookType: TransitionEventType, treeChanges: TreeChanges): RegisteredHook[] {\n    let isCreate = hookType.hookPhase === TransitionHookPhase.CREATE;\n\n    // Instance and Global hook registries\n    let $transitions = this.transition.router.transitionService;\n    let registries = isCreate ? [ $transitions ] : [ this.transition, $transitions ];\n\n    return registries.map((reg: IHookRegistry) => reg.getHooks(hookType.name))    // Get named hooks from registries\n        .filter(assertPredicate(isArray, `broken event named: ${hookType.name}`)) // Sanity check\n        .reduce(unnestR, [])                                                      // Un-nest RegisteredHook[][] to RegisteredHook[] array\n        .filter(hook => hook.matches(treeChanges));                               // Only those satisfying matchCriteria\n  }\n}\n\ninterface HookTuple { hook: RegisteredHook, node: PathNode, transitionHook: TransitionHook }\n\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort = false) {\n  return function nodeDepthThenPriority(l: HookTuple, r: HookTuple): number {\n    let factor = reverseDepthSort ? -1 : 1;\n    let depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n  }\n}"
  ]
}