{
  "version": 3,
  "file": "transition.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/transition.ts"
  ],
  "names": [],
  "mappings": ";;AAAA;;;GAGG;AACH,kBAAkB;AAClB,yCAAwC;AACxC,uDAAkD;AAClD,6CAA8C;AAC9C,2CAAmH;AACnH,mDAA2D;AAC3D,qCAA2D;AAE3D,yCAGqB,CAAC,kBAAkB;AACxC,mDAAkD;AAClD,+CAAuE;AACvE,6CAA4C;AAE5C,mDAAgD;AAGhD,yCAAwC;AACxC,oDAAmD;AAEnD,4DAA2D;AAM3D,cAAc;AACd,IAAM,SAAS,GAA8C,UAAI,CAAC,MAAM,CAAC,CAAC;AAE1E;;;;;;;GAOG;AACH;IAuFE;;;;;;;;;;;OAWG;IACH,oBAAY,QAAoB,EAAE,WAAwB,EAAE,MAAgB;QAA5E,iBAmBC;QAnGD,cAAc;QACN,cAAS,GAAG,uBAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC;QACxC;;;;;WAKG;QACH,YAAO,GAAiB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;QAe/C,iGAAiG;QACjG,qBAAgB,GAAoB,EAAG,CAAC;QAQxC,cAAc;QACN,iBAAY,GAAG,IAAI,yBAAW,CAAC,IAAI,CAAC,CAAC;QA4lB7C,6DAA6D;QAC7D,aAAQ,GAAG;YACP,OAAA,KAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,KAAK,KAAI;QAAvC,CAAuC,CAAC;QA9iB1C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAEhC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YACzB,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC;QACvC,CAAC;QAED,uGAAuG;QACvG,IAAI,CAAC,QAAQ,GAAG,eAAM,CAAC,EAAE,OAAO,EAAE,SAAG,CAAC,IAAI,CAAC,EAAE,EAAE,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC;QACtE,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,iBAAiB,CAAC,gBAAgB,EAAE,CAAC;QACvD,IAAI,MAAM,GAAG,uBAAS,CAAC,WAAW,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QAC1D,IAAI,CAAC,YAAY,GAAG,uBAAS,CAAC,WAAW,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QACvF,IAAI,CAAC,0BAA0B,EAAE,CAAC;QAElC,IAAI,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,+BAAmB,CAAC,MAAM,CAAC,CAAC;QACrF,+BAAc,CAAC,WAAW,CAAC,aAAa,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI,CAAC,CAAC;QAEtD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;IAChC,CAAC;IA/DD,cAAc;IACd,6BAAQ,GAAR,UAAS,QAA2B,EAAE,QAA0B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IACjH,kBAAkB;IAClB,4BAAO,GAAP,UAAQ,QAA2B,EAAE,QAA0B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IAChH,kBAAkB;IAClB,2BAAM,GAAN,UAAO,QAA2B,EAAE,QAA+B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IACpH,kBAAkB;IAClB,6BAAQ,GAAR,UAAS,QAA2B,EAAE,QAA+B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IACtH,kBAAkB;IAClB,4BAAO,GAAP,UAAQ,QAA2B,EAAE,QAA+B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IACrH,kBAAkB;IAClB,6BAAQ,GAAR,UAAS,QAA2B,EAAE,QAA0B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IACjH,kBAAkB;IAClB,8BAAS,GAAT,UAAU,QAA2B,EAAE,QAA0B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IAClH,kBAAkB;IAClB,4BAAO,GAAP,UAAQ,QAA2B,EAAE,QAA0B,EAAE,OAAwB,IAAc,MAAM,CAAC,CAAC,CAAC;IAEhH;;;OAGG;IACK,+CAA0B,GAAlC;QAAA,iBAIC;QAHC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,EAAE;aAChD,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,SAAS,KAAK,+BAAmB,CAAC,MAAM,EAA7C,CAA6C,CAAC;aAC7D,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,wBAAS,CAAC,KAAI,EAAE,KAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,EAApD,CAAoD,CAAC,CAAC;IAC7E,CAAC;IAED,mBAAmB;IACnB,6BAAQ,GAAR,UAAS,QAAgB;QACvB,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;IACzC,CAAC;IAmCO,qCAAgB,GAAxB,UAAyB,MAAgB;QACvC,IAAI,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,EAAV,CAAU,CAAC,CAAC;QACxE,uBAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,cAAc,CAAC,CAAC;IACnG,CAAC;IAED;;;;OAIG;IACH,0BAAK,GAAL;QACE,MAAM,CAAC,aAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;IAC5C,CAAC;IAED;;;;OAIG;IACH,wBAAG,GAAH;QACE,MAAM,CAAC,aAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;IAC1C,CAAC;IAED;;;;;;OAMG;IACH,yBAAI,GAAJ;QACE,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC;IAC3B,CAAC;IAED;;;;;;OAMG;IACH,uBAAE,GAAF;QACE,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;IACzB,CAAC;IAED;;;;;;OAMG;IACH,gCAAW,GAAX;QACE,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACH,uBAAE,GAAF,UAAG,OAA4C;QAC7C,EAAE,CAAC,CAAC,OAAO,YAAY,UAAU,CAAC,CAAC,CAAC;YAClC,gCAAgC;YAChC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;QACzE,CAAC;QACD,MAAM,CAAC,CAAC,CACN,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,yBAAU,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC;YACnD,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,yBAAU,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAC1D,CAAC;IACJ,CAAC;IA6BD,2BAAM,GAAN,UAAO,QAAuB;QAAvB,yBAAA,EAAA,eAAuB;QAC5B,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,UAAI,CAAC,aAAa,CAAC,CAAC,CAAC,MAAM,CAAC,eAAM,EAAE,EAAE,CAAC,CAAC,CAAC;IAChG,CAAC;IAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAsDG;IACH,6BAAQ,GAAR,UAAS,KAAmB,EAAE,QAAe;QAAf,yBAAA,EAAA,eAAe;QAC3C,IAAI,IAAI,GAAe,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACnD,EAAE,CAAC,CAAC,KAAK,CAAC;YAAC,IAAI,GAAG,uBAAS,CAAC,OAAO,CAAC,IAAI,EAAE,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,KAAK,EAAjD,CAAiD,CAAC,CAAC;QACrG,MAAM,CAAC,IAAI,+BAAc,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;IAC7C,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+BG;IACH,qCAAgB,GAAhB,UAAiB,QAAuB;QAAvB,yBAAA,EAAA,eAAuB;QACtC,MAAM,CAAC,IAAI,+BAAc,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;IACrE,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACH,kCAAa,GAAb,UAAc,UAAwC,EAAE,KAAuB;QAAvB,sBAAA,EAAA,UAAuB;QAC7E,UAAU,GAAG,QAAE,CAAC,uBAAU,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,uBAAU,CAAC,UAAU,CAAC,CAAC;QAElF,IAAI,SAAS,GAAW,CAAC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;QACzE,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC;QAClC,IAAI,UAAU,GAAG,aAAI,CAAC,MAAM,EAAE,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,EAA7B,CAA6B,CAAC,CAAC;QACrE,IAAI,cAAc,GAAmB,IAAI,+BAAc,CAAC,MAAM,CAAC,CAAC;QAChE,cAAc,CAAC,cAAc,CAAC,CAAC,UAAwB,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;IAC9E,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACH,mCAAc,GAAd;QACE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,IAAI,IAAI,CAAC;IAC9C,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;OAyBG;IACH,uCAAkB,GAAlB;QACE,IAAI,EAAE,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QAC/B,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,kBAAkB,EAAE,CAAC,IAAI,IAAI,CAAC;IACjD,CAAC;IAED;;;;OAIG;IACH,4BAAO,GAAP;QACE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,6BAAQ,GAAR;QACE,MAAM,CAAC,YAAG,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,UAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IACvE,CAAC;IAED;;;;OAIG;IACH,4BAAO,GAAP;QACE,MAAM,CAAC,YAAG,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;IAChF,CAAC;IAED;;;;;OAKG;IACH,6BAAQ,GAAR;QACE,MAAM,CAAC,YAAG,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,UAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IACvE,CAAC;IAED;;;;;;;;;;;OAWG;IACH,0BAAK,GAAL,UAAM,QAA6B,EAAE,KAAmB;QAAlD,yBAAA,EAAA,qBAA6B;QACjC,IAAI,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,YAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAC3D,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,UAAI,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,iBAAQ,CAAC,CAAC,MAAM,CAAC,gBAAO,EAAE,EAAE,CAAC,CAAC;IACtE,CAAC;IAgBD,gCAAW,GAAX,UAAY,QAAiB;QAC3B,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC;IACpE,CAAC;IAED;;;;;;;;;OASG;IACH,6BAAQ,GAAR,UAAS,WAAwB;QAC/B,IAAI,SAAS,GAAG,CAAC,EAAE,KAAK,GAAe,IAAI,CAAC;QAC5C,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC,cAAc,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC;YAChD,EAAE,CAAC,CAAC,EAAE,SAAS,GAAG,EAAE,CAAC;gBAAC,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;QAC3F,CAAC;QAED,IAAI,YAAY,GAAsB,EAAE,cAAc,EAAE,IAAI,EAAE,MAAM,EAAE,UAAU,EAAE,CAAC;QACnF,sFAAsF;QACtF,wFAAwF;QACxF,mFAAmF;QACnF,2DAA2D;QAC3D,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,MAAM,KAAK,KAAK,IAAI,WAAW,CAAC,OAAO,EAAE,CAAC,QAAQ,KAAK,KAAK,CAAC,CAAC,CAAC;YAChF,YAAY,CAAC,QAAQ,GAAG,SAAS,CAAC;QACpC,CAAC;QAED,IAAI,UAAU,GAAG,eAAM,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,WAAW,CAAC,OAAO,EAAE,EAAE,YAAY,CAAC,CAAC;QACjF,WAAW,GAAG,WAAW,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QAExD,IAAI,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;QAC9F,IAAI,qBAAqB,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;QACvD,IAAI,qBAAqB,GAAG,aAAa,CAAC,YAAY,CAAC,QAAQ,CAAC;QAEhE,uDAAuD;QACvD,0GAA0G;QAC1G,oGAAoG;QACpG,yBAAyB;QACzB,EAAE;QACF,kGAAkG;QAClG,oFAAoF;QACpF,mEAAmE;QACnE,4DAA4D;QAE5D,IAAM,eAAe,GAAG,UAAC,WAAwB,IAAK,OAAA,UAAC,IAAc;YACnE,MAAM,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC9D,CAAC,EAFqD,CAErD,CAAC;QAEF,wGAAwG;QACxG,IAAI,qBAAqB,GAAe,uBAAS,CAAC,QAAQ,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,uBAAS,CAAC,gBAAgB,CAAC;aAC/H,MAAM,CAAC,SAAG,CAAC,eAAe,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAErE,wFAAwF;QACxF,qBAAqB,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,GAAG;YACtC,IAAI,CAAC,WAAW,GAAG,qBAAqB,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC;QAC5D,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,aAAa,CAAC;IACvB,CAAC;IAED,uGAAuG;IAC/F,mCAAc,GAAtB;QACE,IAAI,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;QAE3B,qFAAqF;QACrF,oCAAoC;QACpC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,SAAS,CAAC;QAC3C,wCAAwC;QACxC,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,SAAS,CAAC;QAC9D,iCAAiC;QACjC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,SAAS,CAAC;QACtD,qCAAqC;QACrC,IAAI,WAAW,GAAY,oBAAW,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC;aACjD,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,EAAjC,CAAiC,CAAC;aAC/C,MAAM,CAAC,iBAAQ,EAAE,KAAK,CAAC,CAAC;QAC7B,EAAE,CAAC,CAAC,WAAW,CAAC;YAAC,MAAM,CAAC,SAAS,CAAC;QAElC,wCAAwC;QACxC,IAAI,WAAW,GAAc,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,UAAC,IAAc,IAAK,OAAA,IAAI,CAAC,WAAW,EAAhB,CAAgB,CAAC,CAAC;QACzE,IAAA,uGAAmF,EAAlF,gBAAQ,EAAE,kBAAU,CAA+D;QACxF,IAAI,MAAM,GAAG,oBAAW,CAAC,WAAW,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;QAE5D,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,EAA0B;gBAAzB,cAAM,EAAE,cAAM,EAAE,gBAAQ;YAAM,OAAA,aAAK,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,CAAC;QAAvC,CAAuC,CAAC,CAAC,MAAM,CAAC,gBAAO,EAAE,EAAE,CAAC,CAAC;IACjH,CAAC;IAED;;;;;;OAMG;IACH,4BAAO,GAAP;QACE,IAAI,OAAO,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,OAAO,EAAT,CAAS,CAAC,CAAC,MAAM,CAAC,iBAAQ,EAAE,KAAK,CAAC,CAAC;IAChF,CAAC;IAED;;;;;;OAMG;IACH,4BAAO,GAAP;QACE,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;IACjC,CAAC;IAED,cAAc;IACd,mCAAc,GAAd;QACE,IAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC/C,IAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;QAE9C,IAAM,IAAI,GAAG,UAAC,KAAK,EAAE,KAAK;YACxB,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC;gBAAC,MAAM,CAAC,KAAK,CAAC;YAChD,IAAM,QAAQ,GAAG,uBAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAClD,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK,QAAQ,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,EAAtD,CAAsD,CAAC,CAAC,MAAM,CAAC;QACjH,CAAC,CAAC;QAEF,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QAC/B,IAAI,MAAM,GAAG,OAAO,IAAI,OAAO,CAAC,WAAW,EAAE,CAAC;QAE9C,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;YAAC,MAAM,CAAC,eAAe,CAAC;QACvG,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC;YAAC,MAAM,CAAC,eAAe,CAAC;IACtH,CAAC;IAED;;;;;;;;OAQG;IACH,wBAAG,GAAH;QAAA,iBAiDC;QAhDC,IAAI,WAAW,GAAG,+BAAc,CAAC,WAAW,CAAC;QAE7C,kDAAkD;QAClD,IAAM,WAAW,GAAG,UAAC,KAA0B;YAC3C,OAAA,KAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,KAAK,CAAC;QAA3C,CAA2C,CAAC;QAEhD,kEAAkE;QAClE,IAAM,iBAAiB,GAAG;YACxB,aAAK,CAAC,YAAY,CAAC,KAAI,CAAC,GAAG,EAAE,EAAE,KAAI,CAAC,CAAC;YACrC,KAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAI,CAAC,EAAE,EAAE,CAAC,CAAC;YAClC,WAAW,CAAC,WAAW,CAAC,+BAAmB,CAAC,OAAO,CAAC,CAAC,CAAC;QACxD,CAAC,CAAC;QAEF,IAAM,eAAe,GAAG,UAAC,MAAW;YAClC,aAAK,CAAC,UAAU,CAAC,MAAM,EAAE,KAAI,CAAC,CAAC;YAC/B,KAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YACrB,KAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAC9B,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,WAAW,CAAC,WAAW,CAAC,+BAAmB,CAAC,KAAK,CAAC,CAAC,CAAC;QACtD,CAAC,CAAC;QAEF,IAAM,aAAa,GAAG;YACpB,mEAAmE;YACnE,+FAA+F;YAC/F,IAAI,WAAW,GAAG,WAAW,CAAC,+BAAmB,CAAC,GAAG,CAAC,CAAC;YACvD,IAAI,IAAI,GAAG,cAAM,OAAA,uBAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,EAA3B,CAA2B,CAAC;YAC7C,MAAM,CAAC,+BAAc,CAAC,WAAW,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QACvD,CAAC,CAAC;QAEF,IAAM,eAAe,GAAG;YACtB,IAAI,OAAO,GAAG,KAAI,CAAC,MAAM,CAAC,OAAO,CAAC;YAElC,OAAO,CAAC,uBAAuB,GAAG,KAAI,CAAC,GAAG,CAAC;YAC3C,OAAO,CAAC,UAAU,GAAG,KAAI,CAAC;YAC1B,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAI,CAAC,CAAC;YAExC,aAAK,CAAC,oBAAoB,CAAC,KAAI,CAAC,CAAC;YAEjC,MAAM,CAAC,uBAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACrC,CAAC,CAAC;QAEF,IAAI,cAAc,GAAG,WAAW,CAAC,+BAAmB,CAAC,MAAM,CAAC,CAAC;QAC7D,+BAAc,CAAC,WAAW,CAAC,cAAc,EAAE,eAAe,CAAC;aACtD,IAAI,CAAC,aAAa,CAAC;aACnB,IAAI,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;QAE9C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAMD;;;;OAIG;IACH,0BAAK,GAAL;QACE,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,CAAC;IACrD,CAAC;IAED;;;;;OAKG;IACH,0BAAK,GAAL;QACE,wDAAwD;QACxD,EAAE,CAAC,CAAC,wBAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAE,CAAC;YAC/B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACvB,CAAC;IACH,CAAC;IAED;;;;;;;OAOG;IACH,0BAAK,GAAL;QACE,IAAI,KAAK,GAAgB,IAAI,CAAC,GAAG,EAAE,CAAC;QAEpC,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;YACtB,MAAM,CAAC,0CAAwC,KAAK,CAAC,IAAI,MAAG,CAAC;QAE/D,IAAM,SAAS,GAAG,KAAK,CAAC,UAAU,EAAE,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QAC7D,IAAM,aAAa,GAAG,SAAS,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAlC,CAAkC,CAAC,CAAC;QACpF,EAAE,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,uCAAqC,KAAK,CAAC,IAAI,6BAAwB,aAAa,CAAC,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,EAAE,EAAR,CAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAI,CAAC;QACpI,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC;YACzB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,6BAAQ,GAAR;QACE,IAAI,eAAe,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAClC,IAAI,aAAa,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC;QAE9B,IAAM,cAAc,GAAG,UAAC,MAAiB;YACvC,OAAA,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,aAAI,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC;QAAlF,CAAkF,CAAC;QAErF,qCAAqC;QACrC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,EACb,IAAI,GAAG,qBAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,eAAe,EACzE,UAAU,GAAG,mBAAS,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,UAAI,CAAC,aAAa,CAAC,CAAC,CAAC,MAAM,CAAC,eAAM,EAAE,EAAE,CAAC,CAAC,CAAC,EAC1G,OAAO,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,EACpC,EAAE,GAAG,qBAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,aAAa,EACjE,QAAQ,GAAG,mBAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QAExD,MAAM,CAAC,gBAAc,EAAE,WAAM,IAAI,SAAI,UAAU,YAAO,OAAO,SAAI,EAAE,SAAI,QAAQ,OAAI,CAAC;IACtF,CAAC;IArtBD,cAAc;IACP,kBAAO,GAAG,UAAU,CAAC;IAqtB9B,iBAAC;CAAA,AAxtBD,IAwtBC;AAxtBY,gCAAU",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { stringify } from '../common/strings';\nimport { map, find, extend, mergeR, tail, omit, arrayTuples, unnestR, identity, anyTrueR } from '../common/common';\nimport {isObject, isUndefined} from '../common/predicates';\nimport { prop, propEq, val, not, is } from '../common/hof';\nimport { StateDeclaration, StateOrName } from '../state/interface';\nimport {\n  TransitionOptions, TreeChanges, IHookRegistry, TransitionHookPhase, RegisteredHooks, HookRegOptions,\n  HookMatchCriteria, TransitionStateHookFn, TransitionHookFn,\n} from './interface'; // has or is using\nimport { TransitionHook } from './transitionHook';\nimport { matchState, makeEvent, RegisteredHook } from './hookRegistry';\nimport { HookBuilder } from './hookBuilder';\nimport { PathNode } from '../path/pathNode';\nimport { PathUtils } from '../path/pathFactory';\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ViewConfig } from '../view/interface';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { UIRouter } from '../router';\nimport { UIInjector } from '../interface';\nimport { RawParams } from '../params/interface';\nimport { ResolvableLiteral } from '../resolve/interface';\n\n/** @hidden */\nconst stateSelf: (_state: StateObject) => StateDeclaration = prop(\"self\");\n\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nexport class Transition implements IHookRegistry {\n\n  /** @hidden */\n  static diToken = Transition;\n\n  /**\n   * A unique identifier for the transition.\n   *\n   * This is an auto incrementing integer, starting from `0`.\n   */\n  $id: number;\n\n  /**\n   * A reference to the [[UIRouter]] instance\n   *\n   * This reference can be used to access the router services, such as the [[StateService]]\n   */\n  router: UIRouter;\n\n  /** @hidden */\n  private _deferred = services.$q.defer();\n  /**\n   * This promise is resolved or rejected based on the outcome of the Transition.\n   *\n   * When the transition is successful, the promise is resolved\n   * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n   */\n  promise: Promise<any> = this._deferred.promise;\n  /**\n   * A boolean which indicates if the transition was successful\n   *\n   * After a successful transition, this value is set to true.\n   * After an unsuccessful transition, this value is set to false.\n   *\n   * The value will be undefined if the transition is not complete\n   */\n  success: boolean;\n  /** @hidden */\n  _aborted: boolean;\n  /** @hidden */\n  private _error: any;\n\n  /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n  _registeredHooks: RegisteredHooks = { };\n\n  /** @hidden */\n  private _options: TransitionOptions;\n  /** @hidden */\n  private _treeChanges: TreeChanges;\n  /** @hidden */\n  private _targetState: TargetState;\n  /** @hidden */\n  private _hookBuilder = new HookBuilder(this);\n\n\n  /** @hidden */\n  onBefore(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onStart(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onExit(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onRetain(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onEnter(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onFinish(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onSuccess(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function { return; }\n  /** @inheritdoc */\n  onError(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function { return; }\n\n  /** @hidden\n   * Creates the transition-level hook registration functions\n   * (which can then be used to register hooks)\n   */\n  private createTransitionHookRegFns() {\n    this.router.transitionService._pluginapi._getEvents()\n        .filter(type => type.hookPhase !== TransitionHookPhase.CREATE)\n        .forEach(type => makeEvent(this, this.router.transitionService, type));\n  }\n\n  /** @internalapi */\n  getHooks(hookName: string): RegisteredHook[] {\n    return this._registeredHooks[hookName];\n  }\n\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @internalapi\n   *\n   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param router The [[UIRouter]] instance\n   */\n  constructor(fromPath: PathNode[], targetState: TargetState, router: UIRouter) {\n    this.router = router;\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    }\n\n    // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n    this._options = extend({ current: val(this) }, targetState.options());\n    this.$id = router.transitionService._transitionCount++;\n    let toPath = PathUtils.buildToPath(fromPath, targetState);\n    this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n    this.createTransitionHookRegFns();\n\n    let onCreateHooks = this._hookBuilder.buildHooksForPhase(TransitionHookPhase.CREATE);\n    TransitionHook.invokeHooks(onCreateHooks, () => null);\n\n    this.applyViewConfigs(router);\n  }\n\n  private applyViewConfigs(router: UIRouter) {\n    let enteringStates = this._treeChanges.entering.map(node => node.state);\n    PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n  }\n\n  /**\n   * @internalapi\n   *\n   * @returns the internal from [State] object\n   */\n  $from() {\n    return tail(this._treeChanges.from).state;\n  }\n\n  /**\n   * @internalapi\n   *\n   * @returns the internal to [State] object\n   */\n  $to() {\n    return tail(this._treeChanges.to).state;\n  }\n\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns The state declaration object for the Transition's (\"from state\").\n   */\n  from(): StateDeclaration {\n    return this.$from().self;\n  }\n\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns The state declaration object for the Transition's target state (\"to state\").\n   */\n  to(): StateDeclaration {\n    return this.$to().self;\n  }\n\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns the [[TargetState]] of this Transition\n   */\n  targetState() {\n    return this._targetState;\n  }\n\n  /**\n   * Determines whether two transitions are equivalent.\n   * @deprecated\n   */\n  is(compare: (Transition|{to?: any, from?: any})): boolean {\n    if (compare instanceof Transition) {\n      // TODO: Also compare parameters\n      return this.is({ to: compare.$to().name, from: compare.$from().name });\n    }\n    return !(\n      (compare.to && !matchState(this.$to(), compare.to)) ||\n      (compare.from && !matchState(this.$from(), compare.from))\n    );\n  }\n\n  /**\n   * Gets transition parameter values\n   *\n   * Returns the parameter values for a transition as key/value pairs.\n   * This object is immutable.\n   *\n   * By default, returns the new parameter values (for the \"to state\").\n   *\n   * #### Example:\n   * ```js\n   * var toParams = transition.params();\n   * ```\n   *\n   * To return the previous parameter values,  supply `'from'` as the `pathname` argument.\n   *\n   * #### Example:\n   * ```js\n   * var fromParams = transition.params('from');\n   * ```\n   *\n   * @param pathname the name of the treeChanges path to get parameter values for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   *\n   * @returns transition parameter values for the desired path.\n   */\n  params(pathname?: string): any;\n  params<T>(pathname?: string): T;\n  params(pathname: string = \"to\") {\n    return Object.freeze(this._treeChanges[pathname].map(prop(\"paramValues\")).reduce(mergeR, {}));\n  }\n\n\n  /**\n   * Creates a [[UIInjector]] Dependency Injector\n   *\n   * Returns a Dependency Injector for the Transition's target state (to state).\n   * The injector provides resolve values which the target state has access to.\n   *\n   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n   *\n   * #### Example:\n   * ```js\n   * .onEnter({ entering: 'myState' }, trans => {\n   *   var myResolveValue = trans.injector().get('myResolve');\n   *   // Inject a global service from the global/native injector (if it exists)\n   *   var MyService = trans.injector().get('MyService');\n   * })\n   * ```\n   *\n   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n   * You can use [[UIInjector.getAsync]] to get a promise for the data.\n   * #### Example:\n   * ```js\n   * .onBefore({}, trans => {\n   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n   *     return myResolveValue !== 'ABORT';\n   *   });\n   * });\n   * ```\n   *\n   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n   * #### Example:\n   * ```js\n   * .onEnter({ to: 'foo.bar' }, trans => {\n   *   // returns result of `foo` state's `data` resolve\n   *   // even though `foo.bar` also has a `data` resolve\n   *   var fooData = trans.injector('foo').get('data');\n   * });\n   * ```\n   *\n   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n   * The resolve data from the `from` path will be returned.\n   * #### Example:\n   * ```js\n   * .onExit({ exiting: 'foo.bar' }, trans => {\n   *   // Gets the resolve value of `data` from the exiting state.\n   *   var fooData = trans.injector(null, 'foo.bar').get('data');\n   * });\n   * ```\n   *\n   *\n   * @param state Limits the resolves provided to only the resolves the provided state has access to.\n   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n   *\n   * @returns a [[UIInjector]]\n   */\n  injector(state?: StateOrName, pathName = \"to\"): UIInjector {\n    let path: PathNode[] = this._treeChanges[pathName];\n    if (state) path = PathUtils.subPath(path, node => node.state === state || node.state.name === state);\n    return new ResolveContext(path).injector();\n  }\n\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n  getResolveTokens(pathname: string = \"to\"): any[] {\n    return new ResolveContext(this._treeChanges[pathname]).getTokens();\n  }\n\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n  addResolvable(resolvable: Resolvable|ResolvableLiteral, state: StateOrName = \"\"): void {\n    resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n\n    let stateName: string = (typeof state === \"string\") ? state : state.name;\n    let topath = this._treeChanges.to;\n    let targetNode = find(topath, node => node.state.name === stateName);\n    let resolveContext: ResolveContext = new ResolveContext(topath);\n    resolveContext.addResolvables([resolvable as Resolvable], targetNode.state);\n  }\n\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns The previous Transition, or null if this Transition is not the result of a redirection\n   */\n  redirectedFrom(): Transition {\n    return this._options.redirectedFrom || null;\n  }\n\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns The original Transition that started a redirect chain\n   */\n  originalTransition(): Transition {\n    let rf = this.redirectedFrom();\n    return (rf && rf.originalTransition()) || this;\n  }\n\n  /**\n   * Get the transition options\n   *\n   * @returns the options for this Transition.\n   */\n  options(): TransitionOptions {\n    return this._options;\n  }\n\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n  entering(): StateDeclaration[] {\n    return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Gets the states being exited.\n   *\n   * @returns an array of states that will be exited during this transition.\n   */\n  exiting(): StateDeclaration[] {\n    return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n  }\n\n  /**\n   * Gets the states being retained.\n   *\n   * @returns an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n  retained(): StateDeclaration[] {\n    return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns a list of ViewConfig objects for the given path.\n   */\n  views(pathname: string = \"entering\", state?: StateObject): ViewConfig[] {\n    let path = this._treeChanges[pathname];\n    path = !state ? path : path.filter(propEq('state', state));\n    return path.map(prop(\"views\")).filter(identity).reduce(unnestR, []);\n  }\n\n  /**\n   * Return the transition's tree changes\n   *\n   * A transition goes from one state/parameters to another state/parameters.\n   * During a transition, states are entered and/or exited.\n   *\n   * This function returns various branches (paths) which represent the changes to the\n   * active state tree that are caused by the transition.\n   *\n   * @param pathname The name of the tree changes path to get:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   */\n  treeChanges(pathname: string): PathNode[];\n  treeChanges(): TreeChanges;\n  treeChanges(pathname?: string) {\n    return pathname ? this._treeChanges[pathname] : this._treeChanges;\n  }\n\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @internalapi\n   *\n   * @returns Returns a new [[Transition]] instance.\n   */\n  redirect(targetState: TargetState): Transition {\n    let redirects = 1, trans: Transition = this;\n    while ((trans = trans.redirectedFrom()) != null) {\n      if (++redirects > 20) throw new Error(`Too many consecutive Transition redirects (20+)`);\n    }\n\n    let redirectOpts: TransitionOptions = { redirectedFrom: this, source: \"redirect\" };\n    // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n    if (this.options().source === 'url' && targetState.options().location !== false) {\n      redirectOpts.location = 'replace';\n    }\n\n    let newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n    targetState = targetState.withOptions(newOptions, true);\n\n    let newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n    let originalEnteringNodes = this._treeChanges.entering;\n    let redirectEnteringNodes = newTransition._treeChanges.entering;\n\n    // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n\n    const nodeIsReloading = (reloadState: StateObject) => (node: PathNode) => {\n      return reloadState && node.state.includes[reloadState.name];\n    };\n\n    // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n    let matchingEnteringNodes: PathNode[] = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams)\n        .filter(not(nodeIsReloading(targetState.options().reloadState)));\n\n    // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n    matchingEnteringNodes.forEach((node, idx) => {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n\n    return newTransition;\n  }\n\n  /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n  private _changedParams(): Param[] {\n    let tc = this._treeChanges;\n\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n    if (this._options.reload) return undefined;\n    // If any states are exiting or entering\n    if (tc.exiting.length || tc.entering.length) return undefined;\n    // If to/from path lengths differ\n    if (tc.to.length !== tc.from.length) return undefined;\n    // If the to/from paths are different\n    let pathsDiffer: boolean = arrayTuples(tc.to, tc.from)\n        .map(tuple => tuple[0].state !== tuple[1].state)\n        .reduce(anyTrueR, false);\n    if (pathsDiffer) return undefined;\n\n    // Find any parameter values that differ\n    let nodeSchemas: Param[][] = tc.to.map((node: PathNode) => node.paramSchema);\n    let [toValues, fromValues] = [tc.to, tc.from].map(path => path.map(x => x.paramValues));\n    let tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n\n    return tuples.map(([schema, toVals, fromVals]) => Param.changed(schema, toVals, fromVals)).reduce(unnestR, []);\n  }\n\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns true if the Transition is dynamic\n   */\n  dynamic(): boolean {\n    let changes = this._changedParams();\n    return !changes ? false : changes.map(x => x.dynamic).reduce(anyTrueR, false);\n  }\n\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n  ignored(): boolean {\n    return !!this._ignoredReason();\n  }\n\n  /** @hidden */\n  _ignoredReason(): \"SameAsCurrent\"|\"SameAsPending\"|undefined {\n    const pending = this.router.globals.transition;\n    const reloadState = this._options.reloadState;\n\n    const same = (pathA, pathB) => {\n      if (pathA.length !== pathB.length) return false;\n      const matching = PathUtils.matching(pathA, pathB);\n      return pathA.length === matching.filter(node => !reloadState || !node.state.includes[reloadState.name]).length;\n    };\n\n    let newTC = this.treeChanges();\n    let pendTC = pending && pending.treeChanges();\n\n    if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return \"SameAsPending\";\n    if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return \"SameAsCurrent\";\n  }\n\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internalapi\n   *\n   * @returns a promise for a successful transition.\n   */\n  run(): Promise<any> {\n    let runAllHooks = TransitionHook.runAllHooks;\n\n    // Gets transition hooks array for the given phase\n    const getHooksFor = (phase: TransitionHookPhase) =>\n        this._hookBuilder.buildHooksForPhase(phase);\n\n    // When the chain is complete, then resolve or reject the deferred\n    const transitionSuccess = () => {\n      trace.traceSuccess(this.$to(), this);\n      this.success = true;\n      this._deferred.resolve(this.to());\n      runAllHooks(getHooksFor(TransitionHookPhase.SUCCESS));\n    };\n\n    const transitionError = (reason: any) => {\n      trace.traceError(reason, this);\n      this.success = false;\n      this._deferred.reject(reason);\n      this._error = reason;\n      runAllHooks(getHooksFor(TransitionHookPhase.ERROR));\n    };\n\n    const runTransition = () => {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      let allRunHooks = getHooksFor(TransitionHookPhase.RUN);\n      let done = () => services.$q.when(undefined);\n      return TransitionHook.invokeHooks(allRunHooks, done);\n    };\n\n    const startTransition = () => {\n      let globals = this.router.globals;\n\n      globals.lastStartedTransitionId = this.$id;\n      globals.transition = this;\n      globals.transitionHistory.enqueue(this);\n\n      trace.traceTransitionStart(this);\n\n      return services.$q.when(undefined);\n    };\n\n    let allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n        .then(runTransition)\n        .then(transitionSuccess, transitionError);\n\n    return this.promise;\n  }\n\n  /** Checks if this transition is currently active/running. */\n  isActive = () =>\n      this.router.globals.transition === this;\n\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n  valid() {\n    return !this.error() || this.success !== undefined;\n  }\n\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n  abort() {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success))  {\n      this._aborted = true;\n    }\n  }\n\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n   */\n  error() {\n    let state: StateObject = this.$to();\n\n    if (state.self.abstract)\n      return `Cannot transition to abstract state '${state.name}'`;\n\n    const paramDefs = state.parameters(), values = this.params();\n    const invalidParams = paramDefs.filter(param => !param.validates(values[param.id]));\n    if (invalidParams.length) {\n      return `Param values not valid for state '${state.name}'. Invalid params: [ ${invalidParams.map(param => param.id).join(', ')} ]`;\n    }\n\n    if (this.success === false)\n      return this._error;\n  }\n\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n  toString () {\n    let fromStateOrName = this.from();\n    let toStateOrName = this.to();\n\n    const avoidEmptyHash = (params: RawParams) =>\n      (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : omit(params, [\"#\"]);\n\n    // (X) means the to state is invalid.\n    let id = this.$id,\n        from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n        fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))),\n        toValid = this.valid() ? \"\" : \"(X) \",\n        to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n        toParams = stringify(avoidEmptyHash(this.params()));\n\n    return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;\n  }\n}\n"
  ]
}