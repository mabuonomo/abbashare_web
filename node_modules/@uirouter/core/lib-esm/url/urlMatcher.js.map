{
  "version": 3,
  "file": "urlMatcher.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/url/urlMatcher.ts"
  ],
  "names": [],
  "mappings": "AAAA;;;GAGG;AACH,kBAAkB;AAClB,OAAO,EACL,GAAG,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAc,QAAQ,EAAE,OAAO,EAAE,WAAW,EACjG,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AACpE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAIjD,OAAO,EAAE,cAAc,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjE,cAAc;AACd,qBAAqB,MAAW,EAAE,KAAW;IAC3C,IAAI,eAAe,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,uBAAuB,EAAE,MAAM,CAAC,CAAC;IACzF,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;QAAC,MAAM,CAAC,MAAM,CAAC;IAE1B,MAAM,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QACrB,KAAK,KAAK;YACR,eAAe,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAAC,KAAK,CAAC;QACtE,KAAK,IAAI;YACP,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACnC,eAAe,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACvC,KAAK,CAAC;QACR;YACE,eAAe,GAAG,CAAC,MAAI,KAAK,CAAC,MAAM,MAAG,EAAE,IAAI,CAAC,CAAC;YAAC,KAAK,CAAC;IACzD,CAAC;IACD,MAAM,CAAC,MAAM,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;AACtF,CAAC;AAED,cAAc;AACd,IAAM,SAAS,GAAG,UAAC,GAAQ,EAAE,IAAY,EAAE,EAAY;IACnD,OAAA,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE;AAA7B,CAA6B,CAAC;AAElC,cAAc;AACd,IAAM,YAAY,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;AAWvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkDG;AACH;IAkBE;;;;;;OAMG;IACH,oBAAY,OAAe,EAAE,UAAsB,EAAE,YAA0B,EAAS,MAAY;QAApG,iBAuFC;QAvFuF,WAAM,GAAN,MAAM,CAAM;QArBpG,cAAc;QACN,WAAM,GAAoB,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QACnD,cAAc;QACN,cAAS,GAAiB,EAAE,CAAC;QACrC,cAAc;QACN,YAAO,GAAmB,EAAE,CAAC;QACrC,cAAc;QACN,cAAS,GAAiB,EAAE,CAAC;QACrC,cAAc;QACN,cAAS,GAAiB,EAAE,CAAC;QAanC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE;YAClC,MAAM,EAAE,EAAE;YACV,MAAM,EAAE,IAAI;YACZ,eAAe,EAAE,KAAK;YACtB,QAAQ,EAAE,QAAQ;SACnB,CAAC,CAAC;QAEH,6FAA6F;QAC7F,aAAa;QACb,aAAa;QACb,iBAAiB;QACjB,4BAA4B;QAC5B,uFAAuF;QACvF,gFAAgF;QAChF,0GAA0G;QAC1G,8IAA8I;QAC9I,uGAAuG;QACvG,oFAAoF;QACpF,yDAAyD;QACzD,2FAA2F;QAC3F,IAAI,WAAW,GAAG,uFAAuF,EACrG,iBAAiB,GAAG,2FAA2F,EAC/G,IAAI,GAAG,CAAC,EAAE,CAAkB,EAAE,QAAQ,GAAY,EAAE,CAAC;QAEzD,IAAM,gBAAgB,GAAG,UAAC,EAAU;YAClC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBAAC,MAAM,IAAI,KAAK,CAAC,6BAA2B,EAAE,sBAAiB,OAAO,MAAG,CAAC,CAAC;YAClH,EAAE,CAAC,CAAC,IAAI,CAAC,KAAI,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;gBAAC,MAAM,IAAI,KAAK,CAAC,+BAA6B,EAAE,sBAAiB,OAAO,MAAG,CAAC,CAAC;QACxH,CAAC,CAAC;QAEF,uEAAuE;QACvE,yEAAyE;QACzE,IAAM,YAAY,GAAG,UAAC,CAAkB,EAAE,QAAiB;YACzD,yDAAyD;YACzD,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YAE3E,IAAM,cAAc,GAAG,UAAC,MAAM,IAAK,OAAA,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;gBACvF,OAAO,EAAE,IAAI,MAAM,CAAC,MAAM,EAAE,KAAI,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC;aAC3E,CAAC,EAFiC,CAEjC,CAAC;YAEH,MAAM,CAAC;gBACL,EAAE,IAAA;gBACF,MAAM,QAAA;gBACN,GAAG,EAAM,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC/B,OAAO,EAAE,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC;gBACzC,IAAI,EAAK,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,MAAM,CAAC;aAC5E,CAAC;QACJ,CAAC,CAAC;QAEF,IAAI,CAAM,EAAE,OAAe,CAAC;QAE5B,OAAO,CAAC,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC;YACvC,CAAC,GAAG,YAAY,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;YAC3B,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC,CAAC,6BAA6B;YAErE,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;YACvB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3F,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;YAC/B,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAI,GAAG,WAAW,CAAC,SAAS,CAAC;QAC/B,CAAC;QACD,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QAElC,wEAAwE;QACxE,IAAI,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAE7B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACX,IAAI,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAClC,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAElC,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAI,GAAG,CAAC,CAAC;gBAET,OAAO,CAAC,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;oBAC5C,CAAC,GAAG,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;oBAC1B,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;oBACvB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC5F,IAAI,GAAG,WAAW,CAAC,SAAS,CAAC;oBAC7B,cAAc;gBAChB,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,WAAW,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,EAAhC,CAAgC,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;IAC1G,CAAC;IAED;;;;;;OAMG;IACH,2BAAM,GAAN,UAAO,GAAe;QACpB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACzB,GAAG,CAAC,MAAM,GAAG;YACX,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;YAClC,MAAM,EAAE,IAAI;YACZ,OAAO,EAAE,IAAI;SACd,CAAC;QACF,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED,cAAc;IACd,2BAAM,GAAN;QACE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC;IACtC,CAAC;IAED,uCAAuC;IACvC,6BAAQ,GAAR;QACE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;OAyBG;IACH,yBAAI,GAAJ,UAAK,IAAY,EAAE,MAAgB,EAAE,IAAa,EAAE,OAAiB;QAArE,iBAwDC;QAxDkB,uBAAA,EAAA,WAAgB;QAAiB,wBAAA,EAAA,YAAiB;QACnE,IAAI,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE;YAC5C,MAAM,CAAC,IAAI,MAAM,CAAC;gBAChB,GAAG;gBACH,MAAM,CAAC,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;gBACxD,KAAI,CAAC,MAAM,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;gBACzC,GAAG;aACJ,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,KAAI,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEd,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAExB,kDAAkD;QAElD,IAAI,SAAS,GAAe,IAAI,CAAC,UAAU,EAAE,EACzC,UAAU,GAAc,SAAS,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAjB,CAAiB,CAAC,EACpE,YAAY,GAAY,SAAS,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,QAAQ,EAAE,EAAhB,CAAgB,CAAC,EACnE,aAAa,GAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAzB,CAAyB,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAG,CAAC,EAAL,CAAK,CAAC,EAChG,MAAM,GAAc,EAAE,CAAC;QAE3B,EAAE,CAAC,CAAC,aAAa,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YACrC,MAAM,IAAI,KAAK,CAAC,wCAAsC,IAAI,CAAC,OAAO,MAAG,CAAC,CAAC;QAEzE,yBAAyB,MAAc;YACrC,IAAM,aAAa,GAAG,UAAC,GAAW,IAAK,OAAA,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAhC,CAAgC,CAAC;YACxE,IAAM,aAAa,GAAG,UAAC,GAAW,IAAK,OAAA,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,EAAxB,CAAwB,CAAC;YAEhE,IAAI,KAAK,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YACnD,IAAI,WAAW,GAAG,GAAG,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;YAC5C,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC,OAAO,EAAE,CAAC;QACnD,CAAC;QAED,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;YACvC,IAAI,KAAK,GAAU,UAAU,CAAC,CAAC,CAAC,CAAC;YACjC,IAAI,KAAK,GAAgB,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAEtC,oFAAoF;YACpF,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC9C,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC;oBAAC,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACnE,CAAC;YACD,EAAE,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,IAAI,CAAC;gBAAC,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;YAClE,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvD,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACxC,CAAC;QACD,YAAY,CAAC,OAAO,CAAC,UAAA,KAAK;YACxB,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC7B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC9C,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC;oBAAC,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACnE,CAAC;YACD,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvD,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,IAAI,CAAC;YAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;QAE7B,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACH,+BAAU,GAAV,UAAW,IAAc;QAAd,qBAAA,EAAA,SAAc;QACvB,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;QAChD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,OAAO,CAAC,OAAO,EAAf,CAAe,CAAC,CAAC,CAAC;IAClE,CAAC;IAED;;;;;;;OAOG;IACH,8BAAS,GAAT,UAAU,EAAU,EAAE,IAAc;QAApC,iBASC;QATqB,qBAAA,EAAA,SAAc;QAClC,IAAM,SAAS,GAAG;YAChB,GAAG,CAAC,CAAc,UAAY,EAAZ,KAAA,KAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY;gBAAzB,IAAI,KAAK,SAAA;gBACZ,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,CAAC;oBAAC,MAAM,CAAC,KAAK,CAAC;aACnC;QACH,CAAC,CAAC;QAEF,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAChC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,IAAI,MAAM,IAAI,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC;IACjG,CAAC;IAED;;;;;;;;OAQG;IACH,8BAAS,GAAT,UAAU,MAAiB;QACzB,IAAM,aAAa,GAAG,UAAC,KAAY,EAAE,GAAQ;YACzC,OAAA,CAAC,KAAK,IAAI,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC;QAA9B,CAA8B,CAAC;QAEnC,MAAM,GAAG,MAAM,IAAI,EAAE,CAAC;QAEtB,0GAA0G;QAC1G,IAAI,WAAW,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAlC,CAAkC,CAAC,CAAC;QAC3F,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,UAAA,QAAQ,IAAI,OAAA,aAAa,CAAC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,EAA5C,CAA4C,CAAC,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC1G,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,2BAAM,GAAN,UAAO,MAAsB;QAAtB,uBAAA,EAAA,WAAsB;QAC3B,wEAAwE;QACxE,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAEnC,yEAAyE;QACzE,wBAAwB;QACxB,IAAI,qBAAqB,GAA+B,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,qBAAqB,CAAC;aAChG,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;aACnB,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,EAA/B,CAA+B,CAAC,CAAC;QAEnD,iDAAiD;QACjD,IAAI,WAAW,GAAwB,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,CAAC;aACrE,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;aACnB,GAAG,CAAC,UAAU,CAAC,CAAC;QAEzB,IAAM,SAAS,GAAG,UAAC,KAAmB,IAAK,OAAA,KAAK,CAAC,OAAO,KAAK,KAAK,EAAvB,CAAuB,CAAC;QACnE,EAAE,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACvE,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAED;;WAEG;QACH,oBAAoB,KAAY;YAC9B,2BAA2B;YAC3B,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;YAC1C,IAAI,OAAO,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACrC,IAAI,cAAc,GAAG,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;YACjD,kDAAkD;YAClD,IAAI,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC;YACnD,iDAAiD;YACjD,IAAI,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAEvC,MAAM,CAAC,EAAE,KAAK,OAAA,EAAE,KAAK,OAAA,EAAE,OAAO,SAAA,EAAE,cAAc,gBAAA,EAAE,MAAM,QAAA,EAAE,OAAO,SAAA,EAAE,CAAC;QACpE,CAAC;QAED,4EAA4E;QAC5E,IAAI,UAAU,GAAG,qBAAqB,CAAC,MAAM,CAAC,UAAC,GAAW,EAAE,CAAsB;YAChF,iEAAiE;YACjE,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;YAEhC,kCAAkC;YAC5B,IAAA,iBAAM,EAAE,mBAAO,EAAE,eAAK,CAAO;YAEnC,6DAA6D;YAC7D,EAAE,CAAC,CAAC,MAAM,KAAK,IAAI,CAAC;gBAAC,MAAM,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YACxE,4DAA4D;YAC5D,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAAC,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC;YAC1C,EAAE,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC;gBAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI;YACtC,EAAE,CAAC,CAAC,OAAO,IAAI,IAAI,CAAC;gBAAC,MAAM,CAAC,GAAG,CAAC;YAChC,2EAA2E;YAC3E,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBAAC,MAAM,CAAC,GAAG,GAAG,GAAG,CAAY,OAAO,EAAE,UAAU,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC9F,iEAAiE;YACjE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC,GAAG,GAAG,OAAO,CAAC;YACpC,mBAAmB;YACnB,MAAM,CAAC,GAAG,GAAG,kBAAkB,CAAU,OAAO,CAAC,CAAC;QACpD,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,yEAAyE;QACzE,mEAAmE;QACnE,IAAI,WAAW,GAAG,WAAW,CAAC,GAAG,CAAC,UAAC,YAA0B;YACrD,IAAA,0BAAK,EAAE,4BAAM,EAAE,8BAAO,EAAE,4CAAc,CAAkB;YAC9D,EAAE,CAAC,CAAC,OAAO,IAAI,IAAI,IAAI,CAAC,cAAc,IAAI,MAAM,KAAK,KAAK,CAAC,CAAC;gBAAC,MAAM,CAAC;YACpE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBAAC,OAAO,GAAG,CAAU,OAAO,CAAC,CAAC;YACpD,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC;gBAAC,MAAM,CAAC;YACjC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;gBAAC,OAAO,GAAG,GAAG,CAAY,OAAO,EAAE,kBAAkB,CAAC,CAAC;YAEtE,MAAM,CAAa,OAAQ,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAG,KAAK,CAAC,EAAE,SAAI,GAAK,EAApB,CAAoB,CAAC,CAAC;QAC/D,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAElD,wFAAwF;QACxF,MAAM,CAAC,UAAU,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,MAAI,WAAa,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IACtG,CAAC;IAED,cAAc;IACP,uBAAY,GAAnB,UAAoB,GAAW;QAC7B,MAAM,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,UAAA,CAAC,IAAI,OAAA,SAAO,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,WAAW,EAAI,EAAnD,CAAmD,CAAC,CAAC;IACzG,CAAC;IAED,0GAA0G;IACnG,gCAAqB,GAA5B,UAA6B,OAAmB;QAC9C,IAAI,cAAc,GAAG,OAAO,CAAC,SAAS,CAAC;QACvC,IAAI,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,KAAK,OAAO,CAAC,IAAI,EAA3B,CAA2B,CAAC,CAAC;QAC1E,MAAM,CAAC,WAAW,CAAC,cAAc,EAAE,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;aAC3D,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;aACnB,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAK,EAAE,IAAI,SAAS,CAAC,CAAC,CAAC,EAAxB,CAAwB,CAAC,CAAC;IAC7C,CAAC;IAED,+EAA+E;IACxE,sBAAW,GAAlB,UAAmB,OAAmB;QACpC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,KAAK,OAAO,CAAC,MAAM,EAA7B,CAA6B,CAAC,CAAC;IACpE,CAAC;IAED;;;;;;;;OAQG;IACI,kBAAO,GAAd,UAAe,CAAa,EAAE,CAAa;QACzC;;;;;;;;;WASG;QACH,IAAM,QAAQ,GAAG,UAAC,OAAmB;YACjC,OAAA,OAAO,CAAC,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ;gBAC7C,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,qBAAqB,CAAC;qBACpD,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;qBACnB,MAAM,CAAC,cAAc,EAAE,EAAE,CAAC;qBAC1B,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAjC,CAAiC,CAAC;qBAC3C,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;QAL5B,CAK4B,CAAC;QAEjC;;;;WAIG;QACH,IAAM,OAAO,GAAG,UAAC,OAAmB;YAChC,OAAA,OAAO,CAAC,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,OAAO;gBAC3C,QAAQ,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,UAAA,OAAO;oBAC3B,sDAAsD;oBACtD,EAAE,CAAC,CAAC,OAAO,KAAK,GAAG,CAAC;wBAAC,MAAM,CAAC,CAAC,CAAC;oBAC9B,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;wBAAC,MAAM,CAAC,CAAC,CAAC;oBAChC,EAAE,CAAC,CAAC,OAAO,YAAY,KAAK,CAAC;wBAAC,MAAM,CAAC,CAAC,CAAC;gBACzC,CAAC,CAAC;QANN,CAMM,CAAC;QAEX;;WAEG;QACH,IAAM,SAAS,GAAG,UAAC,CAAQ,EAAE,CAAQ,EAAE,MAAW;YAChD,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;YACzC,OAAO,CAAC,CAAC,MAAM,GAAG,GAAG;gBAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACtC,OAAO,CAAC,CAAC,MAAM,GAAG,GAAG;gBAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACxC,CAAC,CAAC;QAEF,IAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QACnD,SAAS,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;QACjC,IAAI,GAAG,EAAE,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAEpD,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAClC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAChC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;gBAAC,MAAM,CAAC,GAAG,CAAC;QAC5B,CAAC;QAED,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IA5bD,cAAc;IACP,wBAAa,GAAW,2BAA2B,CAAC;IA4b7D,iBAAC;CAAA,AA9bD,IA8bC;SA9bY,UAAU",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\nimport {\n  map, defaults, inherit, identity, unnest, tail, find, Obj, pairs, allTrueR, unnestR, arrayTuples\n} from \"../common/common\";\nimport { prop, propEq } from \"../common/hof\";\nimport { isArray, isString, isDefined } from \"../common/predicates\";\nimport { Param, DefType } from \"../params/param\";\nimport { ParamTypes } from \"../params/paramTypes\";\nimport { RawParams } from \"../params/interface\";\nimport { ParamFactory } from \"./interface\";\nimport { joinNeighborsR, splitOnDelim } from \"../common/strings\";\n\n/** @hidden */\nfunction quoteRegExp(string: any, param?: any) {\n  let surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n  if (!param) return result;\n\n  switch (param.squash) {\n    case false:\n      surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')]; break;\n    case true:\n      result = result.replace(/\\/$/, '');\n      surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n    default:\n      surroundPattern = [`(${param.squash}|`, ')?']; break;\n  }\n  return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n\n/** @hidden */\nconst memoizeTo = (obj: Obj, prop: string, fn: Function) =>\n    obj[prop] = obj[prop] || fn();\n\n/** @hidden */\nconst splitOnSlash = splitOnDelim('/');\n\n/** @hidden */\ninterface UrlMatcherCache {\n  segments?: any[];\n  weights?: number[];\n  path?: UrlMatcher[];\n  parent?: UrlMatcher;\n  pattern?: RegExp;\n}\n\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nexport class UrlMatcher {\n  /** @hidden */\n  static nameValidator: RegExp = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\n  /** @hidden */\n  private _cache: UrlMatcherCache = { path: [this] };\n  /** @hidden */\n  private _children: UrlMatcher[] = [];\n  /** @hidden */\n  private _params:   Param[]      = [];\n  /** @hidden */\n  private _segments: string[]     = [];\n  /** @hidden */\n  private _compiled: string[]     = [];\n\n  /** The pattern that was passed into the constructor */\n  public pattern: string;\n\n  /**\n   * @param pattern The pattern to compile into a matcher.\n   * @param paramTypes The [[ParamTypes]] registry\n   * @param config  A configuration object\n   * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n   * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n   */\n  constructor(pattern: string, paramTypes: ParamTypes, paramFactory: ParamFactory, public config?: any) {\n    this.pattern = pattern;\n    this.config = defaults(this.config, {\n      params: {},\n      strict: true,\n      caseInsensitive: false,\n      paramMap: identity\n    });\n\n    // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n    //   '*' name\n    //   ':' name\n    //   '{' name '}'\n    //   '{' name ':' regexp '}'\n    // The regular expression is somewhat complicated due to the need to allow curly braces\n    // inside the regular expression. The placeholder regexp breaks down as follows:\n    //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n    //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n    //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n    //    [^{}\\\\]+                       - anything other than curly braces or backslash\n    //    \\\\.                            - a backslash escape\n    //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n    let placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n        searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n        last = 0, m: RegExpExecArray, patterns: any[][] = [];\n\n    const checkParamErrors = (id: string) => {\n      if (!UrlMatcher.nameValidator.test(id)) throw new Error(`Invalid parameter name '${id}' in pattern '${pattern}'`);\n      if (find(this._params, propEq('id', id))) throw new Error(`Duplicate parameter name '${id}' in pattern '${pattern}'`);\n    };\n\n    // Split into static segments separated by path parameter placeholders.\n    // The number of segments is always 1 more than the number of parameters.\n    const matchDetails = (m: RegExpExecArray, isSearch: boolean) => {\n      // IE[78] returns '' for unmatched groups instead of null\n      let id = m[2] || m[3];\n      let regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n\n      const makeRegexpType = (regexp) => inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n        pattern: new RegExp(regexp, this.config.caseInsensitive ? 'i' : undefined)\n      });\n\n      return {\n        id,\n        regexp,\n        cfg:     this.config.params[id],\n        segment: pattern.substring(last, m.index),\n        type:    !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n      };\n    };\n\n    let p: any, segment: string;\n\n    while ((m = placeholder.exec(pattern))) {\n      p = matchDetails(m, false);\n      if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n      checkParamErrors(p.id);\n      this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n      this._segments.push(p.segment);\n      patterns.push([p.segment, tail(this._params)]);\n      last = placeholder.lastIndex;\n    }\n    segment = pattern.substring(last);\n\n    // Find any search parameter names and remove them from the last segment\n    let i = segment.indexOf('?');\n\n    if (i >= 0) {\n      let search = segment.substring(i);\n      segment = segment.substring(0, i);\n\n      if (search.length > 0) {\n        last = 0;\n\n        while ((m = searchPlaceholder.exec(search))) {\n          p = matchDetails(m, true);\n          checkParamErrors(p.id);\n          this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n          last = placeholder.lastIndex;\n          // check if ?&\n        }\n      }\n    }\n\n    this._segments.push(segment);\n    this._compiled = patterns.map(pattern => quoteRegExp.apply(null, pattern)).concat(quoteRegExp(segment));\n  }\n\n  /**\n   * Creates a new concatenated UrlMatcher\n   *\n   * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n   *\n   * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n   */\n  append(url: UrlMatcher): UrlMatcher {\n    this._children.push(url);\n    url._cache = {\n      path: this._cache.path.concat(url),\n      parent: this,\n      pattern: null,\n    };\n    return url;\n  }\n\n  /** @hidden */\n  isRoot(): boolean {\n    return this._cache.path[0] === this;\n  }\n\n  /** Returns the input pattern string */\n  toString(): string {\n    return this.pattern;\n  }\n\n  /**\n   * Tests the specified url/path against this matcher.\n   *\n   * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n   * parameter values.  Returns null if the path does not match.\n   *\n   * The returned object contains the values\n   * of any search parameters that are mentioned in the pattern, but their value may be null if\n   * they are not present in `search`. This means that search parameters are always treated\n   * as optional.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n   *   x: '1', q: 'hello'\n   * });\n   * // returns { id: 'bob', q: 'hello', r: null }\n   * ```\n   *\n   * @param path    The URL path to match, e.g. `$location.path()`.\n   * @param search  URL search parameters, e.g. `$location.search()`.\n   * @param hash    URL hash e.g. `$location.hash()`.\n   * @param options\n   *\n   * @returns The captured parameter values.\n   */\n  exec(path: string, search: any = {}, hash?: string, options: any = {}): RawParams {\n    let match = memoizeTo(this._cache, 'pattern', () => {\n      return new RegExp([\n        '^',\n        unnest(this._cache.path.map(prop('_compiled'))).join(''),\n        this.config.strict === false ? '\\/?' : '',\n        '$'\n      ].join(''), this.config.caseInsensitive ? 'i' : undefined);\n    }).exec(path);\n\n    if (!match) return null;\n\n    //options = defaults(options, { isolate: false });\n\n    let allParams:    Param[] = this.parameters(),\n        pathParams:   Param[] = allParams.filter(param => !param.isSearch()),\n        searchParams: Param[] = allParams.filter(param => param.isSearch()),\n        nPathSegments  = this._cache.path.map(urlm => urlm._segments.length - 1).reduce((a, x) => a + x),\n        values: RawParams = {};\n\n    if (nPathSegments !== match.length - 1)\n      throw new Error(`Unbalanced capture group in route '${this.pattern}'`);\n\n    function decodePathArray(string: string) {\n      const reverseString = (str: string) => str.split(\"\").reverse().join(\"\");\n      const unquoteDashes = (str: string) => str.replace(/\\\\-/g, \"-\");\n\n      let split = reverseString(string).split(/-(?!\\\\)/);\n      let allReversed = map(split, reverseString);\n      return map(allReversed, unquoteDashes).reverse();\n    }\n\n    for (let i = 0; i < nPathSegments; i++) {\n      let param: Param = pathParams[i];\n      let value: (any|any[]) = match[i + 1];\n\n      // if the param value matches a pre-replace pair, replace the value before decoding.\n      for (let j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n      if (value && param.array === true) value = decodePathArray(value);\n      if (isDefined(value)) value = param.type.decode(value);\n      values[param.id] = param.value(value);\n    }\n    searchParams.forEach(param => {\n      let value = search[param.id];\n      for (let j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n      if (isDefined(value)) value = param.type.decode(value);\n      values[param.id] = param.value(value);\n    });\n\n    if (hash) values[\"#\"] = hash;\n\n    return values;\n  }\n\n  /**\n   * @hidden\n   * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n   *\n   * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n   *    pattern has no parameters, an empty array is returned.\n   */\n  parameters(opts: any = {}): Param[] {\n    if (opts.inherit === false) return this._params;\n    return unnest(this._cache.path.map(matcher => matcher._params));\n  }\n\n  /**\n   * @hidden\n   * Returns a single parameter from this UrlMatcher by id\n   *\n   * @param id\n   * @param opts\n   * @returns {T|Param|any|boolean|UrlMatcher|null}\n   */\n  parameter(id: string, opts: any = {}): Param {\n    const findParam = () => {\n      for (let param of this._params) {\n        if (param.id === id) return param;\n      }\n    };\n\n    let parent = this._cache.parent;\n    return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n  }\n\n  /**\n   * Validates the input parameter values against this UrlMatcher\n   *\n   * Checks an object hash of parameters to validate their correctness according to the parameter\n   * types of this `UrlMatcher`.\n   *\n   * @param params The object hash of parameters to validate.\n   * @returns Returns `true` if `params` validates, otherwise `false`.\n   */\n  validates(params: RawParams): boolean {\n    const validParamVal = (param: Param, val: any) =>\n        !param || param.validates(val);\n\n    params = params || {};\n\n    // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n    let paramSchema = this.parameters().filter(paramDef => params.hasOwnProperty(paramDef.id));\n    return paramSchema.map(paramDef => validParamVal(paramDef, params[paramDef.id])).reduce(allTrueR, true);\n  }\n\n  /**\n   * Given a set of parameter values, creates a URL from this UrlMatcher.\n   *\n   * Creates a URL that matches this pattern by substituting the specified values\n   * for the path and search parameters.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n   * // returns '/user/bob?q=yes'\n   * ```\n   *\n   * @param values  the values to substitute for the parameters in this pattern.\n   * @returns the formatted URL (path and optionally search part).\n   */\n  format(values: RawParams = {}) {\n    // Build the full path of UrlMatchers (including all parent UrlMatchers)\n    let urlMatchers = this._cache.path;\n\n    // Extract all the static segments and Params (processed as ParamDetails)\n    // into an ordered array\n    let pathSegmentsAndParams: Array<string|ParamDetails> = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(unnestR, [])\n            .map(x => isString(x) ? x : getDetails(x));\n\n    // Extract the query params into a separate array\n    let queryParams: Array<ParamDetails> = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(unnestR, [])\n            .map(getDetails);\n\n    const isInvalid = (param: ParamDetails) => param.isValid === false;\n    if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n      return null;\n    }\n\n    /**\n     * Given a Param, applies the parameter value, then returns detailed information about it\n     */\n    function getDetails(param: Param): ParamDetails {\n      // Normalize to typed value\n      let value = param.value(values[param.id]);\n      let isValid = param.validates(value);\n      let isDefaultValue = param.isDefaultValue(value);\n      // Check if we're in squash mode for the parameter\n      let squash = isDefaultValue ? param.squash : false;\n      // Allow the Parameter's Type to encode the value\n      let encoded = param.type.encode(value);\n\n      return { param, value, isValid, isDefaultValue, squash, encoded };\n    }\n\n    // Build up the path-portion from the list of static segments and parameters\n    let pathString = pathSegmentsAndParams.reduce((acc: string, x: string|ParamDetails) => {\n      // The element is a static segment (a raw string); just append it\n      if (isString(x)) return acc + x;\n\n      // Otherwise, it's a ParamDetails.\n      let { squash, encoded, param } = x;\n\n      // If squash is === true, try to remove a slash from the path\n      if (squash === true) return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n      // If squash is a string, use the string for the param value\n      if (isString(squash)) return acc + squash;\n      if (squash !== false) return acc; // ?\n      if (encoded == null) return acc;\n      // If this parameter value is an array, encode the value using encodeDashes\n      if (isArray(encoded)) return acc + map(<string[]> encoded, UrlMatcher.encodeDashes).join(\"-\");\n      // If the parameter type is \"raw\", then do not encodeURIComponent\n      if (param.raw) return acc + encoded;\n      // Encode the value\n      return acc + encodeURIComponent(<string> encoded);\n    }, \"\");\n\n    // Build the query string by applying parameter values (array or regular)\n    // then mapping to key=value, then flattening and joining using \"&\"\n    let queryString = queryParams.map((paramDetails: ParamDetails) => {\n      let { param, squash, encoded, isDefaultValue } = paramDetails;\n      if (encoded == null || (isDefaultValue && squash !== false)) return;\n      if (!isArray(encoded)) encoded = [<string> encoded];\n      if (encoded.length === 0) return;\n      if (!param.raw) encoded = map(<string[]> encoded, encodeURIComponent);\n\n      return (<string[]> encoded).map(val => `${param.id}=${val}`);\n    }).filter(identity).reduce(unnestR, []).join(\"&\");\n\n    // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n    return pathString + (queryString ? `?${queryString}` : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n  }\n\n  /** @hidden */\n  static encodeDashes(str: string) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, c => `%5C%${c.charCodeAt(0).toString(16).toUpperCase()}`);\n  }\n\n  /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n  static pathSegmentsAndParams(matcher: UrlMatcher) {\n    let staticSegments = matcher._segments;\n    let pathParams = matcher._params.filter(p => p.location === DefType.PATH);\n    return arrayTuples(staticSegments, pathParams.concat(undefined))\n        .reduce(unnestR, [])\n        .filter(x => x !== \"\" && isDefined(x));\n  }\n\n  /** @hidden Given a matcher, return an array with the matcher's query params */\n  static queryParams(matcher: UrlMatcher): Param[] {\n    return matcher._params.filter(p => p.location === DefType.SEARCH);\n  }\n\n  /**\n   * Compare two UrlMatchers\n   *\n   * This comparison function converts a UrlMatcher into static and dynamic path segments.\n   * Each static path segment is a static string between a path separator (slash character).\n   * Each dynamic segment is a path parameter.\n   *\n   * The comparison function sorts static segments before dynamic ones.\n   */\n  static compare(a: UrlMatcher, b: UrlMatcher): number {\n    /**\n     * Turn a UrlMatcher and all its parent matchers into an array\n     * of slash literals '/', string literals, and Param objects\n     *\n     * This example matcher matches strings like \"/foo/:param/tail\":\n     * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n     * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n     *\n     * Caches the result as `matcher._cache.segments`\n     */\n    const segments = (matcher: UrlMatcher) =>\n        matcher._cache.segments = matcher._cache.segments ||\n            matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                .reduce(unnestR, [])\n                .reduce(joinNeighborsR, [])\n                .map(x => isString(x) ? splitOnSlash(x) : x)\n                .reduce(unnestR, []);\n\n    /**\n     * Gets the sort weight for each segment of a UrlMatcher\n     *\n     * Caches the result as `matcher._cache.weights`\n     */\n    const weights = (matcher: UrlMatcher) =>\n        matcher._cache.weights = matcher._cache.weights ||\n            segments(matcher).map(segment => {\n              // Sort slashes first, then static strings, the Params\n              if (segment === '/') return 1;\n              if (isString(segment)) return 2;\n              if (segment instanceof Param) return 3;\n            });\n\n    /**\n     * Pads shorter array in-place (mutates)\n     */\n    const padArrays = (l: any[], r: any[], padVal: any) => {\n      const len = Math.max(l.length, r.length);\n      while (l.length < len) l.push(padVal);\n      while (r.length < len) r.push(padVal);\n    };\n\n    const weightsA = weights(a), weightsB = weights(b);\n    padArrays(weightsA, weightsB, 0);\n    let cmp, i, pairs = arrayTuples(weightsA, weightsB);\n\n    for (i = 0; i < pairs.length; i++) {\n      cmp = pairs[i][0] - pairs[i][1];\n      if (cmp !== 0) return cmp;\n    }\n\n    return 0;\n  }\n}\n\n/** @hidden */\ninterface ParamDetails {\n  param: Param;\n  value: any;\n  isValid: boolean;\n  isDefaultValue: boolean;\n  squash: (boolean|string);\n  encoded: (string|string[]);\n}\n"
  ]
}