{
  "version": 3,
  "file": "transitionHook.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/transitionHook.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nimport { TransitionHookOptions, HookResult, TransitionHookPhase } from './interface';\nimport { defaults, noop, silentRejection } from '../common/common';\nimport { fnToString, maxLength } from '../common/strings';\nimport { isPromise } from '../common/predicates';\nimport { is, parse } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { Rejection } from './rejectFactory';\nimport { TargetState } from '../state/targetState';\nimport { Transition } from './transition';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\nimport { StateDeclaration } from '../state/interface';\n\nlet defaultOptions: TransitionHookOptions = {\n  current: noop,\n  transition: null,\n  traceData: {},\n  bind: null,\n};\n\nexport type GetResultHandler = (hook: TransitionHook) => ResultHandler;\nexport type GetErrorHandler  = (hook: TransitionHook) => ErrorHandler;\n\nexport type ResultHandler = (result: HookResult)      => Promise<HookResult>;\nexport type ErrorHandler  = (error: any)              => Promise<any>;\n\n/** @hidden */\nexport class TransitionHook {\n  type: TransitionEventType;\n  constructor(private transition: Transition,\n              private stateContext: StateDeclaration,\n              private registeredHook: RegisteredHook,\n              private options: TransitionHookOptions) {\n    this.options = defaults(options, defaultOptions);\n    this.type = registeredHook.eventType;\n  }\n\n  /**\n   * These GetResultHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static HANDLE_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) =>\n      hook.handleHookResult(result);\n\n  /**\n   * If the result is a promise rejection, log it.\n   * Otherwise, ignore the result.\n   */\n  static LOG_REJECTED_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) => {\n    isPromise(result) && result.catch(err =>\n        hook.logError(Rejection.normalize(err)));\n    return undefined;\n  }\n\n  /**\n   * These GetErrorHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static LOG_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) =>\n      hook.logError(error);\n\n  static REJECT_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) =>\n      silentRejection(error);\n\n  static THROW_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => {\n    throw error;\n  }\n\n  private isSuperseded = () =>\n    this.type.hookPhase === TransitionHookPhase.RUN && !this.options.transition.isActive();\n\n  logError(err): any {\n    this.transition.router.stateService.defaultErrorHandler()(err);\n  }\n\n  invokeHook(): Promise<HookResult> | void {\n    let hook = this.registeredHook;\n    if (hook._deregistered) return;\n\n    let notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    let options = this.options;\n    trace.traceHookInvocation(this, this.transition, options);\n\n    const invokeCallback = () =>\n        hook.callback.call(options.bind, this.transition, this.stateContext);\n\n    const normalizeErr = err =>\n        Rejection.normalize(err).toPromise();\n\n    const handleError = err =>\n        hook.eventType.getErrorHandler(this)(err);\n\n    const handleResult = result =>\n        hook.eventType.getResultHandler(this)(result);\n\n    try {\n      let result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return result.catch(normalizeErr)\n            .then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  }\n\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   */\n  handleHookResult(result: HookResult): Promise<HookResult> {\n    let notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    // Hook returned a promise\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return result.then(val => this.handleHookResult(val));\n    }\n\n    trace.traceHookResult(result, this.transition, this.options);\n\n    // Hook returned false\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted(\"Hook aborted transition\").toPromise();\n    }\n\n    const isTargetState = is(TargetState);\n    // hook returned a TargetState\n    if (isTargetState(result)) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n  }\n\n\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * to a stopped router (disposed), or a new transition has started and superseded this one.\n   */\n  private getNotCurrentRejection() {\n    let router = this.transition.router;\n\n    // The router is stopped\n    if (router._disposed) {\n      return Rejection.aborted(`UIRouter instance #${router.$id} has been stopped (disposed)`).toPromise();\n    }\n\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    }\n\n    // This transition is no longer current.\n    // Another transition started while this hook was still running.\n    if (this.isSuperseded()) {\n      // Abort this transition\n      return Rejection.superseded(this.options.current()).toPromise();\n    }\n  }\n\n  toString() {\n    let { options, registeredHook } = this;\n    let event = parse(\"traceData.hookType\")(options) || \"internal\",\n        context = parse(\"traceData.context.state.name\")(options) || parse(\"traceData.context\")(options) || \"unknown\",\n        name = fnToString(registeredHook.callback);\n    return `${event} context: ${context}, ${maxLength(200, name)}`;\n  }\n\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param hooks the list of hooks to chain together\n   * @param waitFor if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n  static chain(hooks: TransitionHook[], waitFor?: Promise<any>): Promise<any> {\n    // Chain the next hook off the previous\n    const createHookChainR = (prev: Promise<any>, nextHook: TransitionHook) =>\n        prev.then(() => nextHook.invokeHook());\n    return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n  }\n\n\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param hooks the list of TransitionHooks to invoke\n   * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns a promise for the async result, or the result of the callback\n   */\n  static invokeHooks<T>(hooks: TransitionHook[], doneCallback: (result?: HookResult) => T): Promise<any> | T {\n    for (let idx = 0; idx < hooks.length; idx++) {\n      let hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        let remainingHooks = hooks.slice(idx + 1);\n\n        return TransitionHook.chain(remainingHooks, hookResult)\n            .then(doneCallback);\n      }\n    }\n\n    return doneCallback();\n  }\n\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   */\n  static runAllHooks(hooks: TransitionHook[]): void {\n    hooks.forEach(hook => hook.invokeHook());\n  }\n\n}\n"
  ]
}