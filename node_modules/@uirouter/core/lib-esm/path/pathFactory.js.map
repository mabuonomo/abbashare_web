{
  "version": 3,
  "file": "pathFactory.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/path/pathFactory.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @module path */ /** for typedoc */\n\nimport {\n  extend, find, pick, omit, tail, mergeR, values, unnestR, Predicate, inArray, arrayTuples,\n} from \"../common/common\";\nimport {prop, propEq, not} from \"../common/hof\";\n\nimport {RawParams} from \"../params/interface\";\nimport {TreeChanges} from \"../transition/interface\";\nimport {ViewConfig} from \"../view/interface\";\nimport {_ViewDeclaration} from \"../state/interface\";\n\nimport {StateObject} from \"../state/stateObject\";\nimport {TargetState} from \"../state/targetState\";\nimport {GetParamsFn, PathNode} from \"./pathNode\";\nimport {ViewService} from \"../view/view\";\nimport { Param } from '../params/param';\nimport { StateRegistry } from '../state';\n\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nexport class PathUtils {\n\n  constructor() { }\n\n  /** Given a PathNode[], create an TargetState */\n  static makeTargetState(registry: StateRegistry, path: PathNode[]): TargetState {\n    let state = tail(path).state;\n    return new TargetState(registry, state, path.map(prop(\"paramValues\")).reduce(mergeR, {}), {});\n  }\n\n  static buildPath(targetState: TargetState) {\n    let toParams = targetState.params();\n    return targetState.$state().path.map(state => new PathNode(state).applyRawParams(toParams));\n  }\n\n  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n  static buildToPath(fromPath: PathNode[], targetState: TargetState): PathNode[] {\n    let toPath: PathNode[] = PathUtils.buildPath(targetState);\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n    }\n    return toPath;\n  }\n\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   */\n  static applyViewConfigs($view: ViewService, path: PathNode[], states: StateObject[]) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path.filter(node => inArray(states, node.state)).forEach(node => {\n      let viewDecls: _ViewDeclaration[] = values(node.state.views || {});\n      let subPath = PathUtils.subPath(path, n => n === node);\n      let viewConfigs: ViewConfig[][] = viewDecls.map(view => $view.createViewConfig(subPath, view));\n      node.views = viewConfigs.reduce(unnestR, []);\n    });\n  }\n\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   */\n  static inheritParams(fromPath: PathNode[], toPath: PathNode[], toKeys: string[] = []): PathNode[] {\n    function nodeParamVals(path: PathNode[], state: StateObject): RawParams {\n      let node: PathNode = find(path, propEq('state', state));\n      return extend({}, node && node.paramValues);\n    }\n\n    let noInherit = fromPath.map(node => node.paramSchema)\n        .reduce(unnestR, [])\n        .filter(param => !param.inherit)\n        .map(prop('id'));\n\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     */\n    function makeInheritedParamsNode(toNode: PathNode): PathNode {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      let toParamVals = extend({}, toNode && toNode.paramValues);\n      // limited to only those keys found in toParams\n      let incomingParamVals = pick(toParamVals, toKeys);\n      toParamVals = omit(toParamVals, toKeys);\n      let fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n      // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n      let ownParamVals: RawParams = extend(toParamVals, fromParamVals, incomingParamVals);\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    }\n\n    // The param keys specified by the incoming toParams\n    return <PathNode[]> toPath.map(makeInheritedParamsNode);\n  }\n\n  static nonDynamicParams = (node: PathNode): Param[] =>\n      node.state.parameters({ inherit: false })\n          .filter(param => !param.dynamic);\n\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   */\n  static treeChanges(fromPath: PathNode[], toPath: PathNode[], reloadState: StateObject): TreeChanges {\n    let keep = 0, max = Math.min(fromPath.length, toPath.length);\n\n    const nodesMatch = (node1: PathNode, node2: PathNode) =>\n        node1.equals(node2, PathUtils.nonDynamicParams);\n\n    while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n      keep++;\n    }\n\n    /** Given a retained node, return a new node which uses the to node's param values */\n    function applyToParams(retainedNode: PathNode, idx: number): PathNode {\n      let cloned = PathNode.clone(retainedNode);\n      cloned.paramValues = toPath[idx].paramValues;\n      return cloned;\n    }\n\n    let from: PathNode[], retained: PathNode[], exiting: PathNode[], entering: PathNode[], to: PathNode[];\n\n    from                  = fromPath;\n    retained              = from.slice(0, keep);\n    exiting               = from.slice(keep);\n\n    // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n    let retainedWithToParams  = retained.map(applyToParams);\n    entering              = toPath.slice(keep);\n    to                    = (retainedWithToParams).concat(entering);\n\n    return { from, to, retained, exiting, entering };\n  }\n\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param pathA the first path\n   * @param pathB the second path\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   *\n   * @returns an array of PathNodes from the first path which match the nodes in the second path\n   */\n  static matching(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): PathNode[] {\n    let done = false;\n    let tuples: PathNode[][] = arrayTuples(pathA, pathB);\n    return tuples.reduce((matching, [nodeA, nodeB]) => {\n      done = done || !nodeA.equals(nodeB, paramsFn);\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  }\n\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param pathA\n   * @param pathB\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n  static equals(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): boolean {\n    return pathA.length === pathB.length &&\n        PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n  }\n\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   *\n   * @param path a path of [[PathNode]]s\n   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns a subpath up to the matching node, or undefined if no match is found\n   */\n  static subPath(path: PathNode[], predicate: Predicate<PathNode>): PathNode[] {\n    let node = find(path, predicate);\n    let elementIdx = path.indexOf(node);\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  }\n\n  /** Gets the raw parameter values from a path */\n  static paramValues = (path: PathNode[]) =>\n      path.reduce((acc, node) => extend(acc, node.paramValues), {});\n}\n"
  ]
}