{
  "version": 3,
  "file": "templateFactory.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/angularjs/templateFactory.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @module view */\n/** for typedoc */\nimport { ng as angular } from \"./angular\";\nimport { IAugmentedJQuery } from \"angular\";\nimport {\n  isArray, isDefined, isFunction, isObject, services, Obj, IInjectable, tail, kebobString, unnestR, ResolveContext,\n  Resolvable, RawParams\n} from \"@uirouter/core\";\nimport { Ng1ViewDeclaration, TemplateFactoryProvider } from \"./interface\";\n\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nexport class TemplateFactory implements TemplateFactoryProvider {\n  /** @hidden */ private _useHttp = angular.version.minor < 3;\n  /** @hidden */ private $templateRequest;\n  /** @hidden */ private $templateCache;\n  /** @hidden */ private $http;\n\n  /** @hidden */ $get = ['$http', '$templateCache', '$injector', ($http, $templateCache, $injector) => {\n    this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n    this.$http = $http;\n    this.$templateCache = $templateCache;\n    return this;\n  }];\n\n  /** @hidden */\n  useHttpService(value: boolean) {\n    this._useHttp = value;\n  };\n\n  /**\n   * Creates a template from a configuration object.\n   *\n   * @param config Configuration object for which to load a template.\n   * The following properties are search in the specified order, and the first one\n   * that is defined is used to create the template:\n   *\n   * @param params  Parameters to pass to the template function.\n   * @param context The resolve context associated with the template's view\n   *\n   * @return {string|object}  The template html as a string, or a promise for\n   * that string,or `null` if no template is configured.\n   */\n  fromConfig(config: Ng1ViewDeclaration, params: any, context: ResolveContext): Promise<{ template?: string, component?: string }> {\n    const defaultTemplate = \"<ui-view></ui-view>\";\n\n    const asTemplate  = (result) => services.$q.when(result).then(str => ({ template:  str }));\n    const asComponent = (result) => services.$q.when(result).then(str => ({ component: str }));\n\n    return (\n        isDefined(config.template)          ? asTemplate(this.fromString(config.template, params)) :\n        isDefined(config.templateUrl)       ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n        isDefined(config.templateProvider)  ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n        isDefined(config.component)         ? asComponent(config.component) :\n        isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n        asTemplate(defaultTemplate)\n    );\n  };\n\n  /**\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param template html template as a string or function that returns an html template as a string.\n   * @param params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that\n   * string.\n   */\n  fromString(template: (string | Function), params?: RawParams) {\n    return isFunction(template) ? (<any> template)(params) : template;\n  };\n\n  /**\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function\n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromUrl(url: (string | Function), params: any) {\n    if (isFunction(url)) url = (<any> url)(params);\n    if (url == null) return null;\n\n    if (this._useHttp) {\n      return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n          .then(function (response) {\n            return response.data;\n          });\n    }\n\n    return this.$templateRequest(url);\n  };\n\n  /**\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromProvider(provider: IInjectable, params: any, context: ResolveContext) {\n    let deps = services.$injector.annotate(provider);\n    let providerFn = isArray(provider) ? tail(<any[]> provider) : provider;\n    let resolvable = new Resolvable(\"\", <Function> providerFn, deps);\n    return resolvable.get(context);\n  };\n\n  /**\n   * Creates a component's template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  fromComponentProvider(provider: IInjectable, params: any, context: ResolveContext) {\n    let deps = services.$injector.annotate(provider);\n    let providerFn = isArray(provider) ? tail(<any[]> provider) : provider;\n    let resolvable = new Resolvable(\"\", <Function> providerFn, deps);\n    return resolvable.get(context);\n  };\n\n  /**\n   * Creates a template from a component's name\n   *\n   * This implements route-to-component.\n   * It works by retrieving the component (directive) metadata from the injector.\n   * It analyses the component's bindings, then constructs a template that instantiates the component.\n   * The template wires input and output bindings to resolves or from the parent component.\n   *\n   * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n   * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n   * @param component {string} Component's name in camel case.\n   * @param bindings An object defining the component's bindings: {foo: '<'}\n   * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  makeComponentTemplate(uiView: IAugmentedJQuery, context: ResolveContext, component: string, bindings?: any) {\n    bindings = bindings || {};\n\n    // Bind once prefix\n    const prefix = angular.version.minor >= 3 ? \"::\" : \"\";\n    // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n    const kebob = (camelCase: string) => {\n      const kebobed = kebobString(camelCase);\n      return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;\n    };\n\n\n    const attributeTpl = (input: BindingTuple) => {\n      let { name, type } = input;\n      let attrName = kebob(name);\n      // If the ui-view has an attribute which matches a binding on the routed component\n      // then pass that attribute through to the routed component template.\n      // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n      if (uiView.attr(attrName) && !bindings[name])\n        return `${attrName}='${uiView.attr(attrName)}'`;\n\n      let resolveName = bindings[name] || name;\n      // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n      // some-attr=\"{{ ::$resolve.someResolveName }}\"\n      if (type === '@')\n        return `${attrName}='{{${prefix}$resolve.${resolveName}}}'`;\n\n      // Wire \"&\" callbacks to resolves that return a callback function\n      // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n      // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n      if (type === '&') {\n        let res = context.getResolvable(resolveName);\n        let fn = res && res.data;\n        let args = fn && services.$injector.annotate(fn) || [];\n        // account for array style injection, i.e., ['foo', function(foo) {}]\n        let arrayIdxStr = isArray(fn) ? `[${fn.length - 1}]` : '';\n        return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(\",\")})'`;\n      }\n\n      // some-attr=\"::$resolve.someResolveName\"\n      return `${attrName}='${prefix}$resolve.${resolveName}'`;\n    };\n\n    let attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n    let kebobName = kebob(component);\n    return `<${kebobName} ${attrs}></${kebobName}>`;\n  };\n}\n\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name: string) {\n  let cmpDefs = <any[]> services.$injector.get(name + \"Directive\"); // could be multiple\n  if (!cmpDefs || !cmpDefs.length) throw new Error(`Unable to find component named '${name}'`);\n  return cmpDefs.map(getBindings).reduce(unnestR, []);\n}\n\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nconst getBindings = (def: any) => {\n  if (isObject(def.bindToController)) return scopeBindings(def.bindToController);\n  return scopeBindings(def.scope);\n};\n\ninterface BindingTuple {\n  name: string;\n  type: string;\n}\n\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nconst scopeBindings = (bindingsObj: Obj) => Object.keys(bindingsObj || {})\n    // [ 'input', [ '=foo', '=', 'foo' ] ]\n    .map(key => [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])])\n    // skip malformed values\n    .filter(tuple => isDefined(tuple) && isArray(tuple[1]))\n    // { name: ('foo' || 'input'), type: '=' }\n    .map(tuple => ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] } as BindingTuple));\n\n"
  ]
}